<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>DTracker v1 0</title>
  <!-- PWA manifest and theme color -->
  <link rel="manifest" href="./manifest.webmanifest">
  <meta name="theme-color" content="#0a6ed1">
  <!-- jsPDF and html2canvas for PDF generation -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" integrity="sha512-qZvrmS2ekKPF2mSznTQsxqPgnpkI4DNTlrdUmTzrDgektczlKNRRhy5X5AAOnx5S09ydFYWWNSfcEqDTTHgtNA==" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" integrity="sha512-BNaRQnYJYiPSqHHDb58B0yaPfCu+Wgds8Gp/gU33kqBtgNS4tSPHuGibyoeqMV/TJlSKda6FXzoEyYGjTe+vXA==" crossorigin="anonymous"></script>
<style>
  :root{
    --sap-shell-bg:#f7f7f7;
    --sap-panel:#ffffff;
    --sap-accent:#0a6ed1;
    --sap-accent-2:#0854a0;
    --sap-text:#222;
    --sap-muted:#6a6d70;
    --sap-border:#d9d9d9;
    --sap-success:#107e3e;
    --sap-warning:#e9730c;
    --sap-error:#bb0000;
    --radius:8px;
    --gap:12px;
  }
  
  /* Dark Mode Variables */
  body.dark-mode {
    --sap-shell-bg:#1a1a1a;
    --sap-panel:#2d2d2d;
    --sap-accent:#3d9bff;
    --sap-accent-2:#2d7dcc;
    --sap-text:#e0e0e0;
    --sap-muted:#a0a0a0;
    --sap-border:#404040;
    --sap-success:#4caf50;
    --sap-warning:#ff9800;
    --sap-error:#f44336;
  }
  
  body.dark-mode .app-header {
    background:linear-gradient(180deg,#1e3a5f 0%, #0d2744 100%);
  }
  
  body.dark-mode input[type="text"],
  body.dark-mode input[type="time"],
  body.dark-mode input[type="number"],
  body.dark-mode input[type="password"],
  body.dark-mode select {
    background:#3a3a3a;
    color:var(--sap-text);
    border-color:var(--sap-border);
  }
  
  body.dark-mode .table th {
    background:linear-gradient(180deg, #3a3a3a 0%, #2d2d2d 100%);
  }
  
  body.dark-mode .table td {
    background:#2d2d2d;
  }
  
  body.dark-mode .table tbody tr:hover td {
    background:#3a3a3a;
  }
  
  body.dark-mode .timeline-scale,
  body.dark-mode .timeline-right-header {
    background:linear-gradient(180deg, #3a3a3a 0%, #2d2d2d 100%);
  }
  
  body.dark-mode .timeline-control-cell {
    background:linear-gradient(180deg, #3a3a3a 0%, #2d2d2d 100%);
  }
  
  body.dark-mode .btn {
    background:#3a3a3a;
    color:var(--sap-text);
    border-color:var(--sap-border);
  }
  
  body.dark-mode .btn:hover:not(:disabled) {
    background:#4a4a4a;
  }

  body.dark-mode .panel {
    background:#242b33;
    border-color:rgba(255,255,255,0.08);
  }

  body.dark-mode .status-item .status-label {
    color:var(--sap-muted);
  }

  body.dark-mode .status-item .status-value {
    color:var(--sap-text);
  }

  body.dark-mode .time-display {
    background:#1e3a5f;
    border-color:#2d4f7f;
    color:#3d9bff;
  }
  
  body.dark-mode .info-box {
    background:#1e3a5f;
    border-color:#2d4f7f;
    color:#3d9bff;
  }

  .toast-container {
    position: fixed;
    top: 20px;
    right: 20px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    z-index: 100002;
  }

  .toast-message {
    min-width: 220px;
    max-width: 320px;
    background: var(--sap-panel);
    border: 1px solid var(--sap-border);
    border-radius: 8px;
    padding: 10px 14px;
    font-size: 13px;
    box-shadow: 0 4px 18px rgba(0,0,0,0.15);
    opacity: 0;
    transform: translateY(-6px);
    transition: opacity 0.3s ease, transform 0.3s ease;
  }

  .toast-message.show {
    opacity: 1;
    transform: translateY(0);
  }

  body.dark-mode .toast-message {
    background: rgba(30, 37, 43, 0.95);
    border-color: rgba(255,255,255,0.08);
    color: #f5f7fa;
  }

  #realtimeStatusPanel {
    transition: box-shadow 0.2s ease, transform 0.2s ease;
  }

  #realtimeStatusPanel .rt-panel-header {
    display: flex;
    align-items: flex-start;
    justify-content: space-between;
    gap: 8px;
  }

  #realtimeStatusPanel .rt-panel-header-buttons {
    display: inline-flex;
    gap: 4px;
  }

  #realtimeStatusPanel .rt-collapse-btn {
    padding: 4px 6px;
    border: 1px solid #ccc;
    border-radius: 6px;
    background: #f9f9fb;
    cursor: pointer;
    font-size: 12px;
    line-height: 1;
  }

  #realtimeStatusPanel.collapsed {
    box-shadow: 0 2px 6px rgba(0,0,0,0.05);
  }

  #realtimeStatusPanel.collapsed .rt-body {
    display: none;
  }

  #diagnosticsDrawer {
    position: fixed;
    right: 16px;
    bottom: 80px;
    width: 320px;
    max-height: 70vh;
    background: var(--sap-panel);
    border: 1px solid var(--sap-border);
    border-radius: 12px;
    box-shadow: 0 12px 32px rgba(15, 23, 42, 0.25);
    transform: translateY(110%);
    transition: transform 0.25s ease;
    display: flex;
    flex-direction: column;
    z-index: 100003;
    overflow: hidden;
  }

  #diagnosticsDrawer.open {
    transform: translateY(0);
  }

  #diagnosticsDrawer header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 16px;
    background: linear-gradient(135deg, rgba(10,110,209,0.1), rgba(8,84,160,0.15));
    border-bottom: 1px solid rgba(10,110,209,0.15);
  }

  #diagnosticsDrawer header h3 {
    margin: 0;
    font-size: 14px;
    letter-spacing: 0.3px;
    text-transform: uppercase;
  }

  #diagnosticsDrawer .diagnostics-body {
    padding: 12px 16px;
    overflow-y: auto;
  }

  #diagnosticsDrawer dl {
    margin: 0;
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 6px 8px;
    font-size: 12px;
  }

  #diagnosticsDrawer dl dt {
    color: var(--sap-muted);
  }

  #diagnosticsDrawer dl dd {
    margin: 0;
    font-weight: 600;
  }

  #diagnosticsDrawer .offline-queue {
    margin-top: 12px;
  }

  #diagnosticsDrawer .offline-queue h4,
  #diagnosticsDrawer .hooks h4,
  #diagnosticsDrawer .automation h4,
  #diagnosticsDrawer .snapshot h4 {
    margin: 12px 0 6px;
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--sap-muted);
  }

  #diagnosticsDrawer ul {
    margin: 0;
    padding-left: 18px;
    font-size: 11px;
  }

  #diagnosticsDrawer button.small {
    font-size: 11px;
    padding: 4px 8px;
  }

  .command-palette-overlay {
    position: fixed;
    inset: 0;
    background: rgba(15, 23, 42, 0.45);
    display: none;
    align-items: flex-start;
    justify-content: center;
    padding-top: 10vh;
    z-index: 100004;
  }

  .command-palette-overlay.show {
    display: flex;
  }

  .command-palette {
    width: min(520px, 90vw);
    background: var(--sap-panel);
    border-radius: 12px;
    border: 1px solid var(--sap-border);
    box-shadow: 0 24px 48px rgba(15, 23, 42, 0.35);
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  .command-palette input {
    border: none;
    padding: 12px 16px;
    font-size: 14px;
    outline: none;
    border-bottom: 1px solid var(--sap-border);
  }

  .command-palette ul {
    list-style: none;
    margin: 0;
    padding: 8px 0;
    max-height: 280px;
    overflow-y: auto;
  }

  .command-palette li {
    padding: 10px 16px;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .command-palette li.active,
  .command-palette li:hover {
    background: rgba(10,110,209,0.1);
  }

  .command-palette li span.shortcut {
    font-size: 11px;
    color: var(--sap-muted);
  }

  .onboarding-overlay {
    position: fixed;
    inset: 0;
    background: rgba(15, 23, 42, 0.6);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 100005;
  }

  .onboarding-overlay.show {
    display: flex;
  }

  .onboarding-card {
    width: min(440px, 90vw);
    background: var(--sap-panel);
    border-radius: 16px;
    padding: 20px 24px;
    box-shadow: 0 32px 64px rgba(15, 23, 42, 0.35);
  }

  .onboarding-card h2 {
    margin-top: 0;
    margin-bottom: 8px;
  }

  .onboarding-card footer {
    margin-top: 16px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .tour-highlight {
    position: relative;
    z-index: 100006 !important;
    box-shadow: 0 0 0 4px rgba(10,110,209,0.35);
    border-radius: 8px;
  }
  
  *{
    box-sizing: border-box;
  }
  
  html,body{
    margin:0;
    padding:0;
    background:var(--sap-shell-bg);
    color:var(--sap-text);
    font:14px/1.4 "72","Segoe UI",Roboto,Arial,sans-serif;
    min-height: 100vh;
    transition: background-color 0.3s ease, color 0.3s ease;
  }
  
  .app-header{
    background:linear-gradient(180deg,#0b74de 0%, #095cab 100%);
    color:#fff;
    padding:16px 24px;
    display:grid;
    grid-template-columns:auto minmax(0, 1fr) auto auto;
    align-items:center;
    gap:24px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.15);
    position: sticky;
    top: 0;
    z-index: 1000;
  }
  
  .brand{
    display:flex;
    align-items:center;
    gap:12px;
    flex-wrap:wrap;
  }
  
  .brand svg{
    height:28px;
    width:auto;
  }
  
  h1{
    margin:0;
    font-size:18px;
    font-weight:600;
    letter-spacing:.2px;
  }
  
  .header-completion {
    justify-self:center;
    display:flex;
    align-items:center;
    justify-content:center;
  }

  .header-status {
    justify-self:flex-end;
    display:flex;
    flex-direction:column;
    align-items:flex-end;
    gap:4px;
    text-align:right;
  }

  .header-actions {
    justify-self:flex-end;
    display:flex;
    align-items:center;
  }

  .header-focus-button {
    display:inline-flex;
    align-items:center;
    gap:8px;
    padding:8px 18px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,0.45);
    background:rgba(255,255,255,0.18);
    color:#fff;
    font-size:13px;
    font-weight:600;
    letter-spacing:0.3px;
    cursor:pointer;
    transition:background 0.2s ease,border-color 0.2s ease,transform 0.2s ease;
  }

  .header-focus-button:hover {
    background:rgba(255,255,255,0.28);
    border-color:rgba(255,255,255,0.6);
  }

  .header-focus-button:focus-visible {
    outline:2px solid rgba(255,255,255,0.75);
    outline-offset:2px;
  }

  .header-focus-button.active {
    background:rgba(255,255,255,0.34);
    border-color:rgba(255,255,255,0.8);
    box-shadow:0 0 0 2px rgba(10,116,222,0.4);
  }

  .header-focus-button .header-focus-icon {
    font-size:14px;
    line-height:1;
  }

  body.dark-mode .header-focus-button {
    background:rgba(61,155,255,0.25);
    border-color:rgba(61,155,255,0.5);
  }

  body.dark-mode .header-focus-button:hover {
    background:rgba(61,155,255,0.35);
    border-color:rgba(61,155,255,0.7);
  }

  @media (max-width: 900px) {
    .app-header {
      grid-template-columns: 1fr;
      text-align: center;
      gap:16px;
    }

    .brand {
      justify-self: center;
    }

    .header-completion,
    .header-status,
    .header-actions {
      justify-self:center;
    }
  }

  .status-item .status-meta {
    font-size:11px;
    color:var(--sap-muted);
  }

  .status-item .status-value {
    font-weight:600;
  }

  .btn.subtle {
    background:transparent;
    border:1px solid var(--sap-border);
    color:var(--sap-accent);
    padding:4px 8px;
    font-size:11px;
    border-radius:999px;
    transition:all 0.2s ease;
  }

  .btn.subtle:hover:not(:disabled) {
    background:rgba(10,110,209,0.1);
  }

  .btn.subtle:disabled {
    color:var(--sap-muted);
    border-color:rgba(0,0,0,0.05);
    cursor:not-allowed;
    background:rgba(0,0,0,0.03);
  }

  .control-request-banner {
    display:none;
    align-items:center;
    justify-content:space-between;
    gap:16px;
    background:linear-gradient(135deg, rgba(10,110,209,0.12), rgba(8,84,160,0.12));
    border:1px solid rgba(10,110,209,0.3);
    padding:12px 16px;
    border-radius:8px;
    margin-bottom:16px;
  }

  .control-request-banner.show {
    display:flex;
  }

  .control-request-banner strong {
    color:var(--sap-accent-2);
  }

  .control-request-timestamp {
    font-size:12px;
    color:var(--sap-muted);
  }

  .context-switch-toast {
    position:fixed;
    top:90px;
    right:24px;
    background:var(--sap-panel);
    color:var(--sap-text);
    border:1px solid var(--sap-border);
    border-radius:8px;
    box-shadow:0 8px 24px rgba(0,0,0,0.18);
    padding:12px 16px;
    z-index:2000;
    display:none;
    gap:12px;
    align-items:center;
  }

  .context-switch-toast.show {
    display:flex;
  }

  .context-switch-spinner {
    width:16px;
    height:16px;
    border-radius:50%;
    border:3px solid rgba(10,110,209,0.2);
    border-top-color:var(--sap-accent);
    animation:spin 1s linear infinite;
  }

  @keyframes spin {
    to { transform:rotate(360deg); }
  }

  .flash-update {
    animation:flashHighlight 1.4s ease;
  }

  @keyframes flashHighlight {
    0% { box-shadow:0 0 0 rgba(10,110,209,0); }
    20% { box-shadow:0 0 0 4px rgba(10,110,209,0.25); }
    100% { box-shadow:0 0 0 rgba(10,110,209,0); }
  }
  
  .status-item{
    display:flex;
    flex-direction:column;
    align-items:center;
  }
  
  .status-label{
    opacity:0.9;
    font-size:11px;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  
  .status-value{
    font-size:16px;
    font-weight:700;
  }
  
  /* Dark Mode Toggle Button */
  .dark-mode-toggle {
    background: rgba(255,255,255,0.2);
    border: 1px solid rgba(255,255,255,0.3);
    border-radius: 20px;
    padding: 6px 12px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    transition: all 0.3s ease;
  }
  
  .dark-mode-toggle:hover {
    background: rgba(255,255,255,0.3);
  }
  
  /* Full Screen Toggle Button */
  .fullscreen-toggle {
    background: rgba(255,255,255,0.2);
    border: 1px solid rgba(255,255,255,0.3);
    border-radius: 20px;
    padding: 6px 12px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 12px;
    transition: all 0.3s ease;
  }
  
  .fullscreen-toggle:hover {
    background: rgba(255,255,255,0.3);
  }
  
  .fullscreen-toggle.active {
    background: rgba(255,255,255,0.4);
    border-color: rgba(255,255,255,0.5);
  }
  
  /* Full Screen Mode Styles */
  body.fullscreen-mode .app-header {
    display: none;
  }

  body.fullscreen-mode .customer-info-panel {
    display: none !important;
  }

  body.fullscreen-mode .model-parameters-panel {
    display: none !important;
  }

  body.fullscreen-mode .content > *:not(#progressPanel) {
    display: none !important;
  }

  body.fullscreen-mode #progressPanel {
    margin-bottom: 0;
    height: calc(100vh - 32px);
    display: flex;
    flex-direction: column;
  }

  body.fullscreen-mode #progressPanel > :not(#focusExitControl):not(.timeline-container) {
    display: none !important;
  }

  .fullscreen-kpi {
    display: none;
    gap: 16px;
    margin-bottom: 12px;
    background: rgba(16, 126, 62, 0.08);
    border: 1px solid rgba(16, 126, 62, 0.2);
    border-radius: 10px;
    padding: 12px 16px;
  }

  body.fullscreen-mode .fullscreen-kpi {
    display: flex;
  }

  .fullscreen-kpi .kpi-item {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 4px;
    min-width: 100px;
  }

  .fullscreen-kpi .kpi-label {
    font-size: 11px;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: var(--sap-muted);
  }

  .fullscreen-kpi .kpi-value {
    font-size: 20px;
    font-weight: 700;
    color: var(--sap-primary);
  }

  body.fullscreen-mode .timeline-container {
    flex: 1;
    display: flex;
    min-height: 0;
  }

  body.fullscreen-mode .content {
    padding: 16px;
    height: 100vh;
    display: flex;
    flex-direction: column;
  }
  
  body.fullscreen-mode h1 {
    font-size: 16px;
  }
  
  body.fullscreen-mode .fullscreen-customer-info {
    display: flex !important;
    gap: 16px;
    align-items: center;
    font-size: 13px;
    padding: 4px 12px;
    background: rgba(255,255,255,0.1);
    border-radius: 6px;
  }

  body.fullscreen-mode #realtimeStatusPanel,
  body.fullscreen-mode #realtimeResetWrapper {
    display: none !important;
  }
  
  .fullscreen-customer-info {
    display: none;
  }
  
  .fullscreen-customer-info .info-item {
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  
  .fullscreen-customer-info .info-label {
    font-size: 10px;
    opacity: 0.8;
    text-transform: uppercase;
    letter-spacing: 0.5px;
  }
  
  .fullscreen-customer-info .info-value {
    font-size: 13px;
    font-weight: 600;
  }

  #focusExitControl {
    position: fixed;
    top: 16px;
    right: 16px;
    z-index: 1001;
    display: none;
  }

  #focusExitControl[hidden] {
    display: none !important;
  }

  .focus-exit-button {
    padding: 8px 14px;
    border-radius: 20px;
    border: 1px solid rgba(0,0,0,0.15);
    background: rgba(255,255,255,0.92);
    font-size: 12px;
    font-weight: 600;
    cursor: pointer;
    box-shadow: 0 2px 12px rgba(0,0,0,0.18);
    transition: background 0.2s ease, transform 0.2s ease;
  }

  .focus-exit-button:hover {
    background: rgba(240,240,240,0.95);
    transform: translateY(-1px);
  }

  body.dark-mode .focus-exit-button {
    background: rgba(20,30,40,0.9);
    color: #f1f5f9;
    border-color: rgba(255,255,255,0.12);
  }

  body.dark-mode .focus-exit-button:hover {
    background: rgba(35,45,55,0.95);
  }

  body.fullscreen-mode #focusExitControl {
    display: block;
  }
  
  /* Completion Progress */
  .completion-progress {
    display: flex;
    flex-direction: column;
    align-items: center;
    min-width: 160px;
    text-align: center;
    gap: 6px;
    width: min(100%, 320px);
  }
  
  .progress-bar-container {
    width: 100%;
    height: 8px;
    background: rgba(255,255,255,0.2);
    border-radius: 4px;
    overflow: hidden;
    margin-top: 4px;
  }
  
  .progress-bar-fill {
    height: 100%;
    background: linear-gradient(90deg, #4CAF50, #8BC34A);
    border-radius: 4px;
    transition: width 0.5s ease;
  }
  
  .progress-percentage {
    font-size: 16px;
    font-weight: 700;
  }
  
  /* Recent Customers Dropdown */
  .customer-input-wrapper {
    position: relative;
    flex: 1;
  }
  
  .recent-customers-btn {
    background: transparent;
    border: none;
    cursor: pointer;
    padding: 4px 8px;
    color: var(--sap-accent);
    font-size: 12px;
    transition: color 0.2s;
  }

  .recent-customers-btn:hover {
    color: var(--sap-accent-2);
  }

  .customer-input-group {
    position: relative;
    display: flex;
    align-items: center;
  }

  .customer-input-group input {
    flex: 1;
    padding-right: 80px;
  }

  .customer-input-actions {
    position: absolute;
    right: 0;
    top: 50%;
    transform: translateY(-50%);
    display: flex;
    gap: 4px;
  }

  .customer-input-actions .recent-customers-btn {
    position: static;
    padding: 4px 10px;
    font-size: 14px;
  }
  
  .recent-customers-dropdown {
    position: absolute;
    top: calc(100% + 4px);
    left: 0;
    right: 0;
    background: var(--sap-panel);
    border: 1px solid var(--sap-border);
    border-radius: 6px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    max-height: 200px;
    overflow-y: auto;
    z-index: 1000;
    display: none;
  }
  
  .recent-customers-dropdown.show {
    display: block;
  }
  
  .recent-customer-item {
    padding: 10px 12px;
    cursor: pointer;
    transition: background-color 0.2s;
    border-bottom: 1px solid var(--sap-border);
    font-size: 14px;
    display: flex;
    gap: 8px;
    align-items: center;
  }

  .recent-customer-item:last-child {
    border-bottom: none;
  }
  
  .recent-customer-item:hover {
    background: rgba(10,110,209,0.1);
  }
  
  .recent-customer-item-empty {
    padding: 20px;
    text-align: center;
    color: var(--sap-muted);
    font-size: 13px;
  }

  .recent-section-title {
    font-size: 11px;
    text-transform: uppercase;
    letter-spacing: 0.08em;
    color: var(--sap-muted);
    padding: 8px 12px 4px;
  }

  .recent-customer-item.bookmarked {
    font-weight: 600;
  }

  .recent-customer-item .recent-remove {
    margin-left: auto;
    background: transparent;
    border: none;
    color: var(--sap-muted);
    cursor: pointer;
    font-size: 12px;
    padding: 2px 4px;
  }

  .recent-customer-item .recent-remove:hover {
    color: var(--sap-error);
  }
  
  /* Enhanced Tooltip */
  .enhanced-tooltip {
    position: fixed;
    background: var(--sap-panel);
    border: 2px solid var(--sap-accent);
    border-radius: 8px;
    padding: 16px;
    box-shadow: 0 8px 24px rgba(0,0,0,0.2);
    z-index: 10000;
    pointer-events: none;
    display: none;
    min-width: 300px;
    max-width: 400px;
  }
  
  body.dark-mode .enhanced-tooltip {
    background: #2d2d2d;
    border-color: #3d9bff;
  }
  
  .enhanced-tooltip.show {
    display: block;
  }
  
  .tooltip-header {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 12px;
    padding-bottom: 12px;
    border-bottom: 1px solid var(--sap-border);
  }
  
  .tooltip-icon {
    font-size: 32px;
    width: 48px;
    height: 48px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 8px;
    background: linear-gradient(135deg, var(--sap-accent), var(--sap-accent-2));
    color: white;
  }
  
  .tooltip-title {
    flex: 1;
    font-size: 18px;
    font-weight: 600;
    color: var(--sap-text);
  }
  
  .tooltip-body {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }
  
  .tooltip-row {
    display: flex;
    align-items: center;
    gap: 8px;
    font-size: 14px;
  }
  
  .tooltip-label {
    font-weight: 600;
    color: var(--sap-muted);
    min-width: 100px;
  }
  
  .tooltip-value {
    color: var(--sap-text);
    display: flex;
    align-items: center;
    gap: 6px;
  }
  
  .status-icon {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    display: inline-block;
  }
  
  .status-icon.not-started { background: #9e9e9e; }
  .status-icon.in-progress { background: #2196f3; animation: pulse-dot 2s infinite; }
  .status-icon.blocked { background: #f44336; }
  .status-icon.completed { background: #4caf50; }
  .status-icon.skipped { background: #ff9800; }
  .status-icon.in-error { background: #d32f2f; animation: blink-error 1s infinite; }
  
  @keyframes pulse-dot {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.6; transform: scale(1.2); }
  }
  
  @keyframes blink-error {
    0%, 50%, 100% { opacity: 1; }
    25%, 75% { opacity: 0.4; }
  }
  
  /* Search/Filter Box */
  .search-filter-container {
    display: flex;
    gap: 12px;
    align-items: center;
    margin-bottom: 16px;
    flex-wrap: wrap;
  }
  
  .search-box {
    flex: 1;
    min-width: 250px;
    position: relative;
  }
  
  .search-box input {
    width: 100%;
    padding: 9px 36px 9px 12px;
  }
  
  .search-icon {
    position: absolute;
    right: 12px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--sap-muted);
    pointer-events: none;
  }
  
  .filter-controls {
    display: flex;
    gap: 8px;
    align-items: center;
  }
  
  .filter-tag {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 4px 10px;
    background: var(--sap-accent);
    color: white;
    border-radius: 16px;
    font-size: 12px;
  }
  
  .filter-tag button {
    background: none;
    border: none;
    color: white;
    cursor: pointer;
    padding: 0;
    margin: 0;
    font-size: 14px;
  }
  
  /* Template Management */
  .template-section {
    margin-top: 32px;
    padding-top: 24px;
    border-top: 2px solid var(--sap-border);
  }
  
  .template-controls {
    display: flex;
    gap: 12px;
    align-items: flex-end;
    flex-wrap: wrap;
  }
  
  .template-field {
    flex: 1;
    min-width: 200px;
  }
  
  .template-list {
    margin-top: 16px;
    border: 1px solid var(--sap-border);
    border-radius: 6px;
    overflow: hidden;
  }
  
  .template-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px;
    border-bottom: 1px solid var(--sap-border);
    transition: background-color 0.2s;
  }
  
  .template-item:last-child {
    border-bottom: none;
  }
  
  .template-item:hover {
    background: rgba(10,110,209,0.05);
  }
  
  .template-info {
    flex: 1;
  }
  
  .template-name {
    font-weight: 600;
    font-size: 14px;
    margin-bottom: 4px;
  }
  
  .template-meta {
    font-size: 12px;
    color: var(--sap-muted);
  }
  
  .template-actions {
    display: flex;
    gap: 8px;
  }
  
  /* Elapsed Time Badge */
  .elapsed-time-badge {
    position: absolute;
    bottom: -18px;
    left: 4px;
    font-size: 9px;
    padding: 1px 4px;
    border-radius: 3px;
    background: #fff3cd;
    color: #856404;
    border: 1px solid #ffe08a;
    pointer-events: none;
    font-weight: 600;
  }
  
  /* Task Status Indicators */
  .status-badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 11px;
    font-weight: 600;
    text-transform: uppercase;
  }
  
  .status-not-started {
    background: #e9ecef;
    color: #6c757d;
  }
  
  .status-in-progress {
    background: #cfe2ff;
    color: #084298;
    animation: pulse-status 2s infinite;
  }
  
  .status-blocked {
    background: #f8d7da;
    color: #842029;
  }
  
  .status-completed {
    background: #d1e7dd;
    color: #0f5132;
  }
  
  .status-skipped {
    background: #fff3cd;
    color: #997404;
  }
  
  .status-in-error {
    background: #f8d7da;
    color: #d32f2f;
    animation: pulse-status 2s infinite;
  }
  
  @keyframes pulse-status {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.7; }
  }
  
  .status-select {
    padding: 4px 8px;
    border-radius: 6px;
    font-size: 12px;
    border: 1px solid var(--sap-border);
  }
  
  /* Drag Handle for Row Reordering */
  .drag-handle {
    cursor: grab;
    padding: 4px;
    color: var(--sap-muted);
    display: inline-flex;
    align-items: center;
  }
  
  .drag-handle:active {
    cursor: grabbing;
  }
  
  .drag-handle:hover {
    color: var(--sap-accent);
  }
  
  tr.dragging {
    opacity: 0.5;
  }
  
  tr.drag-over {
    border-top: 2px solid var(--sap-accent);
  }
  
  /* Keyboard Shortcuts Help */
  .keyboard-shortcuts-help {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--sap-panel);
    border: 1px solid var(--sap-border);
    border-radius: 12px;
    box-shadow: 0 8px 32px rgba(0,0,0,0.2);
    padding: 24px;
    z-index: 10000;
    max-width: 500px;
    display: none;
  }
  
  .keyboard-shortcuts-help.show {
    display: block;
  }
  
  .keyboard-shortcuts-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.5);
    z-index: 9999;
    display: none;
  }
  
  .keyboard-shortcuts-overlay.show {
    display: block;
  }
  
  .shortcut-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 0;
    border-bottom: 1px solid var(--sap-border);
  }
  
  .shortcut-item:last-child {
    border-bottom: none;
  }
  
  .shortcut-key {
    background: #f8f9fa;
    padding: 4px 8px;
    border-radius: 4px;
    font-family: monospace;
    font-size: 12px;
    border: 1px solid var(--sap-border);
  }
  
  body.dark-mode .shortcut-key {
    background: #3a3a3a;
  }
  
  .content{
    padding:16px;
    max-width: 1600px;
    margin: 0 auto;
  }
  
  .panel{
    background:var(--sap-panel);
    border:1px solid var(--sap-border);
    border-radius:var(--radius);
    padding:20px;
    box-shadow:0 2px 4px rgba(0,0,0,.06);
    margin-bottom:16px;
  }

  .panel:hover {
    box-shadow: 0 4px 8px rgba(0,0,0,.1);
    transition: box-shadow 0.3s ease;
  }

  .panel-heading {
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:16px;
    margin-bottom:12px;
    flex-wrap:wrap;
  }

  .panel-heading h2 {
    margin:0;
  }

  .panel-utilities {
    display:flex;
    align-items:center;
    gap:8px;
    justify-content:flex-end;
    flex-wrap:wrap;
  }

  h2{
    margin:0 0 12px 0;
    font-size:18px;
    font-weight:600;
    color:var(--sap-text);
  }
  
  h3{
    margin:20px 0 10px 0;
    font-size:13px;
    color:var(--sap-accent);
    text-transform:uppercase;
    letter-spacing:.5px;
    font-weight:600;
  }
  
  .field{
    display:flex;
    flex-direction:column;
    gap:6px;
    margin-bottom:16px;
  }
  
  .field-row{
    display:flex;
    gap:16px;
    align-items:flex-end;
  }
  
  label{
    font-size:12px;
    color:var(--sap-muted);
    font-weight:500;
  }
  
  input[type="text"],
  input[type="time"],
  input[type="number"],
  input[type="password"],
  select{
    padding:9px 12px;
    border:1px solid var(--sap-border);
    border-radius:6px;
    background:#fff;
    color:var(--sap-text);
    font-size:14px;
    transition:border-color 0.2s, box-shadow 0.2s;
  }
  
  input[type="text"]:focus,
  input[type="time"]:focus,
  input[type="number"]:focus,
  input[type="password"]:focus,
  select:focus{
    outline:none;
    border-color:var(--sap-accent);
    box-shadow: 0 0 0 3px rgba(10,110,209,0.1);
  }
  
  input[type="number"]{
    text-align:right;
  }
  
  input[readonly],
  input:disabled,
  select:disabled{
    background:#f8fafb;
    cursor:default;
    opacity: 0.7;
  }
  
  body.dark-mode input[readonly],
  body.dark-mode input:disabled,
  body.dark-mode select:disabled {
    background:#252525;
  }
  
  .time-display{
    font-family:'Courier New', monospace;
    font-size:15px;
    font-weight:600;
    color:var(--sap-accent-2);
    padding:8px 12px;
    background:#f0f7ff;
    border:1px solid #cce0f5;
    border-radius:6px;
    min-width:100px;
    text-align:center;
  }

  .time-subtext {
    font-family: 'Courier New', monospace;
    font-size: 12px;
    color: var(--sap-muted);
    margin-top: 6px;
  }
  
  .time-input{
    font-family:'Courier New', monospace;
    font-size:15px;
    font-weight:600;
    color:var(--sap-accent-2);
    padding:8px 12px;
    background:#fff;
    border:1px solid #cce0f5;
    border-radius:6px;
    min-width:100px;
    text-align:center;
  }
  
  .time-input:focus{
    border-color:var(--sap-accent);
    box-shadow:0 0 0 2px rgba(10,110,209,0.1);
  }
  
  .table{
    width:100%;
    border-collapse:separate;
    border-spacing:0;
    margin-top:12px;
    border-radius:8px;
    overflow:hidden;
    box-shadow:0 2px 6px rgba(0,0,0,.1);
  }
  
  .table th,
  .table td{
    border-bottom:1px solid var(--sap-border);
    border-right:1px solid var(--sap-border);
    padding:10px;
    text-align:left;
    vertical-align:middle;
  }
  
  .table th:last-child,
  .table td:last-child{
    border-right:none;
  }
  
  .table tbody tr:last-child td{
    border-bottom:none;
  }
  
  .table th{
    background:linear-gradient(180deg, #f8fafb 0%, #f2f5f7 100%);
    font-weight:600;
    font-size:12px;
    color:var(--sap-text);
    text-transform:uppercase;
    letter-spacing:0.5px;
    position: sticky;
    top: 0;
  }
  
  .table td{
    background:#fff;
    font-size:14px;
  }
  
  .table tbody tr{
    transition: background-color 0.2s;
  }
  
  .table tbody tr:hover td{
    background:#f8fafb;
  }
  
  .table td.center,
  .table th.center{
    text-align:center;
  }
  
  .btn{
    padding:9px 14px;
    border-radius:6px;
    border:1px solid var(--sap-border);
    background:#fff;
    color:var(--sap-text);
    cursor:pointer;
    font-size:14px;
    font-weight:500;
    transition:all 0.2s;
    display: inline-flex;
    align-items: center;
    gap: 6px;
  }
  
  .btn:hover:not(:disabled){
    background:#f5f5f5;
    border-color:var(--sap-accent);
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  }
  
  .btn:active:not(:disabled){
    transform: translateY(0);
  }
  
  .btn:disabled{
    opacity: 0.5;
    cursor: not-allowed;
  }
  
  .btn.primary{
    background:var(--sap-accent);
    color:#fff;
    border-color:var(--sap-accent-2);
  }
  
  .btn.primary:hover:not(:disabled){
    background:var(--sap-accent-2);
  }
  
  .btn.warning{
    background:var(--sap-warning);
    color:#fff;
    border-color:#d96a0c;
  }
  
  .btn.warning:hover:not(:disabled){
    background:#d96a0c;
  }
  
  .btn.small{
    padding:6px 10px;
    font-size:12px;
  }
  
  .btn.danger{
    background:#fff;
    color:var(--sap-error);
    border-color:var(--sap-error);
  }
  
  .btn.danger:hover:not(:disabled){
    background:#fee;
    color:var(--sap-error);
  }
  
  .btnbar{
    display:flex;
    gap:8px;
    align-items:center;
    margin-top:16px;
    flex-wrap: wrap;
  }
  
  /* Timeline Styles */
  .timeline-container{
    background:#fff;
    border:1px solid var(--sap-border);
    border-radius:8px;
    padding:0;
    margin-top:16px;
    overflow-x:auto;
    position:relative;
    display:flex;
    width:100%;
    min-height: 200px;
  }
  
  body.dark-mode .timeline-container {
    background:#2d2d2d;
  }
  
  .timeline-header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    margin-bottom:20px;
    padding-bottom:12px;
    border-bottom:1px solid var(--sap-border);
    flex-wrap: wrap;
    gap: 16px;
  }
  
  .timeline-info{
    display:flex;
    gap:30px;
    flex-wrap: wrap;
  }
  
  .timeline-field{
    display:flex;
    flex-direction:column;
    gap:4px;
  }

  #downtimeControls{
    display:flex;
    flex-wrap:wrap;
    gap:8px;
    align-items:center;
  }

  #downtimeControls .btn{
    min-width:140px;
    justify-content:center;
  }

  #downtimeControls .btn:hover:not(:disabled){
    transform:none;
    box-shadow:0 2px 4px rgba(0,0,0,0.12);
  }

  #downtimeControls .btn:active:not(:disabled){
    transform:none;
  }

  #downtimeControls .downtime-host-message{
    font-size:12px;
    color:var(--sap-muted);
  }
  
  .timeline-field label{
    font-size:11px;
    color:var(--sap-muted);
  }
  
  .timeline-scroll{
    flex:1 1 auto;
    overflow-x:auto;
    overflow-y:hidden;
    position:relative;
  }
  
  .timeline-right{
    flex:0 0 270px;
    display:flex;
    flex-direction:column;
    border-left:2px solid var(--sap-border);
    background: #fafbfc;
  }
  
  body.dark-mode .timeline-right {
    background: #252525;
  }
  
  .timeline-right-header{
    display:grid;
    grid-template-columns:70px 70px 60px 70px;
    align-items:center;
    height:24px;
    background:linear-gradient(180deg, #f8fafb 0%, #f2f5f7 100%);
    border-bottom:1px solid var(--sap-border);
  }
  
  .timeline-right-header .header-cell{
    font-weight:600;
    font-size:10px;
    text-transform:uppercase;
    color:var(--sap-muted);
    display:flex;
    align-items:center;
    justify-content:center;
    border-right:1px solid #e5e5e5;
    padding:0;
    height:100%;
  }
  
  .timeline-right-header .header-cell:last-child{
    border-right:none;
  }
  
  #timelineControlsRows{
    display:flex;
    flex-direction:column;
  }
  
  .timeline-row{
    display:flex;
    align-items:center;
    height:28px;
    border-bottom:1px solid #e5e5e5;
    position:relative;
    transition:background 0.2s;
  }
  
  .timeline-row:hover{
    background:rgba(10,110,209,0.03);
  }
  
  .timeline-row:last-child{
    border-bottom:none;
  }
  
  .timeline-track{
    flex:0 0 auto;
    height:28px;
    position:relative;
    background-image:repeating-linear-gradient(
      90deg,
      transparent,
      transparent 59px,
      #e5e5e5 59px,
      #e5e5e5 60px
    );
    background-position:0 0;
    border-right:2px solid var(--sap-border);
  }
  
  .timeline-control-row{
    display:grid;
    grid-template-columns:70px 70px 60px 70px;
    height:28px;
    border-bottom:1px solid #e5e5e5;
  }
  
  .timeline-control-cell{
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:12px;
    color:var(--sap-text);
    background:linear-gradient(180deg, #fafbfc 0%, #f8f9fa 100%);
    border-right:1px solid #e5e5e5;
  }
  
  .timeline-control-row .timeline-control-cell:last-child{
    border-right:none;
  }
  
  .timeline-control-cell input[type="text"]{
    width:90%;
    text-align:center;
    border:1px solid #d5d5d5;
    border-radius:3px;
    font-size:11px;
    padding:2px 3px;
  }
  
  .timeline-control-cell input[type="text"]:focus{
    border-color:var(--sap-accent);
    box-shadow:0 0 0 2px rgba(10,110,209,0.1);
  }
  
  .timeline-control-cell input[type="checkbox"]{
    cursor:pointer;
    width:16px;
    height:16px;
    accent-color:var(--sap-success);
  }
  
  .timeline-scale{
    height:24px;
    position:relative;
    background:linear-gradient(180deg, #f8fafb 0%, #f2f5f7 100%);
    border-bottom:1px solid var(--sap-border);
    border-right:2px solid var(--sap-border);
    flex:0 0 auto;
  }
  
  .timeline-hour{
    position:absolute;
    font-size:10px;
    color:var(--sap-muted);
    top:5px;
    font-weight:600;
    user-select: none;
  }
  
  .timeline-hour:hover{
    color:var(--sap-accent);
  }
  
  .timeline-block{
    position:absolute;
    height:16px;
    top:6px;
    border-radius:3px;
    cursor:move;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:0 4px;
    color:#fff;
    font-size:9px;
    font-weight:600;
    transition:opacity 0.2s, transform 0.2s;
    box-shadow:0 1px 2px rgba(0,0,0,0.2);
    user-select:none;
    white-space:nowrap;
    overflow:visible;
    text-overflow:initial;
  }
  
  .timeline-block:hover{
    opacity:0.9;
    z-index:10;
    transform: scale(1.05);
  }
  
  .timeline-block.dragging{
    opacity:0.7;
    z-index:20;
  }
  
  .timeline-block.completed{
    background-image:repeating-linear-gradient(
      45deg,
      transparent,
      transparent 10px,
      rgba(255,255,255,0.3) 10px,
      rgba(255,255,255,0.3) 20px
    );
    opacity:0.4;
    filter: grayscale(100%);
  }
  
  /* Block label outside */
  .block-label-external{
    position:absolute;
    left:100%;
    margin-left:6px;
    white-space:nowrap;
    color:var(--sap-text);
    font-size:12px;
    font-weight:500;
    top:50%;
    transform:translateY(-50%);
    pointer-events:none;
    background: rgba(255,255,255,0.9);
    padding: 0 4px;
    border-radius: 3px;
  }
  
  body.dark-mode .block-label-external {
    background: rgba(45,45,45,0.95);
  }
  
  /* Quality gate label - horizontal and positioned on track */
  .quality-gate-label{
    white-space:nowrap;
    color:var(--sap-text);
    font-size:12px;
    font-weight:600;
    pointer-events:none;
    background: rgba(255,255,255,0.95);
    padding: 2px 6px;
    border-radius: 3px;
    box-shadow: 0 1px 3px rgba(0,0,0,0.1);
    z-index: 5;
  }
  
  body.dark-mode .quality-gate-label {
    background: rgba(45,45,45,0.95);
  }
  
  /* Critical path indicators */
  .timeline-block.critical {
    box-shadow: 0 0 8px rgba(255, 0, 0, 0.6), 0 2px 4px rgba(0,0,0,0.3);
    animation: pulse 2s infinite;
  }
  
  @keyframes pulse {
    0% { box-shadow: 0 0 8px rgba(255, 0, 0, 0.6), 0 2px 4px rgba(0,0,0,0.3); }
    50% { box-shadow: 0 0 16px rgba(255, 0, 0, 0.8), 0 2px 4px rgba(0,0,0,0.3); }
    100% { box-shadow: 0 0 8px rgba(255, 0, 0, 0.6), 0 2px 4px rgba(0,0,0,0.3); }
  }
  
  .critical-indicator {
    position: absolute;
    top: -6px;
    right: -6px;
    width: 14px;
    height: 14px;
    background: #ff0000;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-size: 9px;
    font-weight: bold;
    z-index: 100;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  }
  
  .table .critical-cell {
    text-align: center;
  }
  
  .critical-checkbox {
    cursor: pointer;
    width: 16px;
    height: 16px;
    accent-color: var(--sap-error);
  }
  
  .finish-line {
    position:absolute;
    top:0;
    bottom:0;
    width:2px;
    background:var(--sap-error);
    z-index:10;
    pointer-events: none;
  }
  
  .finish-line::before{
    content:'FINISH';
    position:absolute;
    top:-20px;
    left:50%;
    transform:translateX(-50%);
    font-size: 9px;
    font-weight: bold;
    color: var(--sap-error);
    white-space: nowrap;
  }
  
  .current-time-line{
    position:absolute;
    top:0;
    bottom:0;
    width:2px;
    background:#00ff00;
    z-index:15;
    pointer-events:none;
    box-shadow: 0 0 8px rgba(0,255,0,0.5);
  }
  
  .current-time-label{
    position:absolute;
    top:-22px;
    left:50%;
    transform:translateX(-50%);
    background:var(--sap-success);
    color:#fff;
    padding:2px 6px;
    border-radius:3px;
    font-size:10px;
    font-weight:600;
    white-space:nowrap;
  }
  
  /* Block Colors */
  .block-preparation{background:#795548;}
  .block-export{background:#4CAF50;}
  .block-import{background:#2196F3;}
  .block-quality{background:#FF9800;}
  .block-qualitygate{background:#FF9800;}
  .block-conversion{background:#9C27B0;}
  .block-validation{background:#00BCD4;}
  
  .runblock-name{
    font-size:10px;
    color:var(--sap-muted);
    white-space:nowrap;
    pointer-events:none;
  }
  
  .quality-diamond{
    position:absolute;
    width:14px;
    height:14px;
    background:#FF9800;
    transform:rotate(45deg);
    top:50%;
    margin-top:-7px;
    border-radius:2px;
    box-shadow:0 1px 2px rgba(0,0,0,0.2);
  }
  
  .legend{
    display:flex;
    gap:16px;
    margin-top:12px;
    padding-top:12px;
    border-top:1px solid var(--sap-border);
    font-size:12px;
    flex-wrap:wrap;
    align-items:center;
  }
  
  .legend-item{
    display:flex;
    align-items:center;
    gap:6px;
  }
  
  .legend-color{
    width:16px;
    height:16px;
    border-radius:3px;
  }
  
  .info-box{
    background:#f0f7ff;
    border:1px solid #cce0f5;
    border-radius:6px;
    padding:12px;
    margin-top:12px;
    font-size:12px;
    color:var(--sap-accent-2);
  }
  
  .btn.success{
    background:var(--sap-success);
    color:#fff;
    border-color:#0b6d34;
  }
  
  .btn.success:hover:not(:disabled){
    background:#0b6d34;
  }
  
  .hidden{
    display:none !important;
  }
  
  /* Validation warnings */
  .validation-warning {
    background: #fff3cd;
    border: 1px solid #ffc107;
    border-radius: 4px;
    padding: 8px 12px;
    margin: 8px 0;
    font-size: 12px;
    color: #856404;
    animation: slideDown 0.3s ease;
  }
  
  body.dark-mode .validation-warning {
    background: #664d03;
    border-color: #ffca2c;
    color: #ffecb5;
  }
  
  @keyframes slideDown {
    from { 
      opacity: 0;
      transform: translateY(-10px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
  
  .conflict-indicator {
    background: #ff6b6b;
    color: white;
    padding: 2px 6px;
    border-radius: 3px;
    font-size: 10px;
    font-weight: bold;
    margin-left: 4px;
  }
  
  @media print{
    body *{ visibility:hidden !important; }
    #progressPanel, #progressPanel *{ visibility:visible !important; }
    #progressPanel{ position:fixed; left:0; top:0; width:100%; }
    .timeline-container{ overflow:visible !important; }
    #rt-reset, #rt-copy { display: none !important; }
  }
  
  /* Ensure viewer mode readonly styling */
  .viewer-mode input:not(#rt-copy),
  .viewer-mode select,
  .viewer-mode textarea,
  .viewer-mode button:not(#rt-copy):not(#rt-reset):not(#reportBtn):not(#fullscreenToggle):not(#darkModeToggle):not(#rt-request-control) {
    pointer-events: none !important;
    opacity: 0.6 !important;
  }
  
  .viewer-mode .timeline-checkbox {
    pointer-events: none !important;
  }
  
  .viewer-mode .timeline-block {
    cursor: default !important;
  }
  
  .viewer-mode #rt-copy,
  .viewer-mode #rt-reset,
  .viewer-mode #reportBtn,
  .viewer-mode #fullscreenToggle,
  .viewer-mode #darkModeToggle {
    pointer-events: auto !important;
    opacity: 1 !important;
  }
  
  /* Performance improvements */
  .timeline-block, .quality-diamond {
    will-change: transform;
  }
  
  .current-time-line {
    will-change: left;
  }
  
  /* Status indicators */
  .sync-indicator {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    background: #9ca3af;
    display: inline-block;
    margin-left: 8px;
    box-shadow: 0 0 0 0 rgba(15,118,110,0.4);
  }

  .sync-indicator.online {
    background: #22c55e;
    animation: pulse-online 2s infinite;
  }

  .sync-indicator.degraded {
    background: #facc15;
    animation: pulse-degraded 3s infinite;
  }

  .sync-indicator.offline {
    background: #ef4444;
    animation: none;
  }

  .sync-indicator.pending {
    background: #60a5fa;
    animation: pulse-online 1.4s infinite;
  }

  @keyframes pulse-online {
    0% { box-shadow: 0 0 0 0 rgba(34,197,94,0.5); }
    70% { box-shadow: 0 0 0 6px rgba(34,197,94,0); }
    100% { box-shadow: 0 0 0 0 rgba(34,197,94,0); }
  }

  @keyframes pulse-degraded {
    0% { box-shadow: 0 0 0 0 rgba(250,204,21,0.5); }
    70% { box-shadow: 0 0 0 6px rgba(250,204,21,0); }
    100% { box-shadow: 0 0 0 0 rgba(250,204,21,0); }
  }
  
  /* Responsive design */
  @media (max-width: 768px) {
    .timeline-right {
      flex: 0 0 200px;
    }
    
    .timeline-right-header {
      grid-template-columns: 60px 60px 40px 40px;
    }
    
    .timeline-info {
      flex-direction: column;
      gap: 16px;
    }

    .header-status {
      align-items: center;
      text-align: center;
    }

    .panel-heading {
      justify-content: center;
      text-align: center;
    }

    .panel-utilities {
      justify-content: center;
    }
  }

/* --- Enhancements CSS --- */
.input-invalid{
  border-color:#ffc107 !important;
  box-shadow:0 0 0 3px rgba(255,193,7,.15) !important;
}

.conflict-overlay{
  position:absolute;
  top:0; bottom:0;
  background:rgba(255,0,0,0.08);
  border-top:1px dashed rgba(255,0,0,0.4);
  border-bottom:1px dashed rgba(255,0,0,0.4);
  pointer-events:none;
  z-index:5;
}

.slack-badge{
  position:absolute;
  bottom:-18px;
  right:4px;
  font-size:9px;
  padding:1px 4px;
  border-radius:3px;
  background:#e6ffed;
  color:#107e3e;
  border:1px solid #b7f5c7;
  pointer-events:none;
}

.quick-fix{
  position:absolute;
  top:-18px;
  right:4px;
  font-size:10px;
  padding:2px 6px;
  border-radius:3px;
  background:#fff3cd;
  color:#856404;
  border:1px solid #ffe08a;
  cursor:pointer;
}
.quick-fix:hover{ filter:brightness(0.95); }

/* === Message visibility toggle === */
.messages-off .validation-warning,
.messages-off #validationMessages,
.messages-off .conflict-indicator,
.messages-off .conflict-overlay,
.messages-off .slack-badge,
.messages-off .quick-fix,
.messages-off .info-box,
.messages-off [role="alert"] { 
  display: none !important; 
}

#messageToggleBtn{
  padding:6px 12px; 
  border:1px solid var(--sap-border); 
  border-radius:6px;
  background:var(--sap-panel); 
  cursor:pointer; 
  font-size:12px;
  transition: all 0.2s;
}

#messageToggleBtn:hover{
  background:#f5f5f5;
  border-color:var(--sap-accent);
}

body.dark-mode #messageToggleBtn:hover{
  background:#4a4a4a;
}

#messageToggleBtn[aria-pressed="true"]{ 
  font-weight:600;
  background: var(--sap-accent);
  color: white;
  border-color: var(--sap-accent-2);
}

</style>

<script src="https://res.cdn.office.net/teams-js/2.0.0/js/MicrosoftTeams.min.js" 
  integrity="sha384-QtTBFeFlfRDZBfwHJHYQp7MdLJ2C3sfAEB1Qpy+YblvjavBye+q87TELpTnvlXw4" 
  crossorigin="anonymous"></script>
</head>
<body>
  <!-- Enhanced Tooltip -->
  <div class="enhanced-tooltip" id="enhancedTooltip">
    <div class="tooltip-header">
      <div class="tooltip-icon" id="tooltipIcon">ðŸ“¦</div>
      <div class="tooltip-title" id="tooltipTitle">Runblock Name</div>
    </div>
    <div class="tooltip-body">
      <div class="tooltip-row">
        <span class="tooltip-label">Responsibility:</span>
        <span class="tooltip-value" id="tooltipResponsibility">â€”</span>
      </div>
      <div class="tooltip-row">
        <span class="tooltip-label">Status:</span>
        <span class="tooltip-value" id="tooltipStatus">
          <span class="status-icon" id="tooltipStatusIcon"></span>
          <span id="tooltipStatusText">â€”</span>
        </span>
      </div>
      <div class="tooltip-row">
        <span class="tooltip-label">Sequence:</span>
        <span class="tooltip-value" id="tooltipSequence">â€”</span>
      </div>
      <div class="tooltip-row">
        <span class="tooltip-label">Phase:</span>
        <span class="tooltip-value" id="tooltipPhase">â€”</span>
      </div>
      <div class="tooltip-row">
        <span class="tooltip-label">Strategy:</span>
        <span class="tooltip-value" id="tooltipStrategy">â€”</span>
      </div>
      <div class="tooltip-row">
        <span class="tooltip-label">Predecessor:</span>
        <span class="tooltip-value" id="tooltipPredecessor">â€”</span>
      </div>
      <div class="tooltip-row">
        <span class="tooltip-label">Start:</span>
        <span class="tooltip-value" id="tooltipStart">â€”</span>
      </div>
      <div class="tooltip-row">
        <span class="tooltip-label">Plan:</span>
        <span class="tooltip-value" id="tooltipPlan">â€”</span>
      </div>
    </div>
  </div>

  <div class="app-header">
    <div class="brand">
      <svg viewBox="0 0 100 28" xmlns="http://www.w3.org/2000/svg">
        <rect width="100" height="28" fill="#fff" rx="4"/>
        <text x="50" y="20" text-anchor="middle" font-family="Arial, sans-serif" font-size="18" font-weight="bold" fill="#0a6ed1">SNP</text>
      </svg>
      <h1>DTracker v1 0 <span class="sync-indicator" id="syncIndicator"></span></h1>
      <div class="fullscreen-customer-info" id="fullscreenCustomerInfo">
        <div class="info-item">
          <span class="info-label">Customer</span>
          <span class="info-value" id="fullscreenCustomerName">-</span>
        </div>
        <div class="info-item">
          <span class="info-label">Cycle</span>
          <span class="info-value" id="fullscreenTransformCycle">-</span>
        </div>
      </div>
    </div>
    <div class="header-completion">
      <div class="completion-progress">
        <span class="status-label">Completion</span>
        <span class="progress-percentage" id="completionPercentage">0%</span>
        <div class="progress-bar-container">
          <div class="progress-bar-fill" id="progressBarFill"></div>
        </div>
      </div>
    </div>
    <div class="header-status">
      <span class="status-label">Status</span>
      <span class="status-value" id="statusText" style="color:var(--sap-warning);">Not Started</span>
    </div>
    <div class="header-actions">
      <button type="button" class="header-focus-button" id="headerFocusButton" data-focus-toggle="true" aria-pressed="false">
        <span class="header-focus-icon" id="headerFocusIcon">â›¶</span>
        <span class="header-focus-text" id="headerFocusText">Focus</span>
      </button>
    </div>
  </div>

  <div class="context-switch-toast" id="contextSwitchToast" role="status" aria-live="polite">
    <div class="context-switch-spinner" aria-hidden="true"></div>
    <div>
      <div><strong>Loading sessionâ€¦</strong></div>
      <div class="status-meta" id="contextSwitchDetails">Retrieving latest runbooks</div>
    </div>
  </div>

  <div class="content">
    <div class="control-request-banner" id="controlRequestBanner" role="alert">
      <div>
        <div><strong id="controlRequestName">-</strong> is requesting host control</div>
        <div class="control-request-timestamp" id="controlRequestTimestamp">Just now</div>
      </div>
      <div style="display:flex;gap:8px;">
        <button class="btn primary" id="approveControlBtn">Approve takeover</button>
        <button class="btn" id="dismissControlBtn">Dismiss</button>
      </div>
    </div>

    <!-- Customer Information -->
    <div class="panel customer-info-panel" style="margin-bottom:16px;padding:16px;">
      <div class="field-row">
        <div class="field customer-input-wrapper">
          <label>Customer Name *</label>
          <div class="customer-input-group">
            <input type="text" id="customerName" placeholder="Enter customer name" value="">
            <div class="customer-input-actions">
              <button class="recent-customers-btn" id="bookmarkSessionBtn" title="Bookmark customer &amp; transform">â˜…</button>
              <button class="recent-customers-btn" id="recentCustomersBtn" title="Recent customers">â–¼</button>
            </div>
          </div>
          <div class="recent-customers-dropdown" id="recentCustomersDropdown">
            <!-- Recent customers will be populated here -->
          </div>
        </div>
        <div class="field" style="flex:1;">
          <label>Transform Cycle</label>
          <select id="transformCycle">
            <option value="Test Migration">Test Migration</option>
            <option value="Go Live Simulation">Go Live Simulation</option>
            <option value="Go-Live">Go-Live</option>
          </select>
        </div>
      </div>
    </div>
    
    <!-- Progress Tracking Section -->
    <div id="progressPanel" class="panel">
      <div id="focusExitControl" hidden>
        <button type="button" class="focus-exit-button" id="focusExitButton" title="Exit focus mode">Exit Focus</button>
      </div>
      <div class="panel-heading">
        <h2>Progress Tracking Window</h2>
        <div class="panel-utilities">
          <button type="button" class="fullscreen-toggle" id="fullscreenToggle" data-focus-toggle="true" title="Toggle full screen mode" aria-pressed="false">
            <span id="fullscreenIcon">â›¶</span>
            <span id="fullscreenText">Focus</span>
          </button>
          <button class="dark-mode-toggle" id="darkModeToggle" title="Toggle dark mode">
            <span id="darkModeIcon">ðŸŒ™</span>
            <span id="darkModeText">Dark</span>
          </button>
        </div>
      </div>
      <div id="fullscreenKpiSummary" class="fullscreen-kpi" aria-live="polite">
        <div class="kpi-item">
          <div class="kpi-label">Planned</div>
          <div class="kpi-value" id="kpiPlanned">0h</div>
        </div>
        <div class="kpi-item">
          <div class="kpi-label">Actual</div>
          <div class="kpi-value" id="kpiActual">0h</div>
        </div>
        <div class="kpi-item">
          <div class="kpi-label">Variance</div>
          <div class="kpi-value" id="kpiVariance">0h</div>
        </div>
      </div>

      <div class="timeline-header">
        <div class="timeline-info">
          <div class="timeline-field">
            <label>Technical Downtime Duration (hrs)</label>
            <input type="number" id="downtimeDuration" min="1" max="168" value="24"
                   onchange="updateTimeline();calculateEndTime()" style="width:80px;">
            <div class="time-subtext" id="plannedWindowTime">Planned: --:-- â†’ --:--</div>
          </div>
          <div class="timeline-field">
            <label>Start Time</label>
            <div id="startTimeContainer">
              <input type="time" id="startTimeInput" class="time-input"
                     onchange="calculateEndTime()" style="display:none;">
              <div class="time-display" id="startTimeDisplay">--:--:--</div>
              <div class="time-subtext" id="liveStartTime">Current: --:--:--</div>
            </div>
          </div>
          <div class="timeline-field">
            <label>Current Duration</label>
            <div id="currentDurationContainer">
              <input type="text" id="currentDurationInput" class="time-input" 
                     placeholder="HH:MM:SS" pattern="[0-9]{2}:[0-9]{2}:[0-9]{2}" style="display:none;">
              <div class="time-display" id="currentDurationDisplay">00:00:00</div>
            </div>
          </div>
          <div class="timeline-field">
            <label>Estimated End Time</label>
            <div class="time-display" id="endTimeDisplay">--:--:--</div>
          </div>
        </div>
        <div id="downtimeControls">
          <button class="btn primary" id="startDowntimeBtn" onclick="startDowntime()">Start Downtime</button>
        </div>
      </div>

      <div id="validationMessages"></div>

      <div class="timeline-container">
        <div class="timeline-scroll">
          <div class="timeline-table-header">
            <div class="timeline-scale" id="timelineScale">
              <!-- Hour markers will be generated here -->
            </div>
          </div>
          <div id="timelineRows">
            <!-- Timeline track rows will be generated here -->
          </div>
          <div id="finishLine" class="finish-line"></div>
          <div class="current-time-line" id="currentTimeLine" style="display:none;">
            <div class="current-time-label" id="currentTimeLabel">00:00:00</div>
          </div>
        </div>
        <div class="timeline-right">
          <div class="timeline-right-header">
            <div class="header-cell">START</div>
            <div class="header-cell">PLAN</div>
            <div class="header-cell">END</div>
            <div class="header-cell">ACTUAL</div>
          </div>
          <div id="timelineControlsRows">
            <!-- Timeline control rows will be generated here -->
          </div>
        </div>
      </div>
      
      <div class="legend">
        <div class="legend-item">
          <div class="legend-color block-preparation"></div>
          <span>Preparation</span>
        </div>
        <div class="legend-item">
          <div class="legend-color block-export"></div>
          <span>Export</span>
        </div>
        <div class="legend-item">
          <div class="legend-color block-import"></div>
          <span>Import</span>
        </div>
        <div class="legend-item">
          <div class="legend-color block-quality"></div>
          <span>Quality Gate</span>
        </div>
        <div class="legend-item">
          <div class="legend-color block-conversion"></div>
          <span>Conversion</span>
        </div>
        <div class="legend-item">
          <div class="legend-color block-validation"></div>
          <span>Validation</span>
        </div>
        <div class="legend-item">
          <div style="width:2px;height:16px;background:#00ff00;box-shadow:0 0 4px rgba(0,255,0,0.5);"></div>
          <span>Current Position</span>
        </div>
        <div class="legend-item">
          <div style="width:16px;height:16px;background:#ff0000;border-radius:50%;display:flex;align-items:center;justify-content:center;color:white;font-size:10px;font-weight:bold;">!</div>
          <span>Critical Path</span>
        </div>
        <div class="legend-item" style="margin-left:auto;">
          <button id="messageToggleBtn" type="button" aria-pressed="false" title="Show or hide all app messages & warnings">Messages: Off</button>
        </div>
        <button class="btn success" id="reportBtn" onclick="generatePDFReport()">ðŸ“„ PDF Report</button>
      </div>
    </div>

    <!-- Model Parameters Section -->
    <div class="panel model-parameters-panel">
      <h2>Model Parameters</h2>

      <h3>Runbook Configuration</h3>
      
      <!-- Search/Filter Box -->
      <div class="search-filter-container">
        <div class="search-box">
          <input type="text" id="searchRunbooks" placeholder="ðŸ” Search runbooks..." oninput="filterRunbooks()">
        </div>
        <div class="filter-controls">
          <select id="filterStrategy" onchange="filterRunbooks()">
            <option value="">All Strategies</option>
            <option value="Preparation">Preparation</option>
            <option value="Export">Export</option>
            <option value="Import">Import</option>
            <option value="Quality Gate">Quality Gate</option>
            <option value="Conversion">Conversion</option>
            <option value="Validation">Validation</option>
          </select>
          <select id="filterStatus" onchange="filterRunbooks()">
            <option value="">All Status</option>
            <option value="not-started">Not Started</option>
            <option value="in-progress">In Progress</option>
            <option value="blocked">Blocked</option>
            <option value="completed">Completed</option>
            <option value="skipped">Skipped</option>
            <option value="in-error">In Error</option>
          </select>
          <button class="btn small" onclick="clearFilters()">Clear Filters</button>
        </div>
      </div>
      
      <table class="table" id="runbookTable">
        <thead>
          <tr>
            <th style="width:40px;"></th>
            <th style="width:60px;">Sequence</th>
            <th style="width:120px;">Strategy</th>
            <th style="width:120px;">Phase</th>
            <th style="width:160px;">Runblock</th>
            <th style="width:180px;">Responsibility</th>
            <th style="width:80px;text-align:center;">Predecessor</th>
            <th style="width:100px;text-align:center;">Status</th>
            <th style="width:60px;text-align:center;">Critical</th>
            <th style="width:120px;text-align:center;">Actions</th>
          </tr>
        </thead>
        <tbody id="runbookBody">
          <!-- Dynamic rows will be added here -->
        </tbody>
      </table>
      
      <div class="btnbar">
        <button class="btn primary" onclick="addRunbookRow()">âž• Add Line</button>
        <button class="btn" onclick="clearRunbook()">ðŸ—‘ï¸ Clear All</button>
        <div style="margin-left:auto;">
          <input type="file" id="uploadFile" accept=".csv" class="hidden" onchange="uploadExcel(event)">
          <button class="btn" onclick="downloadExcel()">ðŸ“¥ Download CSV</button>
          <button class="btn" onclick="document.getElementById('uploadFile').click()">ðŸ“¤ Upload CSV</button>
        </div>
      </div>
      
      <div class="info-box">
        <strong>Instructions:</strong><br>
        â€¢ Use <strong>Search box</strong> to filter runbooks by name, strategy, phase, or responsibility<br>
        â€¢ <strong>Drag rows</strong> (â‰¡ icon) to reorder sequence<br>
        â€¢ Set <strong>Status</strong> for each task: Not Started, In Progress, Blocked, Completed, Skipped, or In Error<br>
        â€¢ Click <strong>ðŸ”„ Duplicate</strong> to copy a runbook with all settings<br>
        â€¢ <strong>Keyboard shortcuts:</strong> Ctrl+N (add), Ctrl+D (duplicate), Ctrl+F (search), ? (help)<br>
        â€¢ <strong>Elapsed time badges</strong> appear on timeline for in-progress tasks<br>
        â€¢ Mark critical path items with the Critical checkbox<br>
        â€¢ PLAN controls the planned duration of each runbook<br>
        â€¢ ACTUAL is automatically populated when status is set to Completed<br>
        â€¢ Viewer mode users see live progress but cannot make changes<br>
        â€¢ <strong>Hover over timeline blocks</strong> to see detailed information
      </div>

      <!-- Template Management Section -->
      <div class="template-section">
        <h3>ðŸ“‹ Runbook Templates</h3>
        <p style="font-size:13px;color:var(--sap-muted);margin-bottom:16px;">
          Save your current runbook configuration as a template for future use. Templates are stored in the cloud and can be loaded anytime.
        </p>
        
        <div class="template-controls">
          <div class="template-field">
            <label>Template Name</label>
            <input type="text" id="templateName" placeholder="Enter template name (e.g., 'SAP S/4HANA Standard')" style="width:100%;">
          </div>
          <button class="btn primary" onclick="saveTemplate()">ðŸ’¾ Save as Template</button>
          <button class="btn" onclick="refreshTemplates()">ðŸ”„ Refresh List</button>
        </div>

        <div class="template-list" id="templateList">
          <div style="padding:20px;text-align:center;color:var(--sap-muted);">
            No templates saved yet. Create your first template above!
          </div>
        </div>
      </div>
    </div>
  </div>

<!-- Keyboard Shortcuts Help -->
<div class="keyboard-shortcuts-overlay" id="keyboardShortcutsOverlay" onclick="hideKeyboardShortcuts()"></div>
<div class="keyboard-shortcuts-help" id="keyboardShortcutsHelp">
  <h3 style="margin-top:0;">Keyboard Shortcuts</h3>
  <div class="shortcut-item">
    <span>Add New Runbook</span>
    <span class="shortcut-key">Ctrl + N</span>
  </div>
  <div class="shortcut-item">
    <span>Duplicate Selected Row</span>
    <span class="shortcut-key">Ctrl + D</span>
  </div>
  <div class="shortcut-item">
    <span>Save/Sync</span>
    <span class="shortcut-key">Ctrl + S</span>
  </div>
  <div class="shortcut-item">
    <span>Focus Search</span>
    <span class="shortcut-key">Ctrl + F</span>
  </div>
  <div class="shortcut-item">
    <span>Toggle Full Screen</span>
    <span class="shortcut-key">F</span>
  </div>
  <div class="shortcut-item">
    <span>Show This Help</span>
    <span class="shortcut-key">?</span>
  </div>
  <div class="shortcut-item">
    <span>Close Help</span>
    <span class="shortcut-key">Esc</span>
  </div>
  <div style="margin-top:16px;text-align:center;">
    <button class="btn" onclick="hideKeyboardShortcuts()">Close</button>
  </div>
</div>

<script>
'use strict';

const HOST_TAKEOVER_GRACE_MS = 60000;
window.__DT2_HOST_TAKEOVER_GRACE_MS = HOST_TAKEOVER_GRACE_MS;

function displayHostAuthMessage(message, variant) {
  const status = document.getElementById('hostAuthStatus');
  if (status) {
    status.textContent = message || '';
    status.className = 'host-auth-status';
    if (variant === 'error') {
      status.classList.add('error');
    } else if (variant === 'success') {
      status.classList.add('success');
    }
    return;
  }

  if (message && typeof console !== 'undefined' && console.info) {
    console.info('[host]', message);
  }
}

function focusHostAuthInput() {
  const input = document.getElementById('hostPasswordInput');
  if (input) {
    input.disabled = false;
    input.focus();
    input.select();
  }
}

function computeHostModeUrl(options) {
  const forceViewer = !!(options && options.viewer);

  try {
    const current = new URL(window.location.href);
    if (sessionContext && typeof sessionContext === 'object') {
      current.searchParams.set('customer', sessionContext.customerValue || '');
      current.searchParams.set('transformCycle', sessionContext.transformValue || '');
      current.searchParams.set('phase', sessionContext.transformValue || '');
      current.searchParams.set('session', sessionContext.sessionKey || '');
    }
    current.searchParams.set('viewer', forceViewer ? '1' : '0');
    return current.toString();
  } catch (err) {
    const href = window.location && window.location.href ? window.location.href : '';
    const separator = href.includes('?') ? '&' : '?';
    const viewerParam = 'viewer=' + (forceViewer ? '1' : '0');
    const base = href.includes('viewer=') ? href.replace(/viewer=[^&#]*/g, viewerParam) : (href + separator + viewerParam);
    const customerPart = sessionContext?.customerValue ? `&customer=${encodeURIComponent(sessionContext.customerValue)}` : '';
    const transformPart = sessionContext?.transformValue ? `&transformCycle=${encodeURIComponent(sessionContext.transformValue)}&phase=${encodeURIComponent(sessionContext.transformValue)}` : '';
    const sessionPart = sessionContext?.sessionKey ? `&session=${encodeURIComponent(sessionContext.sessionKey)}` : '';
    return base + customerPart + transformPart + sessionPart;
  }
}

function updateHostUrlHint() {
  const link = document.getElementById('hostModeUrlLink');
  const copyBtn = document.getElementById('copyHostModeUrlBtn');
  const url = computeHostModeUrl({ viewer: true });

  if (link) {
    link.href = url;
    link.textContent = url;
  }

  if (copyBtn) {
    copyBtn.dataset.url = url;
  }
}

function copyHostModeUrl(event) {
  event.preventDefault();
  const url = (event.currentTarget && event.currentTarget.dataset && event.currentTarget.dataset.url) || computeHostModeUrl({ viewer: true });
  if (!url) return;

  const notify = function(message) {
    if (typeof window.showToast === 'function') {
      window.showToast(message);
    } else {
      alert(message);
    }
  };

  if (navigator.clipboard && typeof navigator.clipboard.writeText === 'function') {
    navigator.clipboard.writeText(url)
      .then(function() { notify('Host link copied'); })
      .catch(function() { notify('Copy failed. Use the link to open host mode.'); });
    return;
  }

  const temp = document.createElement('textarea');
  temp.value = url;
  temp.setAttribute('readonly', '');
  temp.style.position = 'absolute';
  temp.style.left = '-9999px';
  document.body.appendChild(temp);
  temp.select();
  try {
    document.execCommand('copy');
    notify('Host link copied');
  } catch (err) {
    notify('Copy failed. Use the link to open host mode.');
  } finally {
    document.body.removeChild(temp);
  }
}

function updateHostAuthUI() {
  if (window.AppState) {
    window.AppState.hostAuthenticated = true;
  }

  const card = document.getElementById('hostAuthCard');
  if (card && !card.__removed) {
    card.remove();
    card.__removed = true;
  }
}

window.displayHostAuthMessage = displayHostAuthMessage;
window.focusHostAuthInput = focusHostAuthInput;
window.updateHostAuthUI = updateHostAuthUI;

window.HostAuth = {
  verified: true,
  getSecret() {
    return '';
  },
  isVerified() {
    return true;
  },
  setVerified(value) {
    this.verified = value !== false;
    if (window.AppState) {
      window.AppState.hostAuthenticated = this.verified;
    }
    updateHostAuthUI();
    if (typeof renderHostStatus === 'function') renderHostStatus();
    if (typeof renderDowntimeControls === 'function') renderDowntimeControls();
    if (typeof updateViewerPanel === 'function') updateViewerPanel();
    if (typeof renderRunbookTable === 'function') renderRunbookTable(true);
    if (typeof updateTimeline === 'function') updateTimeline();
    if (this.verified && typeof window.__DT2_attemptControllerClaim === 'function') {
      window.__DT2_attemptControllerClaim('host-access');
    }
  },
  load() {
    this.setVerified(true);
  }
};

// Authentication state
let isAuthenticated = true;
let authUiInitialized = false;
let clockIntervalId = null;
let realtimeInitPromise = null;

function runAuthenticatedStartup() {
  if (!isAuthenticated || authUiInitialized) return;
  authUiInitialized = true;

  initializeApp();
  initDarkMode();
  updateRecentCustomersDropdown();
  renderHostStatus();
  renderControlRequestBanner();
  function handleRealtimeInitError(err) {
    console.error('Realtime initialization failed', err);
    try {
      updateConnectionIndicator('offline', 'Realtime init failed');
    } catch (indicatorErr) {
      console.warn('Unable to update connection indicator', indicatorErr);
    }
  }

  function startRealtimeInitialization() {
    if (realtimeInitPromise || typeof window.initializeRealtime !== 'function') {
      return realtimeInitPromise;
    }

    var promise = window.initializeRealtime();
    if (promise && typeof promise.catch === 'function') {
      promise.catch(handleRealtimeInitError);
    }
    realtimeInitPromise = promise || Promise.resolve();
    return realtimeInitPromise;
  }

  if (typeof window.initializeRealtime === 'function') {
    startRealtimeInitialization();
  } else {
    document.addEventListener('dt2-realtime-ready', function handleRealtimeReady() {
      document.removeEventListener('dt2-realtime-ready', handleRealtimeReady);
      var initialized = startRealtimeInitialization();
      if (!initialized) {
        handleRealtimeInitError(new Error('Realtime module signaled ready without initializer'));
      }
    });
  }

  bindMessageToggleButton();
  initializeFocusToggle();
  window.setMessagesEnabled(window.AppState && typeof window.AppState.messagesOn === 'boolean' ? window.AppState.messagesOn : false);
  updateFocusExitControl(window.AppState.fullscreenMode);
  applyFocusState(window.AppState.fullscreenMode, { forceRefresh: true, skipTimelineRefresh: true });

  updateClock();
  if (!clockIntervalId) {
    clockIntervalId = setInterval(updateClock, 1000);
  }

  var darkModeToggle = document.getElementById('darkModeToggle');
  if (darkModeToggle && !darkModeToggle.__bound) {
    darkModeToggle.addEventListener('click', toggleDarkMode);
    darkModeToggle.__bound = true;
  }

  var focusExitBtn = document.getElementById('focusExitButton');
  if (focusExitBtn && !focusExitBtn.__bound) {
    focusExitBtn.addEventListener('click', function(e) {
      e.preventDefault();
      toggleFullscreenMode(false);
    });
    focusExitBtn.__bound = true;
  }

  var recentBtn = document.getElementById('recentCustomersBtn');
  if (recentBtn && !recentBtn.__bound) {
    recentBtn.addEventListener('click', function(e) {
      e.stopPropagation();
      toggleRecentCustomersDropdown();
    });
    recentBtn.__bound = true;
  }

  var bookmarkBtn = document.getElementById('bookmarkSessionBtn');
  if (bookmarkBtn && !bookmarkBtn.__bound) {
    bookmarkBtn.addEventListener('click', function(e) {
      e.preventDefault();
      e.stopPropagation();
      bookmarkCurrentSession();
    });
    bookmarkBtn.__bound = true;
  }

  var requestBtn = document.getElementById('requestControlBtn');
  if (requestBtn && !requestBtn.__bound) {
    requestBtn.addEventListener('click', function(e) {
      e.preventDefault();
      requestHostControl();
    });
    requestBtn.__bound = true;
  }

  var approveBtn = document.getElementById('approveControlBtn');
  if (approveBtn && !approveBtn.__bound) {
    approveBtn.addEventListener('click', function(e) {
      e.preventDefault();
      approveControlRequest();
    });
    approveBtn.__bound = true;
  }

  var dismissBtn = document.getElementById('dismissControlBtn');
  if (dismissBtn && !dismissBtn.__bound) {
    dismissBtn.addEventListener('click', function(e) {
      e.preventDefault();
      dismissControlRequest();
    });
    dismissBtn.__bound = true;
  }

  var customerNameInput = document.getElementById('customerName');
  if (customerNameInput && !customerNameInput.__bound) {
    customerNameInput.addEventListener('change', function() {
      if (this.value && this.value.trim().length > 0) {
        var transformCycleInput = document.getElementById('transformCycle');
        addRecentCustomer(this.value.trim(), transformCycleInput ? transformCycleInput.value : '');
      }
      if (window.AppState.fullscreenMode) {
        updateFullscreenCustomerInfo();
      }
    });
    customerNameInput.addEventListener('focus', function() {
      window.AppState.inputLock = true;
    });
    customerNameInput.addEventListener('blur', function() {
      setTimeout(function() {
        window.AppState.inputLock = false;
      }, 500);
    });
    customerNameInput.__bound = true;
  }

  var transformCycleInput = document.getElementById('transformCycle');
  if (transformCycleInput && !transformCycleInput.__bound) {
    transformCycleInput.addEventListener('change', function() {
      var customerInput = document.getElementById('customerName');
      if (customerInput && customerInput.value.trim()) {
        addRecentCustomer(customerInput.value.trim(), this.value);
      }
      if (window.AppState.fullscreenMode) {
        updateFullscreenCustomerInfo();
      }
    });
    transformCycleInput.addEventListener('focus', function() {
      window.AppState.inputLock = true;
    });
    transformCycleInput.addEventListener('blur', function() {
      setTimeout(function() {
        window.AppState.inputLock = false;
      }, 500);
    });
    transformCycleInput.__bound = true;
  }
}

// Initialize application when DOM is ready
document.addEventListener('DOMContentLoaded', function() {
  runAuthenticatedStartup();
});

// Initialize Microsoft Teams if running inside Teams
if (typeof microsoftTeams !== 'undefined' && microsoftTeams.app && typeof microsoftTeams.app.initialize === 'function') {
  const validOrigins = ['https://snpcom.sharepoint.com'];
  microsoftTeams.app.initialize(validOrigins).catch(function() {
    console.warn('Teams initialization failed or not running inside Teams');
  });
}

// Global state
window.AppState = {
  runbooks: [],
  downtimeStarted: false,
  downtimeStartTime: null,
  downtimeDuration: 24,
  downtimePaused: false,
  pausedDuration: 0,
  pauseStartTime: null,
  currentDraggedBlock: null,
  dragOffset: 0,
  completionTimes: {},
  pendingCompletionUpdates: {},
  isFirstUser: false,
  syncedTimelinePosition: 0,
  renderLock: false,
  messagesOn: false,
  lastRenderTime: 0,
  inputLock: false,
  timelineInputLock: false,
  focusedTimelineInput: null,
  selectedRunbookId: null,
  draggedRowId: null,
  searchQuery: '',
  filterStrategy: '',
  filterStatus: '',
  fullscreenMode: false,
  fullscreenSince: null,
  darkMode: false,
  lastPauseReason: '',
  lastResetAt: null,
  lastStatusChange: null,
  lastStatusSeenAt: null
};

if (window.HostAuth && typeof window.HostAuth.load === 'function') {
  window.HostAuth.load();
} else {
  updateHostAuthUI();
}

document.body.classList.add('messages-off');

// Constants
var STRATEGIES = ['Preparation', 'Export', 'Import', 'Quality Gate', 'Conversion', 'Validation'];
var PHASES = ['Tables', 'Delta', 'Checkpoint', 'Finance', 'Logistics', 'PCA Tool', 'MPP', 'Support', 'Collector', 'NZD'];
var TASK_STATUSES = ['not-started', 'in-progress', 'blocked', 'completed', 'skipped', 'in-error'];

// Enhanced Tooltip Functions
let tooltipTimeout;

function showEnhancedTooltip(runbook, event, immediate) {
  clearTimeout(tooltipTimeout);

  const displayTooltip = function() {
    const tooltip = document.getElementById('enhancedTooltip');
    if (!tooltip) return;

    document.getElementById('tooltipTitle').textContent = runbook.runblock || 'Unnamed Task';
    document.getElementById('tooltipResponsibility').textContent = runbook.responsibility || 'Not Assigned';
    document.getElementById('tooltipPhase').textContent = runbook.phase || 'â€”';
    document.getElementById('tooltipStrategy').textContent = runbook.strategy || 'â€”';

    const status = runbook.status || 'not-started';
    const statusText = status.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
    document.getElementById('tooltipStatusText').textContent = statusText;

    const statusIcon = document.getElementById('tooltipStatusIcon');
    statusIcon.className = 'status-icon ' + status;

    const sequenceEl = document.getElementById('tooltipSequence');
    if (sequenceEl) {
      sequenceEl.textContent = runbook.sequence != null ? '#' + runbook.sequence : 'â€”';
    }

    const predecessorEl = document.getElementById('tooltipPredecessor');
    if (predecessorEl) {
      if (runbook.predecessor || runbook.predecessor === 0) {
        predecessorEl.textContent = '#' + runbook.predecessor;
      } else {
        predecessorEl.textContent = 'None';
      }
    }

    const parseTimePart = function(value) {
      if (value === null || value === undefined || value === '') return null;
      const num = typeof value === 'number' ? value : parseInt(value, 10);
      if (!Number.isFinite(num)) return null;
      return Math.max(0, Math.trunc(num));
    };

    const formatHHMMTooltip = function(hours, minutes) {
      const h = parseTimePart(hours);
      const m = parseTimePart(minutes);
      if (h === null || m === null) return '--:--';
      return String(h).padStart(2, '0') + ':' + String(m).padStart(2, '0');
    };

    const startEl = document.getElementById('tooltipStart');
    if (startEl) {
      startEl.textContent = formatHHMMTooltip(runbook.scheduleHours, runbook.scheduleMinutes);
    }

    const planEl = document.getElementById('tooltipPlan');
    if (planEl) {
      planEl.textContent = formatHHMMTooltip(runbook.durationHours, runbook.durationMinutes);
    }

    const iconMap = {
      'Preparation': 'ðŸ”§',
      'Export': 'ðŸ“¤',
      'Import': 'ðŸ“¥',
      'Quality Gate': 'âœ“',
      'Conversion': 'ðŸ”„',
      'Validation': 'âœ”ï¸'
    };
    document.getElementById('tooltipIcon').textContent = iconMap[runbook.strategy] || 'ðŸ“¦';

    tooltip.style.left = (event.clientX + 20) + 'px';
    tooltip.style.top = (event.clientY + 20) + 'px';

    tooltip.classList.add('show');
    tooltipTimeout = null;
  };

  if (immediate) {
    displayTooltip();
  } else {
    tooltipTimeout = setTimeout(displayTooltip, 150);
  }
}

function hideEnhancedTooltip() {
  clearTimeout(tooltipTimeout);
  tooltipTimeout = null;
  const tooltip = document.getElementById('enhancedTooltip');
  if (tooltip) tooltip.classList.remove('show');
}

let toastContainer = null;
let sharedAudioContext = null;

function ensureToastContainer() {
  if (!toastContainer) {
    toastContainer = document.createElement('div');
    toastContainer.className = 'toast-container';
    document.body.appendChild(toastContainer);
  }
  return toastContainer;
}

function showToast(message) {
  if (!message) return;
  const container = ensureToastContainer();
  const toast = document.createElement('div');
  toast.className = 'toast-message';
  toast.textContent = message;
  container.appendChild(toast);
  requestAnimationFrame(() => toast.classList.add('show'));
  setTimeout(() => {
    toast.classList.remove('show');
    setTimeout(() => {
      if (toast.parentNode) toast.parentNode.removeChild(toast);
    }, 300);
  }, 4000);
}

function playStatusTone(type) {
  try {
    const AudioCtor = window.AudioContext || window.webkitAudioContext;
    if (!AudioCtor) return;
    if (!sharedAudioContext) {
      sharedAudioContext = new AudioCtor();
    }
    const ctx = sharedAudioContext;
    const now = ctx.currentTime;
    const oscillator = ctx.createOscillator();
    const gain = ctx.createGain();
    const baseFrequency = type === 'pause' ? 440 : type === 'resume' ? 660 : 520;
    oscillator.type = 'sine';
    oscillator.frequency.setValueAtTime(baseFrequency, now);
    gain.gain.setValueAtTime(0.12, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
    oscillator.connect(gain);
    gain.connect(ctx.destination);
    oscillator.start(now);
    oscillator.stop(now + 0.4);
  } catch (err) {
    console.warn('Audio notification failed', err);
  }
}

function recordStatusChange(type, options) {
  options = options || {};
  const message = options.message || (type === 'pause' ? 'Downtime paused' : type === 'resume' ? 'Downtime resumed' : 'Status updated');
  const payload = {
    type,
    message,
    reason: options.reason || '',
    at: new Date().toISOString()
  };
  window.AppState.lastStatusChange = payload;
  window.AppState.lastStatusSeenAt = payload.at;
  showToast(message);
  playStatusTone(type);
  NotificationHooks.notify(type, payload);
  if (typeof schedulePush === 'function' && window.canWrite && window.canWrite()) {
    schedulePush();
  }

  if (typeof updateFullscreenKpis === 'function') {
    updateFullscreenKpis();
  }
}

function handleRemoteStatusChange(change) {
  if (!change) return;
  showToast(change.message);
  playStatusTone(change.type);
}

// Template Management Functions
const TemplateGovernance = (function() {
  const storageKey = 'dt2-template-governance';
  let registry = {};
  try {
    registry = JSON.parse(localStorage.getItem(storageKey) || '{}');
  } catch (err) {
    registry = {};
  }

  function persist() {
    try {
      localStorage.setItem(storageKey, JSON.stringify(registry));
    } catch (err) {
      console.warn('Failed to persist template governance registry', err);
    }
  }

  function ensureEntry(name) {
    const key = name.toLowerCase();
    if (!registry[key]) {
      registry[key] = { version: '1.0.0', history: [] };
    }
    return registry[key];
  }

  function bumpVersion(name, note) {
    const key = name.toLowerCase();
    const entry = ensureEntry(name);
    if (entry.history && entry.history.length) {
      const parts = (entry.version || '1.0.0').split('.').map(function(part) { return parseInt(part, 10) || 0; });
      parts[2] = (parts[2] || 0) + 1;
      entry.version = `${parts[0]}.${parts[1]}.${parts[2]}`;
    } else {
      entry.version = '1.0.0';
    }
    entry.history = entry.history || [];
    entry.history.unshift({ note: note || 'Update', at: new Date().toISOString() });
    entry.history = entry.history.slice(0, 10);
    registry[key] = entry;
    persist();
    return entry;
  }

  function getMetadata(name) {
    const key = name.toLowerCase();
    const entry = registry[key];
    if (!entry) return { version: '0.0.0', history: [] };
    return { version: entry.version || '0.0.0', history: (entry.history || []).slice() };
  }

  function hasHistory(name) {
    const key = name.toLowerCase();
    const entry = registry[key];
    return !!(entry && entry.history && entry.history.length);
  }

  return { bumpVersion, getMetadata, hasHistory };
})();

window.saveTemplate = async function() {
  const templateName = document.getElementById('templateName');
  if (!templateName.value.trim()) {
    alert('Please enter a template name');
    return;
  }
  
  if (window.AppState.runbooks.length === 0) {
    alert('No runbook data to save. Please add some runbooks first.');
    return;
  }

  const trimmedName = templateName.value.trim();
  const existing = TemplateGovernance.getMetadata(trimmedName);
  const defaultNote = existing.history.length ? 'Updated runbook sequence' : 'Initial version';
  const summary = prompt('Summarize this template update (for changelog visibility):', defaultNote) || defaultNote;
  const governance = TemplateGovernance.bumpVersion(trimmedName, summary);

  const template = {
    name: trimmedName,
    runbooks: window.AppState.runbooks.map(r => ({
      sequence: r.sequence,
      strategy: r.strategy,
      phase: r.phase,
      runblock: r.runblock,
      responsibility: r.responsibility,
      critical: r.critical,
      scheduleHours: r.scheduleHours,
      scheduleMinutes: r.scheduleMinutes,
      durationHours: r.durationHours,
      durationMinutes: r.durationMinutes
    })),
    createdAt: new Date().toISOString(),
    createdBy: document.getElementById('customerName')?.value || 'Unknown',
    version: governance.version,
    changeLog: governance.history
  };

  try {
    // Will be saved via Firebase
    if (window.saveTemplateToFirebase) {
      await window.saveTemplateToFirebase(template);
      templateName.value = '';
      alert('âœ… Template saved successfully!');
      refreshTemplates();
    } else {
      alert('âš ï¸ Template saving not available yet. Please wait for Firebase initialization.');
    }
  } catch (e) {
    console.error('Error saving template:', e);
    alert('âŒ Error saving template: ' + e.message);
  }
};

window.loadTemplate = async function(templateId) {
  if (!confirm('Load this template? Current runbook data will be replaced.')) {
    return;
  }
  
  try {
    if (window.loadTemplateFromFirebase) {
      const template = await window.loadTemplateFromFirebase(templateId);
      
      window.AppState.runbooks = template.runbooks.map(function(r, idx) {
        return {
          ...r,
          id: Date.now() + Math.random() + idx,
          completed: false,
          actualDuration: null,
          position: 0,
          status: 'not-started'
        };
      });

      renderRunbookTable();
      updateTimeline();
      updateCompletionPercentage();

      if (typeof window.setMessagesEnabled === 'function') {
        window.setMessagesEnabled(false);
      }

      var versionInfo = template.version ? ` (v${template.version})` : '';
      alert('âœ… Template loaded successfully' + versionInfo + '!');
    }
  } catch (e) {
    console.error('Error loading template:', e);
    alert('âŒ Error loading template: ' + e.message);
  }
};

window.deleteTemplate = async function(templateId) {
  if (!confirm('Are you sure you want to delete this template? This cannot be undone.')) {
    return;
  }
  
  try {
    if (window.deleteTemplateFromFirebase) {
      await window.deleteTemplateFromFirebase(templateId);
      alert('âœ… Template deleted successfully!');
      refreshTemplates();
    }
  } catch (e) {
    console.error('Error deleting template:', e);
    alert('âŒ Error deleting template: ' + e.message);
  }
};

window.refreshTemplates = async function() {
  const listContainer = document.getElementById('templateList');
  if (!listContainer) return;
  
  try {
    if (window.loadTemplatesFromFirebase) {
      const templates = await window.loadTemplatesFromFirebase();
      
      if (templates.length === 0) {
        listContainer.innerHTML = '<div style="padding:20px;text-align:center;color:var(--sap-muted);">No templates saved yet. Create your first template above!</div>';
        return;
      }
      
      listContainer.innerHTML = templates.map(function(t) {
        const date = new Date(t.createdAt).toLocaleDateString();
        const runbookCount = t.runbooks.length;
        const version = t.version || '1.0.0';
        const changelogParam = encodeURIComponent(JSON.stringify(t.changeLog || []));

        return `
          <div class="template-item">
            <div class="template-info">
              <div class="template-name">${t.name}</div>
              <div class="template-meta">v${version} â€¢ ${runbookCount} runbooks â€¢ Created ${date} by ${t.createdBy}</div>
            </div>
            <div class="template-actions">
              <button class="btn small primary" onclick="loadTemplate('${t.id}')">ðŸ“‚ Load</button>
              <button class="btn small" onclick="showTemplateChangelog('${encodeURIComponent(t.name)}','${version}','${changelogParam}')">ðŸ“ Log</button>
              <button class="btn small danger" onclick="deleteTemplate('${t.id}')">ðŸ—‘ï¸ Delete</button>
            </div>
          </div>
        `;
      }).join('');
    }
  } catch (e) {
    console.error('Error refreshing templates:', e);
    listContainer.innerHTML = '<div style="padding:20px;text-align:center;color:var(--sap-error);">Error loading templates</div>';
  }
};

window.showTemplateChangelog = function(encodedName, version, encodedLog) {
  let entries = [];
  let name = decodeURIComponent(encodedName || 'Template');
  try {
    entries = JSON.parse(decodeURIComponent(encodedLog || '[]')) || [];
  } catch (err) {
    console.warn('Failed to parse changelog', err);
  }
  if (!entries.length) {
    alert(`${name} v${version}\nNo recorded changes yet.`);
    return;
  }
  const lines = entries.map(function(entry) {
    const when = entry.at ? new Date(entry.at).toLocaleString() : 'Unknown time';
    return `${when} â€“ ${entry.note}`;
  }).join('\n');
  alert(`${name} v${version}\n\n${lines}`);
};

// NEW: Keyboard Shortcuts Handler
function handleFocusToggleEvent(e) {
  if (e) {
    e.preventDefault();
    e.stopPropagation();
  }

  toggleFullscreenMode();

  if (window.AppState && window.AppState.fullscreenMode && !document.fullscreenElement) {
    var panel = document.getElementById('progressPanel') || document.documentElement;
    if (panel && typeof panel.requestFullscreen === 'function') {
      panel.requestFullscreen().catch(function(err) {
        console.warn('Fullscreen request retry failed:', err);
      });
    }
  }
}

function initializeFocusToggle() {
  if (document.__focusToggleBound) {
    return;
  }

  var clickHandler = function(e) {
    var toggle = e.target && e.target.closest ? e.target.closest('#fullscreenToggle, [data-focus-toggle="true"]') : null;
    if (!toggle) {
      return;
    }
    handleFocusToggleEvent(e);
  };

  var keyHandler = function(e) {
    if (!e || (e.key !== 'Enter' && e.key !== ' ')) {
      return;
    }
    var toggle = e.target && e.target.closest ? e.target.closest('#fullscreenToggle, [data-focus-toggle="true"]') : null;
    if (!toggle) {
      return;
    }
    handleFocusToggleEvent(e);
  };

  document.addEventListener('click', clickHandler);
  document.addEventListener('keydown', keyHandler);
  document.__focusToggleBound = { clickHandler: clickHandler, keyHandler: keyHandler };
}

document.addEventListener('keydown', function(e) {
  // Don't trigger shortcuts when typing in inputs
  if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') {
    // Except for Ctrl+S to save
    if (e.ctrlKey && e.key === 's') {
      e.preventDefault();
      // Force push state if host
      if (window.canWrite && window.canWrite()) {
        console.log('Manual save triggered');
      }
      return;
    }
    return;
  }
  
  // Ctrl+N: Add new runbook
  if (e.ctrlKey && e.key === 'n') {
    e.preventDefault();
    window.addRunbookRow();
  }
  
  // Ctrl+D: Duplicate selected row
  if (e.ctrlKey && e.key === 'd') {
    e.preventDefault();
    if (window.AppState.selectedRunbookId) {
      window.duplicateRunbook(window.AppState.selectedRunbookId);
    }
  }
  
  // Ctrl+F: Focus search
  if (e.ctrlKey && e.key === 'f') {
    e.preventDefault();
    var searchBox = document.getElementById('searchRunbooks');
    if (searchBox) {
      searchBox.focus();
      searchBox.select();
    }
  }
  
  // F: Toggle full screen mode
  if (e.key === 'f' && !e.ctrlKey && !e.shiftKey && !e.altKey) {
    e.preventDefault();
    toggleFullscreenMode();
  }
  
  // ?: Show keyboard shortcuts help
  if (e.key === '?' && !e.ctrlKey && !e.shiftKey && !e.altKey) {
    e.preventDefault();
    showKeyboardShortcuts();
  }
  
  // Esc: Close keyboard shortcuts help or exit fullscreen
  if (e.key === 'Escape') {
    hideKeyboardShortcuts();
    if (window.AppState.fullscreenMode) {
      toggleFullscreenMode();
    }
  }
});

// NEW: Full Screen Mode Functions
function updateFocusExitControl(isActive) {
  var control = document.getElementById('focusExitControl');
  if (!control) return;
  control.hidden = !isActive;
}

function applyFocusState(isActive, options = {}) {
  var state = window.AppState;
  var desired = !!isActive;
  var wasActive = !!state.fullscreenMode;
  var changed = wasActive !== desired;
  var sinceValue = options.since instanceof Date ? options.since : (options.since ? new Date(options.since) : null);

  state.fullscreenMode = desired;
  if (state.fullscreenMode) {
    state.fullscreenSince = sinceValue || state.fullscreenSince || new Date();
  } else {
    state.fullscreenSince = null;
  }

  document.body.classList.toggle('fullscreen-mode', state.fullscreenMode);

  if (state.fullscreenMode) {
    updateFullscreenCustomerInfo();
    if (changed || options.forceRefresh) {
      lazyLoadTimelineForFocus();
    }
  }

  if (changed && options.attemptFullscreen) {
    if (state.fullscreenMode) {
      var panel = document.getElementById('progressPanel');
      var fullscreenTarget = panel && panel.requestFullscreen ? panel : document.documentElement;
      if (fullscreenTarget && fullscreenTarget.requestFullscreen) {
        fullscreenTarget.requestFullscreen().catch(function(err) {
          console.warn('Fullscreen request failed:', err);
        });
      }
    } else if (document.fullscreenElement && document.exitFullscreen) {
      document.exitFullscreen().catch(function(err) {
        console.warn('Failed to exit fullscreen:', err);
      });
    }
  }

  updateFullscreenButton(state.fullscreenMode);
  updateFocusExitControl(state.fullscreenMode);

  if ((changed || options.forceRefresh) && !options.skipTimelineRefresh) {
    setTimeout(function() {
      if (typeof window.updateTimeline === 'function') {
        window.updateTimeline();
      }
    }, 100);
  }

  return changed;
}

function toggleFullscreenMode(forceState) {
  var shouldEnable = typeof forceState === 'boolean' ? forceState : !window.AppState.fullscreenMode;
  var changed = applyFocusState(shouldEnable, { attemptFullscreen: true });

  if (changed && window.canWrite && window.canWrite()) {
    recordStatusChange(shouldEnable ? 'focus-enter' : 'focus-exit', {
      message: shouldEnable ? 'Focus mode enabled' : 'Focus mode exited'
    });
  }

  if (changed && typeof schedulePush === 'function' && window.canWrite && window.canWrite()) {
    schedulePush('focus-toggle');
  }
}

function lazyLoadTimelineForFocus() {
  if ('requestIdleCallback' in window) {
    requestIdleCallback(function() {
      if (typeof window.updateTimeline === 'function') window.updateTimeline();
      if (typeof window.renderRunbookTable === 'function') window.renderRunbookTable();
    }, { timeout: 500 });
  } else {
    setTimeout(function() {
      if (typeof window.updateTimeline === 'function') window.updateTimeline();
      if (typeof window.renderRunbookTable === 'function') window.renderRunbookTable();
    }, 0);
  }
}

function updateFullscreenButton(isFullscreen) {
  var icon = document.getElementById('fullscreenIcon');
  var text = document.getElementById('fullscreenText');
  var btn = document.getElementById('fullscreenToggle');
  var headerBtn = document.getElementById('headerFocusButton');
  var headerIcon = document.getElementById('headerFocusIcon');
  var headerText = document.getElementById('headerFocusText');

  if (icon) icon.textContent = isFullscreen ? 'â›¶' : 'â›¶';
  if (text) text.textContent = isFullscreen ? 'Exit Focus' : 'Focus';
  if (btn) {
    btn.setAttribute('aria-pressed', isFullscreen ? 'true' : 'false');
    if (isFullscreen) {
      btn.classList.add('active');
    } else {
      btn.classList.remove('active');
    }
  }

  if (headerIcon) headerIcon.textContent = isFullscreen ? 'â›¶' : 'â›¶';
  if (headerText) headerText.textContent = isFullscreen ? 'Exit Focus' : 'Focus';
  if (headerBtn) {
    headerBtn.setAttribute('aria-pressed', isFullscreen ? 'true' : 'false');
    if (isFullscreen) {
      headerBtn.classList.add('active');
    } else {
      headerBtn.classList.remove('active');
    }
  }
}

function updateFullscreenCustomerInfo() {
  var customerNameEl = document.getElementById('fullscreenCustomerName');
  var transformCycleEl = document.getElementById('fullscreenTransformCycle');

  var customerName = document.getElementById('customerName');
  var transformCycle = document.getElementById('transformCycle');

  if (customerNameEl && customerName) {
    customerNameEl.textContent = customerName.value || 'Not Set';
  }

  if (transformCycleEl && transformCycle) {
    transformCycleEl.textContent = transformCycle.value || 'Not Set';
  }
}

window.toggleFullscreenMode = toggleFullscreenMode;

document.addEventListener('fullscreenchange', function() {
  var isFullscreen = !!document.fullscreenElement;
  if (!isFullscreen && window.AppState.fullscreenMode) {
    var exited = applyFocusState(false, { forceRefresh: true });
    if (exited && window.canWrite && window.canWrite()) {
      recordStatusChange('focus-exit', { message: 'Focus mode exited' });
      if (typeof schedulePush === 'function') {
        schedulePush();
      }
    }
  } else if (isFullscreen && !window.AppState.fullscreenMode) {
    var entered = applyFocusState(true, { forceRefresh: true, since: new Date() });
    if (entered && window.canWrite && window.canWrite()) {
      recordStatusChange('focus-enter', { message: 'Focus mode enabled' });
      if (typeof schedulePush === 'function') {
        schedulePush();
      }
    }
  }
});

// NEW: Keyboard Shortcuts Help Functions
function showKeyboardShortcuts() {
  document.getElementById('keyboardShortcutsOverlay').classList.add('show');
  document.getElementById('keyboardShortcutsHelp').classList.add('show');
}

function hideKeyboardShortcuts() {
  document.getElementById('keyboardShortcutsOverlay').classList.remove('show');
  document.getElementById('keyboardShortcutsHelp').classList.remove('show');
}

window.showKeyboardShortcuts = showKeyboardShortcuts;
window.hideKeyboardShortcuts = hideKeyboardShortcuts;

// NEW: Search/Filter Functions
window.filterRunbooks = function() {
  var searchQuery = document.getElementById('searchRunbooks').value.toLowerCase();
  var filterStrategy = document.getElementById('filterStrategy').value;
  var filterStatus = document.getElementById('filterStatus').value;
  
  window.AppState.searchQuery = searchQuery;
  window.AppState.filterStrategy = filterStrategy;
  window.AppState.filterStatus = filterStatus;
  
  renderRunbookTable();
  updateTimeline();
};

window.clearFilters = function() {
  document.getElementById('searchRunbooks').value = '';
  document.getElementById('filterStrategy').value = '';
  document.getElementById('filterStatus').value = '';
  window.AppState.searchQuery = '';
  window.AppState.filterStrategy = '';
  window.AppState.filterStatus = '';
  renderRunbookTable();
  updateTimeline();
};

// NEW: Get Filtered Runbooks
function getFilteredRunbooks() {
  return window.AppState.runbooks.filter(function(runbook) {
    // Search filter
    if (window.AppState.searchQuery) {
      var searchMatch = (runbook.runblock || '').toLowerCase().includes(window.AppState.searchQuery) ||
                       (runbook.responsibility || '').toLowerCase().includes(window.AppState.searchQuery) ||
                       (runbook.strategy || '').toLowerCase().includes(window.AppState.searchQuery) ||
                       (runbook.phase || '').toLowerCase().includes(window.AppState.searchQuery);
      if (!searchMatch) return false;
    }
    
    // Strategy filter
    if (window.AppState.filterStrategy && runbook.strategy !== window.AppState.filterStrategy) {
      return false;
    }
    
    // Status filter
    if (window.AppState.filterStatus) {
      var status = runbook.status || 'not-started';
      if (status !== window.AppState.filterStatus) {
        return false;
      }
    }
    
    return true;
  });
}

// NEW: Duplicate Runbook Function
window.duplicateRunbook = function(id) {
  var original = window.AppState.runbooks.find(function(r) { return r.id === id; });
  if (!original) return;
  
  var duplicate = {
    id: Date.now() + Math.random(),
    sequence: window.AppState.runbooks.length + 1,
    strategy: original.strategy,
    phase: original.phase,
    runblock: original.runblock + ' (Copy)',
    responsibility: original.responsibility,
    critical: original.critical,
    scheduleHours: original.scheduleHours,
    scheduleMinutes: original.scheduleMinutes,
    durationHours: original.durationHours,
    durationMinutes: original.durationMinutes,
    completed: false,
    actualDuration: null,
    position: 0,
    status: 'not-started'
  };
  
  window.AppState.runbooks.push(duplicate);
  renderRunbookTable();
  updateTimeline();
  updateCompletionPercentage();
};

// NEW: Update Elapsed Time for In-Progress Tasks
function updateElapsedTimes() {
  if (!window.AppState.downtimeStarted || !window.AppState.downtimeStartTime) return;

  var now = new Date();
  var startTime = resolveDowntimeStartTime();
  if (!startTime) return;
  var pausedOffset = getEffectivePausedDuration(now);

  window.AppState.runbooks.forEach(function(runbook) {
    if (runbook.status === 'in-progress' && !runbook.completed) {
      var scheduledOffset = runbook.scheduleHours * 3600000 + runbook.scheduleMinutes * 60000;
      var taskStart = new Date(startTime.getTime() + scheduledOffset);

      if (now >= taskStart) {
        var elapsedMs = now - taskStart - pausedOffset;
        var elapsedHours = Math.floor(elapsedMs / 3600000);
        var elapsedMinutes = Math.floor((elapsedMs % 3600000) / 60000);
        
        // Update elapsed time badge on timeline
        var block = document.querySelector('.timeline-block[data-runbook-id="' + runbook.id + '"]');
        if (block) {
          var existingBadge = block.querySelector('.elapsed-time-badge');
          if (!existingBadge) {
            var badge = document.createElement('div');
            badge.className = 'elapsed-time-badge';
            block.appendChild(badge);
            existingBadge = badge;
          }
          existingBadge.textContent = 'Elapsed: ' + String(elapsedHours).padStart(2,'0') + ':' + String(elapsedMinutes).padStart(2,'0');
        }
      }
    }
  });
}

// Update clock to also update elapsed times
setInterval(function() {
  if (window.AppState.downtimeStarted && !window.AppState.downtimePaused) {
    updateElapsedTimes();
  }
}, 1000);

// NEW: Dark Mode Functions
function initDarkMode() {
  var stored = localStorage.getItem('darkMode');
  var darkMode = stored === 'true';
  window.AppState.darkMode = darkMode;
  document.body.classList.toggle('dark-mode', darkMode);
  updateDarkModeButton(darkMode);
}

function toggleDarkMode() {
  var isDark = !window.AppState.darkMode;
  window.AppState.darkMode = isDark;
  document.body.classList.toggle('dark-mode', isDark);
  localStorage.setItem('darkMode', isDark);
  updateDarkModeButton(isDark);
  NotificationHooks.notify('dark-mode', { enabled: isDark, at: new Date().toISOString() });
  if (typeof schedulePush === 'function' && window.canWrite && window.canWrite()) {
    schedulePush('dark-mode');
  }
}

function updateDarkModeButton(isDark) {
  var icon = document.getElementById('darkModeIcon');
  var text = document.getElementById('darkModeText');
  if (icon) icon.textContent = isDark ? 'â˜€ï¸' : 'ðŸŒ™';
  if (text) text.textContent = isDark ? 'Light' : 'Dark';
  var toggle = document.getElementById('darkModeToggle');
  if (toggle) toggle.setAttribute('aria-pressed', isDark ? 'true' : 'false');
}

// NEW: Completion Percentage Functions
function updateCompletionPercentage() {
  var totalTasks = window.AppState.runbooks.length;
  var completedTasks = window.AppState.runbooks.filter(function(r) { return r.completed; }).length;
  var percentage = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;

  var percentageEl = document.getElementById('completionPercentage');
  var progressBar = document.getElementById('progressBarFill');

  if (percentageEl) percentageEl.textContent = percentage + '%';
  if (progressBar) progressBar.style.width = percentage + '%';

  if (typeof updateFullscreenKpis === 'function') {
    updateFullscreenKpis();
  }
}

function updateFullscreenKpis() {
  var plannedMinutes = 0;
  var actualMinutes = 0;
  (window.AppState.runbooks || []).forEach(function(runbook) {
    plannedMinutes += ((runbook.durationHours || 0) * 60) + (runbook.durationMinutes || 0);
    if (runbook.actualDuration) {
      var parts = runbook.actualDuration.split(':').map(function(part) { return parseInt(part, 10) || 0; });
      actualMinutes += (parts[0] || 0) * 60 + (parts[1] || 0);
    }
  });

  var plannedLabel = document.getElementById('kpiPlanned');
  var actualLabel = document.getElementById('kpiActual');
  var varianceLabel = document.getElementById('kpiVariance');

  if (plannedLabel) plannedLabel.textContent = formatHoursShort(plannedMinutes);
  if (actualLabel) actualLabel.textContent = formatHoursShort(actualMinutes);
  if (varianceLabel) {
    var varianceMinutes = actualMinutes - plannedMinutes;
    var varianceText = formatHoursShort(Math.abs(varianceMinutes));
    if (varianceMinutes === 0) {
      varianceLabel.textContent = 'On plan';
      varianceLabel.style.color = 'var(--sap-primary)';
    } else if (varianceMinutes > 0) {
      varianceLabel.textContent = '+' + varianceText;
      varianceLabel.style.color = 'var(--sap-error)';
    } else {
      varianceLabel.textContent = '-' + varianceText;
      varianceLabel.style.color = 'var(--sap-success)';
    }
    handleKpiAutomation(plannedMinutes, actualMinutes);
  }
}

function formatHoursShort(totalMinutes) {
  if (!totalMinutes) return '0h';
  var hours = totalMinutes / 60;
  if (hours >= 10 || hours % 1 === 0) {
    return Math.round(hours) + 'h';
  }
  return hours.toFixed(1) + 'h';
}

// NEW: Recent Customers Functions
function normalizeRecentSessions(rawList) {
  if (!Array.isArray(rawList)) return [];
  return rawList
    .map(function(entry) {
      if (!entry) return null;
      if (typeof entry === 'string') {
        return { customer: entry, transform: phaseInput?.value || 'Test Migration', savedAt: Date.now() };
      }
      if (entry.customer) {
        return {
          customer: entry.customer,
          transform: entry.transform || 'Test Migration',
          savedAt: entry.savedAt || Date.now()
        };
      }
      return null;
    })
    .filter(function(entry) { return entry && entry.customer; });
}

function getBookmarkedSessions() {
  try {
    var stored = JSON.parse(localStorage.getItem('bookmarkedSessions') || '[]');
    return normalizeRecentSessions(stored);
  } catch (err) {
    console.warn('Failed to parse bookmarked sessions', err);
    return [];
  }
}

function persistBookmarkedSessions(list) {
  try {
    localStorage.setItem('bookmarkedSessions', JSON.stringify(list));
  } catch (err) {
    console.warn('Unable to persist bookmarked sessions', err);
  }
}

function getRecentCustomers() {
  try {
    var stored = JSON.parse(localStorage.getItem('recentSessions') || 'null');
    if (stored) {
      return normalizeRecentSessions(stored);
    }
  } catch (err) {
    console.warn('Failed to parse recent sessions', err);
  }
  try {
    var legacy = JSON.parse(localStorage.getItem('recentCustomers') || 'null');
    return normalizeRecentSessions(legacy);
  } catch (err) {
    return [];
  }
}

function persistRecentSessions(recent) {
  try {
    localStorage.setItem('recentSessions', JSON.stringify(recent));
  } catch (err) {
    console.warn('Unable to persist recent sessions', err);
  }
}

function bookmarkCurrentSession() {
  var customerInput = document.getElementById('customerName');
  var transformInput = document.getElementById('transformCycle');
  if (!customerInput) return;

  var customer = (customerInput.value || '').trim();
  if (!customer) {
    alert('Enter a customer name before bookmarking.');
    return;
  }

  var transform = (transformInput && transformInput.value ? transformInput.value : 'Test Migration');
  var bookmarks = getBookmarkedSessions();
  var exists = bookmarks.some(function(entry) {
    return entry.customer === customer && entry.transform === transform;
  });

  if (exists) {
    alert('This customer & transform is already bookmarked.');
    return;
  }

  bookmarks.unshift({
    customer: customer,
    transform: transform,
    savedAt: Date.now()
  });

  bookmarks = bookmarks.slice(0, 15);
  persistBookmarkedSessions(bookmarks);
  updateRecentCustomersDropdown();
  alert('â­ Bookmark saved');
}

function removeBookmarkedSession(customer, transform) {
  var bookmarks = getBookmarkedSessions();
  bookmarks = bookmarks.filter(function(entry) {
    return !(entry.customer === customer && entry.transform === transform);
  });
  persistBookmarkedSessions(bookmarks);
  updateRecentCustomersDropdown();
}

function rememberSessionContext(customer, transform) {
  var normalizedCustomer = (customer || '').toString().trim();
  var normalizedTransform = (transform || '').toString().trim();
  if (!normalizedCustomer) return;
  try {
    localStorage.setItem('lastSessionContext', JSON.stringify({
      customer: normalizedCustomer,
      transform: normalizedTransform || 'Test Migration',
      savedAt: Date.now()
    }));
  } catch (err) {
    console.warn('Failed to persist last session context', err);
  }
}

function addRecentCustomer(name, transform) {
  if (!name || name.trim().length === 0) return;

  var normalizedCustomer = name.trim();
  var normalizedTransform = (transform || '').toString().trim() || 'Test Migration';
  var recent = getRecentCustomers();

  recent = recent.filter(function(entry) {
    return !(entry.customer === normalizedCustomer && entry.transform === normalizedTransform);
  });

  recent.unshift({
    customer: normalizedCustomer,
    transform: normalizedTransform,
    savedAt: Date.now()
  });

  recent = recent.slice(0, 10);
  persistRecentSessions(recent);
  rememberSessionContext(normalizedCustomer, normalizedTransform);
  updateRecentCustomersDropdown();
}

function escapeHtml(value) {
  return (value || '').replace(/[&<>"']/g, function(char) {
    switch (char) {
      case '&': return '&amp;';
      case '<': return '&lt;';
      case '>': return '&gt;';
      case '"': return '&quot;';
      case "'": return '&#39;';
      default: return char;
    }
  });
}

function updateRecentCustomersDropdown() {
  var dropdown = document.getElementById('recentCustomersDropdown');
  if (!dropdown) return;

  var recent = getRecentCustomers();
  var bookmarks = getBookmarkedSessions();
  var sections = [];

  if (bookmarks.length) {
    sections.push('<div class="recent-section-title">Bookmarked</div>');
    sections.push(bookmarks.map(function(session) {
      var encodedCustomer = encodeURIComponent(session.customer || '');
      var encodedTransform = encodeURIComponent(session.transform || '');
      var customerLabel = escapeHtml(session.customer || '');
      var transformLabel = escapeHtml(session.transform || '');
      return '<div class="recent-customer-item bookmarked" data-customer="' + encodedCustomer + '" data-transform="' + encodedTransform + '">' +
        '<span class="recent-customer-label">' + customerLabel + '</span>' +
        ' â€” <span style="color:var(--sap-muted);font-size:12px;">' + transformLabel + '</span>' +
        '<button class="recent-remove" data-remove="' + encodedCustomer + '|' + encodedTransform + '">âœ•</button>' +
      '</div>';
    }).join(''));
  }

  if (recent.length) {
    sections.push('<div class="recent-section-title">Recent</div>');
    sections.push(recent.map(function(session) {
      var encodedCustomer = encodeURIComponent(session.customer || '');
      var encodedTransform = encodeURIComponent(session.transform || '');
      var customerLabel = escapeHtml(session.customer || '');
      var transformLabel = escapeHtml(session.transform || '');
      return '<div class="recent-customer-item" data-customer="' + encodedCustomer + '" data-transform="' + encodedTransform + '">' +
        customerLabel + ' â€” <span style="color:var(--sap-muted);font-size:12px;">' + transformLabel + '</span></div>';
    }).join(''));
  }

  if (sections.length === 0) {
    dropdown.innerHTML = '<div class="recent-customer-item-empty">No saved sessions yet</div>';
  } else {
    dropdown.innerHTML = sections.join('');
  }

  dropdown.querySelectorAll('.recent-customer-item').forEach(function(item) {
    item.addEventListener('click', function(event) {
      if (event.target && event.target.matches('.recent-remove')) return;
      var customer = decodeURIComponent(this.getAttribute('data-customer') || '');
      var transform = decodeURIComponent(this.getAttribute('data-transform') || '');
      window.selectRecentCustomer(customer, transform);
    });
  });

  dropdown.querySelectorAll('.recent-remove').forEach(function(btn) {
    btn.addEventListener('click', function(event) {
      event.stopPropagation();
      var payload = this.getAttribute('data-remove') || '';
      var parts = payload.split('|');
      removeBookmarkedSession(decodeURIComponent(parts[0] || ''), decodeURIComponent(parts[1] || ''));
    });
  });
}

function toggleRecentCustomersDropdown() {
  var dropdown = document.getElementById('recentCustomersDropdown');
  if (!dropdown) return;

  dropdown.classList.toggle('show');
}

let messageToggleBound = false;

function applyMessageToggleState() {
  var on = !!(window.AppState && window.AppState.messagesOn);
  document.body.classList.toggle('messages-off', !on);
  var toggleBtn = document.getElementById('messageToggleBtn');
  if (toggleBtn) {
    toggleBtn.setAttribute('aria-pressed', on ? 'true' : 'false');
    toggleBtn.textContent = on ? 'Messages: On' : 'Messages: Off';
  }
  if (typeof displayValidationWarnings === 'function') {
    try {
      displayValidationWarnings();
    } catch (e) {
      console.error('Error displaying warnings:', e);
    }
  }
}

function bindMessageToggleButton() {
  if (messageToggleBound) return;
  var toggleBtn = document.getElementById('messageToggleBtn');
  if (!toggleBtn) return;
  messageToggleBound = true;
  toggleBtn.addEventListener('click', function() {
    window.setMessagesEnabled(!window.AppState.messagesOn);
  });
  applyMessageToggleState();
}

function setMessagesEnabled(enabled) {
  window.AppState = window.AppState || {};
  window.AppState.messagesOn = !!enabled;
  applyMessageToggleState();
  if (typeof renderRunbookTable === 'function') renderRunbookTable();
  if (typeof updateTimeline === 'function') updateTimeline();
  if (typeof schedulePush === 'function' && window.canWrite && window.canWrite()) {
    schedulePush();
  }
}

window.setMessagesEnabled = setMessagesEnabled;

window.selectRecentCustomer = function(name, transform) {
  var input = document.getElementById('customerName');
  if (input) {
    input.value = name;
    // Trigger change event for Firebase sync
    var event = new Event('change', { bubbles: true });
    input.dispatchEvent(event);
  }

  var transformInput = document.getElementById('transformCycle');
  if (transformInput && typeof transform === 'string') {
    transformInput.value = transform;
    var transformEvent = new Event('change', { bubbles: true });
    transformInput.dispatchEvent(transformEvent);
  }

  var dropdown = document.getElementById('recentCustomersDropdown');
  if (dropdown) dropdown.classList.remove('show');

  // Update fullscreen info if in fullscreen mode
  if (window.AppState.fullscreenMode) {
    updateFullscreenCustomerInfo();
  }
}

function bindMessageToggleButton() {
  if (messageToggleBound) return;
  var toggleBtn = document.getElementById('messageToggleBtn');
  if (!toggleBtn) return;
  messageToggleBound = true;
  toggleBtn.addEventListener('click', function() {
    window.setMessagesEnabled(!window.AppState.messagesOn);
  });
  applyMessageToggleState();
}

function setMessagesEnabled(enabled) {
  window.AppState = window.AppState || {};
  window.AppState.messagesOn = !!enabled;
  applyMessageToggleState();
  if (typeof renderRunbookTable === 'function') renderRunbookTable();
  if (typeof updateTimeline === 'function') updateTimeline();
  if (typeof schedulePush === 'function' && window.canWrite && window.canWrite()) {
    schedulePush();
  }
}

// Initialize application after authentication when needed
document.addEventListener('DOMContentLoaded', function() {
  if (isAuthenticated) {
    runAuthenticatedStartup();
  }
});

function initializeApp() {
  updateTimeline();
  setupStartTimeInputs();
  calculateEndTime();
  updateCompletionPercentage();
  refreshTemplates();
  renderDowntimeControls();
}

function setupStartTimeInputs() {
  if (!window.AppState.downtimeStarted) {
    var startInput = document.getElementById('startTimeInput');
    var startDisplay = document.getElementById('startTimeDisplay');
    var durationInput = document.getElementById('currentDurationInput');
    var durationDisplay = document.getElementById('currentDurationDisplay');
    
    if (startInput) startInput.style.display = 'block';
    if (startDisplay) startDisplay.style.display = 'none';
    if (durationInput) durationInput.style.display = 'block';
    if (durationDisplay) durationDisplay.style.display = 'none';
    if (durationInput) durationInput.value = '00:00:00';

    // Set default start time
    var now = new Date();
    var hours = String(now.getHours()).padStart(2, '0');
    var minutes = String(now.getMinutes()).padStart(2, '0');
    if (startInput) startInput.value = hours + ':' + minutes;
  }
}

function calculateEndTime() {
  var duration = parseInt(document.getElementById('downtimeDuration').value) || 24;
  var startTimeInput = document.getElementById('startTimeInput');
  var plannedStart = resolvePlannedStartDate();
  
  if (!window.AppState.downtimeStarted && startTimeInput && startTimeInput.value) {
    var endDate = new Date(plannedStart.getTime() + duration * 3600000);
    updateEndTimeDisplay(endDate, duration);
  } else if (window.AppState.downtimeStarted && window.AppState.downtimeStartTime) {
    var endDate = new Date(window.AppState.downtimeStartTime.getTime() + duration * 3600000);
    updateEndTimeDisplay(endDate, duration);
  }

  updatePlannedWindowTime(null, plannedStart);
}

function updateEndTimeDisplay(endDate, duration) {
  var endTimeDisplay = document.getElementById('endTimeDisplay');
  if (!endTimeDisplay) return;
  
  var endHours = String(endDate.getHours()).padStart(2, '0');
  var endMinutes = String(endDate.getMinutes()).padStart(2, '0');
  var endSeconds = String(endDate.getSeconds()).padStart(2, '0');
  
  var displayText = endHours + ':' + endMinutes + ':' + endSeconds;
  
  var daysDiff = Math.floor(duration / 24);
  if (daysDiff > 0) {
    displayText += ' (+' + daysDiff + ' day' + (daysDiff > 1 ? 's' : '') + ')';
  }

  endTimeDisplay.textContent = displayText;
}

function formatClockTime(date, includeSeconds) {
  if (!(date instanceof Date) || isNaN(date)) return '--:--' + (includeSeconds ? ':--' : '');
  var hours = String(date.getHours()).padStart(2, '0');
  var minutes = String(date.getMinutes()).padStart(2, '0');
  if (!includeSeconds) return hours + ':' + minutes;
  var seconds = String(date.getSeconds()).padStart(2, '0');
  return hours + ':' + minutes + ':' + seconds;
}

function resolvePlannedStartDate(now) {
  var candidateNow = now instanceof Date ? now : new Date();
  var resolvedStart = resolveDowntimeStartTime();
  if (resolvedStart) return resolvedStart;

  var startTimeInput = document.getElementById('startTimeInput');
  if (startTimeInput && startTimeInput.value) {
    var parts = startTimeInput.value.split(':').map(Number);
    if (parts.length >= 2 && !parts.some(function(p) { return isNaN(p); })) {
      var startDate = new Date(candidateNow.getTime());
      startDate.setHours(parts[0], parts[1], candidateNow.getSeconds(), candidateNow.getMilliseconds());
      return startDate;
    }
  }

  return candidateNow;
}

function updatePlannedWindowTime(now, explicitStart) {
  var label = document.getElementById('plannedWindowTime');
  if (!label) return;

  var duration = parseInt(document.getElementById('downtimeDuration').value) || 24;
  var startDate = explicitStart instanceof Date ? explicitStart : resolvePlannedStartDate(now);
  if (!(startDate instanceof Date) || isNaN(startDate)) {
    label.textContent = 'Planned: --:-- â†’ --:--';
    return;
  }

  var endDate = new Date(startDate.getTime() + duration * 3600000);
  label.textContent = 'Planned: ' + formatClockTime(startDate, false) + ' â†’ ' + formatClockTime(endDate, false);
}

function updateLiveStartTime(now) {
  var liveLabel = document.getElementById('liveStartTime');
  if (!liveLabel) return;
  var current = now instanceof Date ? now : new Date();
  liveLabel.textContent = 'Current: ' + formatClockTime(current, true);
}

function updateClock() {
  var now = new Date();
  updateLiveStartTime(now);
  updatePlannedWindowTime(now);
  var timeElement = document.getElementById('currentTime');
  if (timeElement) {
    timeElement.textContent = now.toLocaleTimeString('en-US', {
      hour: '2-digit', 
      minute: '2-digit', 
      second: '2-digit', 
      hour12: false 
    });
  }

  // Only update duration if downtime has actually started
  if (window.AppState.downtimeStarted && window.AppState.downtimeStartTime && !window.AppState.downtimePaused) {
    updateDuration();
    updateProgressIndicators();
  } else if (!window.AppState.downtimeStarted) {
    // Ensure duration stays at 00:00:00 if not started
    var durationDisplay = document.getElementById('currentDurationDisplay');
    if (durationDisplay && durationDisplay.textContent !== '00:00:00') {
      durationDisplay.textContent = '00:00:00';
    }
  }
}

function resolveDowntimeStartTime() {
  var start = window.AppState.downtimeStartTime;
  if (!start) return null;
  return start instanceof Date ? start : new Date(start);
}

function getEffectivePausedDuration(now) {
  var pausedTotal = window.AppState.pausedDuration || 0;
  var pauseStart = window.AppState.pauseStartTime;
  if (window.AppState.downtimePaused && pauseStart) {
    var pauseStartDate = pauseStart instanceof Date ? pauseStart : new Date(pauseStart);
    if (!isNaN(pauseStartDate)) {
      pausedTotal += Math.max(0, now - pauseStartDate);
    }
  }
  return pausedTotal;
}

function captureCurrentDurationStamp(referenceTime) {
  if (!window.AppState || !window.AppState.downtimeStarted || !window.AppState.downtimeStartTime) {
    return null;
  }

  var display = document.getElementById('currentDurationDisplay');
  if (display) {
    var text = (display.textContent || '').trim();
    if (text && text !== '--:--:--' && /^\d{2,}:\d{2}:\d{2}$/.test(text)) {
      return text;
    }
  }

  var startTime = resolveDowntimeStartTime();
  if (!startTime) {
    return null;
  }

  var now = referenceTime instanceof Date ? referenceTime : new Date();
  var pausedOffset = getEffectivePausedDuration(now);
  var elapsed = Math.max(0, now - startTime - pausedOffset);
  var hours = Math.floor(elapsed / 3600000);
  var minutes = Math.floor((elapsed % 3600000) / 60000);
  var seconds = Math.floor((elapsed % 60000) / 1000);

  return String(hours).padStart(2, '0') + ':' + String(minutes).padStart(2, '0') + ':' + String(seconds).padStart(2, '0');
}

function updateDuration() {
  var durationDisplay = document.getElementById('currentDurationDisplay');
  if (!durationDisplay) return;

  var startTime = resolveDowntimeStartTime();
  if (!window.AppState.downtimeStarted || !startTime) {
    durationDisplay.textContent = '00:00:00';
    return;
  }

  var now = new Date();
  var pausedOffset = getEffectivePausedDuration(now);
  var elapsed = Math.max(0, now - startTime - pausedOffset);
  var hours = Math.floor(elapsed / 3600000);
  var minutes = Math.floor((elapsed % 3600000) / 60000);
  var seconds = Math.floor((elapsed % 60000) / 1000);

  durationDisplay.textContent =
    String(hours).padStart(2, '0') + ':' + String(minutes).padStart(2, '0') + ':' + String(seconds).padStart(2, '0');
}

// Data Validation Functions
function validateSchedules() {
  var warnings = [];
  var criticalPathItems = window.AppState.runbooks.filter(function(r) { return r.critical; });
  
  // Check for overlapping critical path items
  for (var i = 0; i < criticalPathItems.length; i++) {
    for (var j = i + 1; j < criticalPathItems.length; j++) {
      var item1 = criticalPathItems[i];
      var item2 = criticalPathItems[j];
      
      var start1 = item1.scheduleHours + item1.scheduleMinutes / 60;
      var end1 = start1 + item1.durationHours + item1.durationMinutes / 60;
      var start2 = item2.scheduleHours + item2.scheduleMinutes / 60;
      var end2 = start2 + item2.durationHours + item2.durationMinutes / 60;
      
      if ((start1 < end2 && end1 > start2)) {
        warnings.push('Critical path conflict: "' + item1.runblock + '" and "' + item2.runblock + '" overlap');
      }
    }
  }
  
  // Check for unrealistic durations
  window.AppState.runbooks.forEach(function(runbook) {
    var duration = runbook.durationHours + runbook.durationMinutes / 60;
    if (duration > 8) {
      warnings.push('Warning: "' + runbook.runblock + '" has duration > 8 hours');
    }
  });
  
  // Check for tasks extending beyond downtime window
  window.AppState.runbooks.forEach(function(runbook) {
    var start = runbook.scheduleHours + runbook.scheduleMinutes / 60;
    var duration = runbook.durationHours + runbook.durationMinutes / 60;
    if (start + duration > window.AppState.downtimeDuration) {
      warnings.push('Schedule conflict: "' + runbook.runblock + '" extends beyond downtime window');
    }
  });
  
  return warnings;
}

function displayValidationWarnings() {
  if (!window.AppState.messagesOn) { 
    var container = document.getElementById('validationMessages'); 
    if (container) container.innerHTML=''; 
    return; 
  }
  var warnings = validateSchedules();
  var container = document.getElementById('validationMessages');
  
  if (!container) return;
  
  container.innerHTML = '';
  if (warnings.length > 0) {
    var warningDiv = document.createElement('div');
    warningDiv.className = 'validation-warning';
    warningDiv.innerHTML = '<strong>âš ï¸ Validation Warnings:</strong><br>' + warnings.join('<br>');
    container.appendChild(warningDiv);
  }
}

// Check if element is actively being edited
function isElementActive(element) {
  var active = document.activeElement;
  return active && (active === element || element.contains(active));
}

// Runbook Management Functions
window.addRunbookRow = function() {
  var runbook = {
    id: Date.now() + Math.random(),
    sequence: window.AppState.runbooks.length + 1,
    strategy: STRATEGIES[0],
    phase: PHASES[0],
    runblock: '',
    responsibility: '',
    predecessor: '',
    critical: false,
    scheduleHours: 0,
    scheduleMinutes: 0,
    durationHours: 1,
    durationMinutes: 0,
    completed: false,
    actualDuration: null,
    position: 0,
    status: 'not-started'
  };
  
  window.AppState.runbooks.push(runbook);
  renderRunbookTable();
  updateTimeline();
  updateCompletionPercentage();
};

function renderRunbookTable() {
  if (window.AppState.renderLock) return;
  
  var tbody = document.getElementById('runbookBody');
  if (!tbody) return;
  
  // Don't re-render if user is actively editing ANY input
  var activeElement = document.activeElement;
  if (activeElement && (activeElement.tagName === 'INPUT' || activeElement.tagName === 'SELECT')) {
    return;
  }
  
  // Throttle renders to prevent flickering
  var now = Date.now();
  if (now - window.AppState.lastRenderTime < 100) {
    return;
  }
  window.AppState.lastRenderTime = now;
  
  window.AppState.renderLock = true;
  
  try {
    // Get filtered runbooks
    var filteredRunbooks = getFilteredRunbooks();
    filteredRunbooks.sort(function(a, b) { return a.sequence - b.sequence; });
    
    // Clear tbody
    tbody.innerHTML = '';
    
    // Check if we're the host and can write
    var canEdit = !window.canWrite || window.canWrite();
    
    // Create rows for filtered runbooks
    filteredRunbooks.forEach(function(runbook) {
      var row = document.createElement('tr');
      row.dataset.runbookId = runbook.id;
      row.draggable = canEdit;
      
      // Add drag events
      if (canEdit) {
        row.addEventListener('dragstart', handleRowDragStart);
        row.addEventListener('dragend', handleRowDragEnd);
        row.addEventListener('dragover', handleRowDragOver);
        row.addEventListener('drop', handleRowDrop);
        row.addEventListener('click', function() {
          window.AppState.selectedRunbookId = runbook.id;
          document.querySelectorAll('#runbookBody tr').forEach(function(r) {
            r.style.backgroundColor = '';
          });
          row.style.backgroundColor = 'rgba(10,110,209,0.1)';
        });
      }
      
      var editingDisabled = canEdit ? '' : 'disabled';
      
      var strategyOptions = STRATEGIES.map(function(s) {
        return '<option value="' + s + '" ' + (runbook.strategy === s ? 'selected' : '') + '>' + s + '</option>';
      }).join('');
      
      var phaseOptions = PHASES.map(function(p) {
        return '<option value="' + p + '" ' + (runbook.phase === p ? 'selected' : '') + '>' + p + '</option>';
      }).join('');
      
      var statusOptions = [
        {value: 'not-started', label: 'Not Started'},
        {value: 'in-progress', label: 'In Progress'},
        {value: 'blocked', label: 'Blocked'},
        {value: 'completed', label: 'Completed'},
        {value: 'skipped', label: 'Skipped'},
        {value: 'in-error', label: 'In Error'}
      ].map(function(s) {
        var selected = (runbook.status || 'not-started') === s.value ? 'selected' : '';
        return '<option value="' + s.value + '" ' + selected + '>' + s.label + '</option>';
      }).join('');
      
      row.innerHTML = 
        '<td style="padding:4px;"><span class="drag-handle" title="Drag to reorder">â‰¡</span></td>' +
        '<td>' +
        '<input type="number" min="1" max="30" value="' + runbook.sequence + '" ' +
        'style="width:60px;text-align:center;" onchange="updateSequence(' + runbook.id + ', this.value)" ' + editingDisabled + '>' +
        '</td>' +
        '<td>' +
        '<select onchange="updateStrategy(' + runbook.id + ', this.value)" ' + editingDisabled + '>' +
        strategyOptions +
        '</select>' +
        '</td>' +
        '<td>' +
        '<select onchange="updatePhase(' + runbook.id + ', this.value)" ' + editingDisabled + '>' +
        phaseOptions +
        '</select>' +
        '</td>' +
        '<td>' +
        '<input type="text" value="' + (runbook.runblock || '') + '" placeholder="Enter runblock name" ' +
        'maxlength="50" style="width:100%;" ' +
        'onchange="updateRunblock(' + runbook.id + ', this.value)" ' + editingDisabled + '>' +
        '</td>' +
        '<td>' +
        '<input type="text" value="' + (runbook.responsibility || '') + '" placeholder="Enter responsibility" ' +
        'maxlength="40" style="width:100%;" ' +
        'onchange="updateResponsibility(' + runbook.id + ', this.value)" ' + editingDisabled + '>' +
        '</td>' +
        '<td class="center">' +
        '<input type="text" value="' + (runbook.predecessor || '') + '" placeholder="Seq#" ' +
        'maxlength="10" style="width:70px;text-align:center;" ' +
        'onchange="updatePredecessor(' + runbook.id + ', this.value)" ' + editingDisabled + ' title="Enter sequence number of task that must complete first">' +
        '</td>' +
        '<td class="center">' +
        '<select class="status-select" onchange="updateStatus(' + runbook.id + ', this.value)" ' + editingDisabled + '>' +
        statusOptions +
        '</select>' +
        '</td>' +
        '<td class="critical-cell center">' +
        '<input type="checkbox" class="critical-checkbox" ' +
        (runbook.critical ? 'checked' : '') + ' ' +
        'onchange="updateCritical(' + runbook.id + ', this.checked)" ' + editingDisabled + '>' +
        '</td>' +
        '<td class="center">' +
        '<button class="btn small" onclick="duplicateRunbook(' + runbook.id + ')" ' + editingDisabled + ' title="Duplicate">ðŸ”„</button> ' +
        '<button class="btn small danger" onclick="removeRunbook(' + runbook.id + ')" ' + editingDisabled + '>Remove</button>' +
        '</td>';
      
      tbody.appendChild(row);
    });
    
  } finally {
    window.AppState.renderLock = false;
  }
}

// NEW: Drag and Drop Row Reordering Functions
function handleRowDragStart(e) {
  if (typeof window.canWrite === 'function' && !window.canWrite()) {
    e.preventDefault();
    return;
  }
  window.AppState.draggedRowId = parseFloat(e.currentTarget.dataset.runbookId);
  e.currentTarget.classList.add('dragging');
  e.dataTransfer.effectAllowed = 'move';
}

function handleRowDragEnd(e) {
  e.currentTarget.classList.remove('dragging');
  document.querySelectorAll('#runbookBody tr').forEach(function(row) {
    row.classList.remove('drag-over');
  });
}

function handleRowDragOver(e) {
  if (typeof window.canWrite === 'function' && !window.canWrite()) {
    return;
  }
  e.preventDefault();
  e.dataTransfer.dropEffect = 'move';

  var draggedId = window.AppState.draggedRowId;
  var targetId = parseFloat(e.currentTarget.dataset.runbookId);
  
  if (draggedId !== targetId) {
    e.currentTarget.classList.add('drag-over');
  }
}

function handleRowDrop(e) {
  if (typeof window.canWrite === 'function' && !window.canWrite()) {
    return;
  }
  e.preventDefault();

  var draggedId = window.AppState.draggedRowId;
  var targetId = parseFloat(e.currentTarget.dataset.runbookId);
  
  if (draggedId === targetId) return;
  
  var draggedRunbook = window.AppState.runbooks.find(function(r) { return r.id === draggedId; });
  var targetRunbook = window.AppState.runbooks.find(function(r) { return r.id === targetId; });
  
  if (!draggedRunbook || !targetRunbook) return;
  
  // Swap sequences
  var tempSeq = draggedRunbook.sequence;
  draggedRunbook.sequence = targetRunbook.sequence;
  targetRunbook.sequence = tempSeq;
  
  // Re-render
  setTimeout(function() {
    renderRunbookTable();
    updateTimeline();
  }, 10);
}

// NEW: Update Status Function
window.updateStatus = function(id, value) {
  var runbook = window.AppState.runbooks.find(function(r) { return r.id === id; });
  if (runbook) {
    runbook.status = value;
    
    // Auto-update completed flag
    if (value === 'completed') {
      runbook.completed = true;
      if (window.AppState.downtimeStarted && window.AppState.downtimeStartTime && !runbook.actualDuration) {
        var now = new Date();
        var stamp = captureCurrentDurationStamp(now);
        if (stamp) {
          runbook.actualDuration = stamp;
          window.AppState.completionTimes[id] = now.toISOString();
        }
      }
      recordPendingCompletionUpdate(id, true, runbook.actualDuration, window.AppState.completionTimes[id]);
    } else {
      runbook.completed = false;
      runbook.actualDuration = null;
      delete window.AppState.completionTimes[id];
      recordPendingCompletionUpdate(id, false, null, null);
    }

    updateCompletionPercentage();
    setTimeout(function() { updateTimeline(); }, 100);
  }
};

window.updateSequence = function(id, value) {
  var runbook = window.AppState.runbooks.find(function(r) { return r.id === id; });
  if (runbook) {
    runbook.sequence = parseInt(value) || 1;
    setTimeout(function() {
      renderRunbookTable();
      updateTimeline();
      displayValidationWarnings();
    }, 100);
  }
};

window.updateStrategy = function(id, value) {
  var runbook = window.AppState.runbooks.find(function(r) { return r.id === id; });
  if (runbook) {
    runbook.strategy = value;
    setTimeout(function() { updateTimeline(); }, 100);
  }
};

window.updatePhase = function(id, value) {
  var runbook = window.AppState.runbooks.find(function(r) { return r.id === id; });
  if (runbook) {
    runbook.phase = value;
    setTimeout(function() { updateTimeline(); }, 100);
  }
};

window.updateRunblock = function(id, value) {
  var runbook = window.AppState.runbooks.find(function(r) { return r.id === id; });
  if (runbook) {
    runbook.runblock = value;
    setTimeout(function() { updateTimeline(); }, 100);
  }
};

window.updateResponsibility = function(id, value) {
  var runbook = window.AppState.runbooks.find(function(r) { return r.id === id; });
  if (runbook) {
    runbook.responsibility = value;
  }
}

// NEW: Update Predecessor Function
window.updatePredecessor = function(id, value) {
  var runbook = window.AppState.runbooks.find(function(r) { return r.id === id; });
  if (runbook) {
    runbook.predecessor = value.trim();
    updateTimeline();
  }
};

window.updateCritical = function(id, value) {
  var runbook = window.AppState.runbooks.find(function(r) { return r.id === id; });
  if (runbook) {
    runbook.critical = value;
    setTimeout(function() {
      updateTimeline();
      displayValidationWarnings();
    }, 100);
  }
};

window.removeRunbook = function(id) {
  window.AppState.runbooks = window.AppState.runbooks.filter(function(r) { return r.id !== id; });
  renderRunbookTable();
  updateTimeline();
  displayValidationWarnings();
  updateCompletionPercentage();
};

window.clearRunbook = function() {
  if (confirm('Are you sure you want to clear all runbook entries?')) {
    window.AppState.runbooks = [];
    renderRunbookTable();
    updateTimeline();
    updateCompletionPercentage();
  }
};

// Timeline Functions
window.updateTimeline = function() {
  var duration = parseInt(document.getElementById('downtimeDuration').value) || 24;
  window.AppState.downtimeDuration = duration;
  
  generateTimeScale(duration);
  generateTimelineRows();
  refreshTimelineFieldLocks();
  syncTimelineDragPermissions();
  displayValidationWarnings();

  var finishLine = document.getElementById('finishLine');
  if (finishLine) {
    var pixelsPerHour = 60;
    finishLine.style.left = (duration * pixelsPerHour) + 'px';
    finishLine.style.display = 'block';
  }
  
  // Update progress if running
  if (window.AppState.downtimeStarted) {
    updateProgressIndicators();
  }
};

function generateTimeScale(hours) {
  var scale = document.getElementById('timelineScale');
  if (!scale) return;
  
  scale.innerHTML = '';
  
  var pixelsPerHour = 60;
  var totalWidth = hours * pixelsPerHour;
  scale.style.width = totalWidth + 'px';
  
  for (var h = 0; h <= hours; h++) {
    var marker = document.createElement('div');
    marker.className = 'timeline-hour';
    marker.style.left = (h * pixelsPerHour) + 'px';
    marker.textContent = h + 'h';
    scale.appendChild(marker);
  }
}

function generateTimelineRows() {
  var trackContainer = document.getElementById('timelineRows');
  var controlsContainer = document.getElementById('timelineControlsRows');
  
  if (!trackContainer || !controlsContainer) return;
  
  // Don't regenerate if user is editing timeline inputs
  if (window.AppState.timelineInputLock) {
    return;
  }
  
  // Use filtered runbooks for timeline
  var visibleRunbooks = getFilteredRunbooks()
    .filter(function(rb) { return rb && rb.runblock && rb.runblock.trim().length > 0; })
    .sort(function(a, b) { return a.sequence - b.sequence; });

  // Clear and regenerate track rows
  trackContainer.innerHTML = '';
  visibleRunbooks.forEach(function(runbook, index) {
    var trackRow = createTimelineRow(runbook, index);
    trackContainer.appendChild(trackRow);
  });
  
  // Update or create control rows (don't recreate if already exists)
  var existingRows = Array.from(controlsContainer.querySelectorAll('.timeline-control-row'));
  
  visibleRunbooks.forEach(function(runbook, index) {
    var existingRow = existingRows[index];
    
    if (existingRow) {
      // Update existing row without recreating inputs
      updateTimelineControlRow(existingRow, runbook);
    } else {
      // Create new row
      var controlRow = createTimelineControlRow(runbook);
      controlsContainer.appendChild(controlRow);
    }
  });
  
  // Remove extra rows
  while (controlsContainer.children.length > visibleRunbooks.length) {
    controlsContainer.removeChild(controlsContainer.lastChild);
  }
}

// NEW: Calculate block positions considering predecessors
function calculateBlockPositions() {
  var positions = {};
  var resolved = new Set();
  
  // Create a map for quick lookup by sequence
  var runbooksMap = {};
  window.AppState.runbooks.forEach(function(rb) {
    runbooksMap[rb.sequence] = rb;
  });
  
  // Resolve positions recursively
  function resolvePosition(rb) {
    if (resolved.has(rb.id)) {
      return positions[rb.id];
    }
    
    var scheduleTimeHours = (rb.scheduleHours || 0) + (rb.scheduleMinutes || 0) / 60;
    var durationTimeHours = (rb.durationHours || 1) + (rb.durationMinutes || 0) / 60;
    var startTime = scheduleTimeHours;
    
    // Check if there's a predecessor
    if (rb.predecessor) {
      var predSeq = parseInt(rb.predecessor);
      if (!isNaN(predSeq)) {
        var predecessor = null;
        // Find predecessor by sequence
        for (var i = 0; i < window.AppState.runbooks.length; i++) {
          if (window.AppState.runbooks[i].sequence === predSeq) {
            predecessor = window.AppState.runbooks[i];
            break;
          }
        }
        
        if (predecessor && predecessor.id !== rb.id) {
          // Resolve predecessor first (recursive)
          var predPos = resolvePosition(predecessor);
          var predDuration = (predecessor.durationHours || 1) + (predecessor.durationMinutes || 0) / 60;
          var predEndTime = predPos.start + predDuration;
          // Start after predecessor ends
          startTime = Math.max(startTime, predEndTime);
        }
      }
    }
    
    positions[rb.id] = {
      start: startTime,
      end: startTime + durationTimeHours
    };
    resolved.add(rb.id);
    
    return positions[rb.id];
  }
  
  // Resolve all runbooks
  window.AppState.runbooks.forEach(function(rb) {
    if (!resolved.has(rb.id)) {
      resolvePosition(rb);
    }
  });
  
  return positions;
}

function createTimelineRow(runbook, index) {
  var row = document.createElement('div');
  row.className = 'timeline-row';
  
  if (runbook.critical) {
    row.style.borderLeft = '3px solid #ff0000';
    row.style.background = 'linear-gradient(90deg, rgba(255,0,0,0.05) 0%, transparent 10%)';
  }
  
  var track = document.createElement('div');
  track.className = 'timeline-track';
  track.dataset.runbookId = runbook.id;
  
  var pixelsPerHour = 60;
  var totalWidth = window.AppState.downtimeDuration * pixelsPerHour;
  track.style.width = totalWidth + 'px';

  var isQualityGate = (runbook.strategy === 'Quality Gate');
  
  // Calculate position considering predecessors
  var blockPositions = calculateBlockPositions();
  var pos = blockPositions[runbook.id];
  var startPos = pos ? pos.start : (runbook.scheduleHours + (runbook.scheduleMinutes / 60));
  var startX = startPos * pixelsPerHour;

  if (isQualityGate) {
    var diamond = document.createElement('div');
    diamond.className = 'quality-diamond';
    diamond.dataset.runbookId = runbook.id;
    diamond.style.left = Math.max(0, startX - 7) + 'px';
    if (runbook.completed) {
      diamond.style.opacity = '0.5';
      diamond.style.filter = 'grayscale(100%)';
    }
    if (runbook.critical) {
      diamond.style.boxShadow = '0 0 8px rgba(255, 0, 0, 0.6)';
    }
    
    // Add tooltip events
    diamond.addEventListener('mouseenter', function(e) {
      showEnhancedTooltip(runbook, e);
    });
    diamond.addEventListener('mousemove', function(e) {
      var tooltip = document.getElementById('enhancedTooltip');
      if (tooltip && tooltip.classList.contains('show')) {
        tooltip.style.left = (e.clientX + 20) + 'px';
        tooltip.style.top = (e.clientY + 20) + 'px';
      } else {
        showEnhancedTooltip(runbook, e, true);
      }
    });
    diamond.addEventListener('mouseleave', hideEnhancedTooltip);
    
    track.appendChild(diamond);
    
    // Add horizontal label to the RIGHT of diamond (positioned relative to track, not diamond)
    var label = document.createElement('div');
    label.className = 'quality-gate-label';
    label.textContent = runbook.runblock;
    label.title = runbook.runblock + ' - ' + runbook.phase;
    label.style.position = 'absolute';
    label.style.left = Math.max(0, startX + 10) + 'px';
    label.style.top = '50%';
    label.style.transform = 'translateY(-50%)';
    track.appendChild(label);
  } else {
    var block = createTimelineBlock(runbook);
    track.appendChild(block);
  }

  row.appendChild(track);
  var trackEditable = typeof window.canWrite === 'function' ? window.canWrite() : true;
  if (trackEditable) {
    track.addEventListener('dragover', handleDragOver);
    track.addEventListener('drop', handleDrop);
  }
  return row;
}

function syncTimelineDragPermissions() {
  var canWrite = typeof window.canWrite === 'function' ? window.canWrite() : true;
  var tracks = document.querySelectorAll('.timeline-track');
  tracks.forEach(function(track) {
    track.classList.toggle('timeline-readonly', !canWrite);
    track.removeEventListener('dragover', handleDragOver);
    track.removeEventListener('drop', handleDrop);
    if (canWrite) {
      track.addEventListener('dragover', handleDragOver);
      track.addEventListener('drop', handleDrop);
    }
  });

  var blocks = document.querySelectorAll('.timeline-block');
  blocks.forEach(function(block) {
    var runbookId = parseFloat(block.dataset.runbookId);
    var runbook = window.AppState.runbooks.find(function(r) { return r.id === runbookId; });
    var status = runbook ? (runbook.status || '') : '';
    var completed = !!(runbook && (runbook.completed || status === 'completed'));
    var allowDrag = canWrite && !completed;

    block.draggable = allowDrag;
    block.classList.toggle('timeline-readonly-block', !allowDrag);

    block.removeEventListener('dragstart', handleDragStart);
    block.removeEventListener('dragend', handleDragEnd);
    if (allowDrag) {
      block.addEventListener('dragstart', handleDragStart);
      block.addEventListener('dragend', handleDragEnd);
    }
  });
}

function isDowntimeTrackerRunning() {
  var state = window.AppState || {};
  return !!(state.downtimeStarted && state.downtimeStartTime && !state.downtimePaused);
}

function shouldLockTimelineField(runbook) {
  if (!runbook) return false;
  return isDowntimeTrackerRunning() && !!runbook.completed;
}

function applyTimelineFieldLock(input, locked) {
  if (!input) return;
  var isLocked = !!locked;
  input.readOnly = isLocked;
  input.style.background = isLocked ? '#f8fafb' : '#fff';
  if (isLocked) {
    input.setAttribute('title', 'Locked while downtime tracking is active');
  } else {
    input.removeAttribute('title');
  }
}

function resolveTimelineInputValue(runbook, field) {
  if (!runbook) return '00:00';
  if (field === 'start' && runbook.__startDraft !== undefined && runbook.__startDraft !== null) {
    return runbook.__startDraft;
  }
  if (field === 'plan' && runbook.__planDraft !== undefined && runbook.__planDraft !== null) {
    return runbook.__planDraft;
  }
  if (field === 'start') {
    return formatHHMM(runbook.scheduleHours, runbook.scheduleMinutes);
  }
  if (field === 'plan') {
    return formatHHMM(runbook.durationHours, runbook.durationMinutes);
  }
  return '00:00';
}

function refreshTimelineFieldLocks() {
  var rows = document.querySelectorAll('.timeline-control-row');
  if (!rows || !rows.length) return;

  rows.forEach(function(row) {
    if (!row || !row.dataset) return;
    var runbookKey = row.dataset.runbookId;
    if (!runbookKey) return;

    var runbook = window.AppState.runbooks.find(function(r) {
      return String(r.id) === String(runbookKey) || r.id === Number(runbookKey);
    });
    if (!runbook) return;

    var inputs = row.querySelectorAll('input[type="text"]');
    if (!inputs || !inputs.length) return;

    var startInput = Array.prototype.find.call(inputs, function(el) {
      return el.dataset && el.dataset.fieldType === 'start';
    });
    var planInput = Array.prototype.find.call(inputs, function(el) {
      return el.dataset && el.dataset.fieldType === 'plan';
    });

    applyTimelineFieldLock(startInput, shouldLockTimelineField(runbook));
    applyTimelineFieldLock(planInput, shouldLockTimelineField(runbook));
  });
}

function createTimelineControlRow(runbook) {
  var row = document.createElement('div');
  row.className = 'timeline-control-row';
  row.dataset.runbookId = runbook.id;

  // START column - editable until completed
  var startCell = document.createElement('div');
  startCell.className = 'timeline-control-cell';
  var startInput = document.createElement('input');
  startInput.type = 'text';
  startInput.pattern = '[0-9]{1,3}:[0-9]{2}';
  startInput.placeholder = 'HH:MM';
  startInput.value = resolveTimelineInputValue(runbook, 'start');
  startInput.dataset.runbookId = runbook.id;
  startInput.dataset.fieldType = 'start';
  var startLocked = shouldLockTimelineField(runbook);
  applyTimelineFieldLock(startInput, startLocked);
  
  startInput.onfocus = function() { 
    window.AppState.timelineInputLock = true;
    window.AppState.focusedTimelineInput = this;
  };
  startInput.onblur = function() {
    setTimeout(function() {
      window.AppState.timelineInputLock = false;
      window.AppState.focusedTimelineInput = null;
      try {
        var id = runbook.id;
        var latest = window.AppState.runbooks.find(function(r) { return r.id === id; });
        if (latest && startInput) {
          startInput.value = resolveTimelineInputValue(latest, 'start');
        }
      } catch (err) {
        console.warn('Unable to refresh start value after blur:', err);
      }
    }, 300);
  };
  startInput.onchange = function() { updateScheduleTime(runbook.id, this.value); };
  startInput.oninput = startInput.onchange;
  startCell.appendChild(startInput);
  row.appendChild(startCell);

  // PLAN column - editable until completed
  var planCell = document.createElement('div');
  planCell.className = 'timeline-control-cell';
  var planInput = document.createElement('input');
  planInput.type = 'text';
  planInput.pattern = '[0-9]{1,3}:[0-9]{2}';
  planInput.placeholder = 'HH:MM';
  planInput.value = resolveTimelineInputValue(runbook, 'plan');
  planInput.dataset.runbookId = runbook.id;
  planInput.dataset.fieldType = 'plan';
  var planLocked = shouldLockTimelineField(runbook);
  applyTimelineFieldLock(planInput, planLocked);
  
  planInput.onfocus = function() { 
    window.AppState.timelineInputLock = true;
    window.AppState.focusedTimelineInput = this;
  };
  planInput.onblur = function() {
    setTimeout(function() {
      window.AppState.timelineInputLock = false;
      window.AppState.focusedTimelineInput = null;
      try {
        var id = runbook.id;
        var latest = window.AppState.runbooks.find(function(r) { return r.id === id; });
        if (latest && planInput) {
          planInput.value = resolveTimelineInputValue(latest, 'plan');
        }
      } catch (err) {
        console.warn('Unable to refresh plan value after blur:', err);
      }
    }, 300);
  };
  planInput.onchange = function() { updateDurationTime(runbook.id, this.value); };
  planInput.oninput = planInput.onchange;
  planCell.appendChild(planInput);
  row.appendChild(planCell);

  // END column - only enabled when downtime is started and not paused
  var endCell = document.createElement('div');
  endCell.className = 'timeline-control-cell';
  var checkbox = document.createElement('input');
  checkbox.type = 'checkbox';
  checkbox.className = 'timeline-checkbox';
  checkbox.checked = runbook.completed;
  checkbox.title = 'Mark as completed';
  var canToggle = window.AppState.downtimeStarted && !window.AppState.downtimePaused;
  if (typeof window.canWrite === 'function') {
    canToggle = canToggle && window.canWrite();
  }
  checkbox.disabled = !canToggle;
  checkbox.dataset.runbookId = runbook.id;
  checkbox.onchange = function() { toggleCompleted(runbook.id, this.checked); };
  endCell.appendChild(checkbox);
  row.appendChild(endCell);
  
  // ACTUAL column
  var actualCell = document.createElement('div');
  actualCell.className = 'timeline-control-cell';
  var actualSpan = document.createElement('span');
  actualSpan.style.fontSize = '11px';
  actualSpan.style.color = runbook.actualDuration ? '#107e3e' : '#999';
  actualSpan.textContent = runbook.actualDuration || '--:--:--';
  actualSpan.dataset.runbookId = runbook.id;
  actualCell.appendChild(actualSpan);
  row.appendChild(actualCell);
  
  return row;
}

// New function to update existing timeline control row without recreating inputs
function updateTimelineControlRow(row, runbook) {
  if (!row || !runbook) return;
  
  row.dataset.runbookId = runbook.id;
  
  var cells = row.querySelectorAll('.timeline-control-cell');
  if (cells.length < 4) return;
  
  // Update START input (only if not currently focused)
  var startInput = cells[0].querySelector('input[type="text"]');
  if (startInput && startInput !== window.AppState.focusedTimelineInput) {
    var newStartValue = resolveTimelineInputValue(runbook, 'start');
    if (startInput.value !== newStartValue) {
      startInput.value = newStartValue;
    }
    var startLocked = shouldLockTimelineField(runbook);
    applyTimelineFieldLock(startInput, startLocked);
  }

  // Update PLAN input (only if not currently focused)
  var planInput = cells[1].querySelector('input[type="text"]');
  if (planInput && planInput !== window.AppState.focusedTimelineInput) {
    var newPlanValue = resolveTimelineInputValue(runbook, 'plan');
    if (planInput.value !== newPlanValue) {
      planInput.value = newPlanValue;
    }
    var planLocked = shouldLockTimelineField(runbook);
    applyTimelineFieldLock(planInput, planLocked);
  }
  
  // Update END checkbox
  var checkbox = cells[2].querySelector('input[type="checkbox"]');
  if (checkbox) {
    checkbox.checked = runbook.completed;
    var canToggle = window.AppState.downtimeStarted && !window.AppState.downtimePaused;
    if (typeof window.canWrite === 'function') {
      canToggle = canToggle && window.canWrite();
    }
    checkbox.disabled = !canToggle;
  }
  
  // Update ACTUAL display
  var actualSpan = cells[3].querySelector('span');
  if (actualSpan) {
    actualSpan.textContent = runbook.actualDuration || '--:--:--';
    actualSpan.style.color = runbook.actualDuration ? '#107e3e' : '#999';
  }
}

// Allow timeline blocks to shrink when plan minutes are less than an hour
var MIN_TIMELINE_BLOCK_WIDTH = 20;

function createTimelineBlock(runbook) {
  var block = document.createElement('div');
  var strategyClass = runbook.strategy.toLowerCase().replace(/\s+/g, '');
  block.className = 'timeline-block block-' + strategyClass;
  block.dataset.runbookId = runbook.id;
  var timelineEditable = typeof window.canWrite === 'function' ? window.canWrite() : true;
  
  // Add status-specific styling
  var status = runbook.status || 'not-started';
  if (status === 'blocked') {
    block.style.border = '2px solid #f44336';
    block.style.filter = 'brightness(0.8)';
  } else if (status === 'in-progress') {
    block.style.boxShadow = '0 0 8px rgba(33, 150, 243, 0.8)';
  } else if (status === 'skipped') {
    block.style.opacity = '0.5';
    block.style.textDecoration = 'line-through';
  } else if (status === 'in-error') {
    block.style.border = '2px solid #d32f2f';
    block.style.boxShadow = '0 0 8px rgba(211, 47, 47, 0.8)';
  }
  
  if (runbook.critical) {
    block.classList.add('critical');
  }
  
  if (runbook.completed || status === 'completed') {
    block.classList.add('completed');
    block.draggable = false;
  } else {
    block.draggable = timelineEditable;
  }
  
  var pixelsPerHour = 60;
  
  // Calculate position considering predecessors
  var blockPositions = calculateBlockPositions();
  var pos = blockPositions[runbook.id];
  var position = pos ? pos.start : (runbook.scheduleHours + (runbook.scheduleMinutes / 60));
  var duration = runbook.durationHours + (runbook.durationMinutes / 60);
  
  block.style.left = (position * pixelsPerHour) + 'px';
  block.style.width = Math.max(MIN_TIMELINE_BLOCK_WIDTH, duration * pixelsPerHour - 4) + 'px';
  
  // Show only the sequence number inside the block for a cleaner timeline
  var sequenceLabel = runbook.sequence != null ? '#' + runbook.sequence : '#?';
  var runblockName = runbook.runblock || 'Runblock';
  block.textContent = sequenceLabel;
  block.title = sequenceLabel + ' ' + runblockName + ' - ' + (runbook.phase || 'â€”') + ' [' + status + ']';
  block.setAttribute('aria-label', sequenceLabel + ' ' + runblockName);
  
  // Add external label for runblock name
  var blockLabel = document.createElement('div');
  blockLabel.className = 'block-label-external';
  blockLabel.textContent = runblockName;
  blockLabel.title = runblockName;
  blockLabel.setAttribute('aria-hidden', 'true');
  block.appendChild(blockLabel);
  
  if (runbook.critical) {
    var indicator = document.createElement('div');
    indicator.className = 'critical-indicator';
    indicator.textContent = '!';
    indicator.title = 'Critical Path Item';
    block.appendChild(indicator);
  }
  
  // Add tooltip events
  block.addEventListener('mouseenter', function(e) {
    showEnhancedTooltip(runbook, e);
  });
  block.addEventListener('mousemove', function(e) {
    var tooltip = document.getElementById('enhancedTooltip');
    if (tooltip && tooltip.classList.contains('show')) {
      tooltip.style.left = (e.clientX + 20) + 'px';
      tooltip.style.top = (e.clientY + 20) + 'px';
    } else {
      showEnhancedTooltip(runbook, e, true);
    }
  });
  block.addEventListener('mouseleave', hideEnhancedTooltip);
  
  if (!runbook.completed && status !== 'completed' && timelineEditable) {
    block.addEventListener('dragstart', handleDragStart);
    block.addEventListener('dragend', handleDragEnd);
  }
  
  return block;
}

// Drag and Drop Handlers
function handleDragStart(e) {
  if (typeof window.canWrite === 'function' && !window.canWrite()) {
    e.preventDefault();
    return;
  }
  e.dataTransfer.effectAllowed = 'move';
  e.target.classList.add('dragging');
  window.AppState.currentDraggedBlock = e.target;

  var rect = e.target.getBoundingClientRect();
  window.AppState.dragOffset = e.clientX - rect.left;
}

function handleDragEnd(e) {
  if (typeof window.canWrite === 'function' && !window.canWrite()) {
    return;
  }
  e.target.classList.remove('dragging');
  window.AppState.currentDraggedBlock = null;
  window.AppState.dragOffset = 0;
}

function handleDragOver(e) {
  if (typeof window.canWrite === 'function' && !window.canWrite()) {
    return;
  }
  e.preventDefault();
  e.dataTransfer.dropEffect = 'move';
  
  if (window.AppState.currentDraggedBlock && e.currentTarget.classList.contains('timeline-track')) {
    var track = e.currentTarget;
    var rect = track.getBoundingClientRect();
    var x = e.clientX - rect.left - (window.AppState.dragOffset || 0);
    var pixelsPerHour = 60;
    
    var position = Math.max(0, x / pixelsPerHour);
    var runbookId = parseFloat(window.AppState.currentDraggedBlock.dataset.runbookId);
    var runbook = window.AppState.runbooks.find(function(r) { return r.id === runbookId; });
    
    if (runbook) {
      var duration = runbook.durationHours + (runbook.durationMinutes / 60);
      var maxPosition = window.AppState.downtimeDuration - duration;
      var validPosition = Math.min(position, maxPosition);
      
      window.AppState.currentDraggedBlock.style.left = (validPosition * pixelsPerHour) + 'px';
    }
  }
}

function handleDrop(e) {
  if (typeof window.canWrite === 'function' && !window.canWrite()) {
    return;
  }
  e.preventDefault();

  if (!window.AppState.currentDraggedBlock) return;
  
  var track = e.currentTarget;
  var rect = track.getBoundingClientRect();
  var x = e.clientX - rect.left - (window.AppState.dragOffset || 0);
  var pixelsPerHour = 60;
  var newPosition = Math.max(0, x / pixelsPerHour);
  
  var runbookId = parseFloat(window.AppState.currentDraggedBlock.dataset.runbookId);
  var runbook = window.AppState.runbooks.find(function(r) { return r.id === runbookId; });
  
  if (runbook) {
    var duration = runbook.durationHours + (runbook.durationMinutes / 60);
    var maxPosition = window.AppState.downtimeDuration - duration;
    var finalPosition = Math.min(newPosition, maxPosition);
    var snappedPosition = Math.round(finalPosition * 12) / 12;
    
    var newHours = Math.floor(snappedPosition);
    var newMinutes = Math.round((snappedPosition % 1) * 60);
    
    runbook.scheduleHours = newHours;
    runbook.scheduleMinutes = newMinutes;
    
    updateTimeline();
  }
}

// Debounced update functions for better performance
var scheduleTimeUpdateDebounce = {};
var durationTimeUpdateDebounce = {};

window.updateScheduleTime = function(id, value) {
  var runbook = window.AppState.runbooks.find(function(r) { return r.id === id; });
  if (runbook) {
    var t = parseHHMM(value);
    if (!t.ok) {
      if (scheduleTimeUpdateDebounce[id]) {
        clearTimeout(scheduleTimeUpdateDebounce[id]);
        delete scheduleTimeUpdateDebounce[id];
      }
      runbook.__startDraft = value;
      return;
    }

    delete runbook.__startDraft;
    runbook.scheduleHours = t.h;
    runbook.scheduleMinutes = t.m;

    // Clear existing timeout for this runbook
    if (scheduleTimeUpdateDebounce[id]) {
      clearTimeout(scheduleTimeUpdateDebounce[id]);
    }
    
    // Debounce the timeline update
    scheduleTimeUpdateDebounce[id] = setTimeout(function() {
      try {
        var controls = document.getElementById('timelineControlsRows');
        var sorted = window.AppState.runbooks.slice().sort(function(a,b) { return a.sequence - b.sequence; });
        var idx = sorted.findIndex(function(r) { return r.id === id; });
        if (controls && idx > -1 && controls.children[idx]) {
          var inp = controls.children[idx].querySelectorAll('.timeline-control-cell input[type="text"]')[0];
          if (inp && inp !== window.AppState.focusedTimelineInput) {
            inp.value = resolveTimelineInputValue(runbook, 'start');
          }
        }
      } catch(e) {
        console.error('Error updating schedule time display:', e);
      }
      updateSingleBlockPosition(id);
      scheduleConflicts();
      scheduleValidation();
      delete scheduleTimeUpdateDebounce[id];
    }, 300);
  }
};

window.updateDurationTime = function(id, value) {
  var runbook = window.AppState.runbooks.find(function(r) { return r.id === id; });
  if (runbook) {
    var t = parseHHMM(value);
    if (!t.ok) {
      if (durationTimeUpdateDebounce[id]) {
        clearTimeout(durationTimeUpdateDebounce[id]);
        delete durationTimeUpdateDebounce[id];
      }
      runbook.__planDraft = value;
      return;
    }

    delete runbook.__planDraft;
    runbook.durationHours = t.h;
    runbook.durationMinutes = t.m;

    // Clear existing timeout for this runbook
    if (durationTimeUpdateDebounce[id]) {
      clearTimeout(durationTimeUpdateDebounce[id]);
    }
    
    // Debounce the timeline update
    durationTimeUpdateDebounce[id] = setTimeout(function() {
      try {
        var controls = document.getElementById('timelineControlsRows');
        var sorted = window.AppState.runbooks.slice().sort(function(a,b) { return a.sequence - b.sequence; });
        var idx = sorted.findIndex(function(r) { return r.id === id; });
        if (controls && idx > -1 && controls.children[idx]) {
          var inp = controls.children[idx].querySelectorAll('.timeline-control-cell input[type="text"]')[1];
          if (inp && inp !== window.AppState.focusedTimelineInput) {
            inp.value = resolveTimelineInputValue(runbook, 'plan');
          }
        }
      } catch(e) {
        console.error('Error updating duration time display:', e);
      }
      updateSingleBlockWidth(id);
      scheduleConflicts();
      scheduleValidation();
      delete durationTimeUpdateDebounce[id];
    }, 300);
  }
};

function ensurePendingCompletionMap() {
  if (!window.AppState.pendingCompletionUpdates) {
    window.AppState.pendingCompletionUpdates = {};
  }
  return window.AppState.pendingCompletionUpdates;
}

function recordPendingCompletionUpdate(id, completed, actualDuration, completionIso) {
  var pending = ensurePendingCompletionMap();
  var key = String(id);
  pending[key] = {
    completed: !!completed,
    actualDuration: actualDuration || null,
    completionIso: completionIso || null,
    timestamp: Date.now()
  };
}

function reconcilePendingCompletionUpdates() {
  var pending = window.AppState.pendingCompletionUpdates;
  if (!pending) return false;
  if (typeof window.canWrite === 'function' && !window.canWrite()) {
    window.AppState.pendingCompletionUpdates = {};
    return false;
  }

  var keys = Object.keys(pending);
  if (!keys.length) return false;

  var now = Date.now();
  var changed = false;

  keys.forEach(function(key) {
    var entry = pending[key];
    if (!entry) {
      delete pending[key];
      return;
    }
    if (now - entry.timestamp > 30000) {
      delete pending[key];
      return;
    }

    var runbook = window.AppState.runbooks.find(function(r) {
      return String(r.id) === key || r.id === Number(key);
    });

    if (!runbook) {
      delete pending[key];
      return;
    }

    var desiredCompleted = !!entry.completed;
    var desiredActual = entry.actualDuration || null;
    var currentCompleted = !!runbook.completed;
    var currentActual = runbook.actualDuration || null;

    if (currentCompleted !== desiredCompleted || currentActual !== desiredActual) {
      runbook.completed = desiredCompleted;
      runbook.actualDuration = desiredActual;
      if (desiredCompleted && entry.completionIso) {
        window.AppState.completionTimes = window.AppState.completionTimes || {};
        window.AppState.completionTimes[runbook.id] = entry.completionIso;
      } else if (!desiredCompleted && window.AppState.completionTimes) {
        delete window.AppState.completionTimes[runbook.id];
      }
      entry.timestamp = now;
      changed = true;
    } else {
      delete pending[key];
    }
  });

  return changed;
}

window.toggleCompleted = function(id, checked) {
  if (typeof window.canWrite === 'function' && !window.canWrite()) {
    setTimeout(function() {
      if (typeof updateTimeline === 'function') updateTimeline();
      if (typeof renderRunbookTable === 'function') renderRunbookTable(true);
    }, 0);
    return;
  }

  var runbook = window.AppState.runbooks.find(function(r) { return r.id === id; });
  if (runbook) {
    runbook.completed = checked;

    if (checked && window.AppState.downtimeStartTime) {
      var now = new Date();
      var stamp = captureCurrentDurationStamp(now);
      if (stamp) {
        runbook.actualDuration = stamp;
        window.AppState.completionTimes[id] = now.toISOString();
        recordPendingCompletionUpdate(id, true, runbook.actualDuration, window.AppState.completionTimes[id]);

        // Force immediate update to timeline to show actual duration
        setTimeout(function() {
          var controls = document.getElementById('timelineControlsRows');
          var sorted = window.AppState.runbooks.slice().sort(function(a,b) { return a.sequence - b.sequence; });
          var idx = sorted.findIndex(function(r) { return r.id === id; });
          if (controls && idx > -1 && controls.children[idx]) {
            var actualCell = controls.children[idx].querySelectorAll('.timeline-control-cell')[3];
            if (actualCell) {
              var actualSpan = actualCell.querySelector('span');
              if (actualSpan) {
                actualSpan.textContent = runbook.actualDuration;
                actualSpan.style.color = '#107e3e';
              }
            }
          }
        }, 50);
      }
    } else if (!checked) {
      runbook.actualDuration = null;
      delete window.AppState.completionTimes[id];
      recordPendingCompletionUpdate(id, false, null, null);
    } else {
      recordPendingCompletionUpdate(id, checked, runbook.actualDuration, window.AppState.completionTimes[id]);
    }

    // Update completion percentage
    updateCompletionPercentage();

    // Delay the timeline update to prevent interference with checkbox
    setTimeout(function() {
      updateTimeline();
    }, 100);
  }
};

function renderDowntimeControls() {
  const controls = document.getElementById('downtimeControls');
  if (!controls) return;

  const canWrite = typeof window.canWrite === 'function' ? window.canWrite() : true;
  const state = window.AppState || {};
  const hasStarted = !!(state.downtimeStarted && state.downtimeStartTime);
  const isPaused = !!state.downtimePaused;

  const modePrefix = canWrite ? 'host' : 'viewer';
  const phaseState = hasStarted ? (isPaused ? 'paused' : 'running') : 'idle';
  const nextState = modePrefix + '-' + phaseState;

  if (controls.dataset.state === nextState) {
    return;
  }

  controls.dataset.state = nextState;

  if (!canWrite) {
    if (hasStarted) {
      controls.innerHTML = '<div class="downtime-host-message">Controlled by host</div>';
    } else {
      controls.innerHTML = '<button class="btn primary" id="startDowntimeBtn" onclick="startDowntime()" disabled title="Only the host can start downtime">Start Downtime</button>';
    }
    return;
  }

  if (!hasStarted) {
    controls.innerHTML = '<button class="btn primary" id="startDowntimeBtn" onclick="startDowntime()">Start Downtime</button>';
  } else if (isPaused) {
    controls.innerHTML = '<button class="btn primary" id="resumeDowntimeBtn" onclick="resumeDowntime()">â–¶ Resume</button>' +
      '<button class="btn danger" id="stopDowntimeBtn" onclick="stopDowntime()">â¹ Stop</button>';
  } else {
    controls.innerHTML = '<button class="btn warning" id="pauseDowntimeBtn" onclick="pauseDowntime()">â¸ Pause</button>' +
      '<button class="btn danger" id="stopDowntimeBtn" onclick="stopDowntime()">â¹ Stop</button>';
  }
}

// Downtime Control Functions
window.startDowntime = function() {
  // Check if user can actually control (is host)
  if (!window.canWrite()) {
    alert("âš ï¸ You are in VIEWER mode and cannot start downtime.\n\nOnly the HOST can control the session.");
    return;
  }

  if (window.AppState.downtimeStarted && window.AppState.downtimeStartTime) {
    renderDowntimeControls();
    if (window.AppState.downtimePaused) {
      alert('Downtime is currently paused. Resume or stop before starting a new session.');
    } else {
      alert('Downtime is already in progress. Use the pause or stop controls to manage the session.');
    }
    return;
  }

  // Always use current system time when starting
  window.AppState.downtimeStartTime = new Date();

  window.AppState.downtimeStarted = true;
  window.AppState.downtimePaused = false;
  window.AppState.pausedDuration = 0;
  window.AppState.pauseStartTime = null;
  window.AppState.pendingCompletionUpdates = {};
  
  var downtimeDuration = parseInt(document.getElementById('downtimeDuration').value) || 24;
  window.AppState.downtimeDuration = downtimeDuration;
  
  // Lock customer name and transform cycle inputs
  var customerNameInput = document.getElementById('customerName');
  var transformCycleInput = document.getElementById('transformCycle');
  if (customerNameInput) customerNameInput.disabled = true;
  if (transformCycleInput) transformCycleInput.disabled = true;

  var hostId = null;
  if (typeof window.getCurrentUid === 'function') {
    try {
      hostId = window.getCurrentUid();
    } catch (e) {
      console.warn('Unable to read current UID from helper', e);
    }
  }
  if (!hostId && typeof window !== 'undefined' && window.currentUid) {
    hostId = window.currentUid;
  }
  console.log("âœ“ Downtime started by host:", hostId || 'unknown');
  
  // Update UI
  document.getElementById('startTimeInput').style.display = 'none';
  document.getElementById('startTimeDisplay').style.display = 'block';
  document.getElementById('currentDurationInput').style.display = 'none';
  document.getElementById('currentDurationDisplay').style.display = 'block';

  var startTimeStr = window.AppState.downtimeStartTime.toLocaleTimeString('en-US',
    { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
  
  document.getElementById('startTimeDisplay').textContent = startTimeStr;
  
  // Set current duration to 00:00:00
  document.getElementById('currentDurationDisplay').textContent = '00:00:00';

  calculateEndTime();

  // Kick off timers immediately so the tracker and duration reflect the new session without delay
  if (!clockIntervalId) {
    clockIntervalId = setInterval(updateClock, 1000);
  }
  updateClock();

  document.getElementById('statusText').textContent = 'In Progress';
  document.getElementById('statusText').style.color = 'var(--sap-error)';

  renderDowntimeControls();
  
  var currentLine = document.getElementById('currentTimeLine');
  if (currentLine) {
    currentLine.style.display = 'block';
    currentLine.style.left = '0px';
  }
  
  updateProgressIndicators();
  updateTimeline();
  renderRunbookTable();

  if (typeof schedulePush === 'function' && window.canWrite && window.canWrite()) {
    schedulePush('downtime-start');
  }
  recordStatusChange('downtime-start', { message: 'Downtime started' });
};

window.pauseDowntime = function() {
  if (!window.AppState.downtimePaused) {
    var reasonInput = prompt('Pause reason (optional):', window.AppState.lastPauseReason || '');
    if (reasonInput === null) {
      reasonInput = '';
    }
    window.AppState.lastPauseReason = (reasonInput || '').trim();
    window.AppState.downtimePaused = true;
    window.AppState.pauseStartTime = new Date();
    document.getElementById('statusText').textContent = 'Paused';
    document.getElementById('statusText').style.color = 'var(--sap-warning)';

    renderDowntimeControls();

    updateDuration();
    updateProgressIndicators();
    updateTimeline();
    renderRunbookTable();
    if (typeof schedulePush === 'function' && window.canWrite && window.canWrite()) {
      schedulePush();
    }
    recordStatusChange('pause', {
      reason: window.AppState.lastPauseReason,
      message: window.AppState.lastPauseReason ? 'Downtime paused: ' + window.AppState.lastPauseReason : 'Downtime paused'
    });
    updateViewerPanel();
  }
};

window.resumeDowntime = function() {
  if (window.AppState.downtimePaused) {
    var pauseDuration = new Date() - window.AppState.pauseStartTime;
    window.AppState.pausedDuration += pauseDuration;
    window.AppState.downtimePaused = false;
    window.AppState.pauseStartTime = null;

    document.getElementById('statusText').textContent = 'In Progress';
    document.getElementById('statusText').style.color = 'var(--sap-error)';

    renderDowntimeControls();

    var currentLine = document.getElementById('currentTimeLine');
    if (currentLine) currentLine.style.display = 'block';

    updateDuration();
    updateProgressIndicators();
    updateTimeline();
    renderRunbookTable();
    if (typeof schedulePush === 'function' && window.canWrite && window.canWrite()) {
      schedulePush();
    }
    recordStatusChange('resume', {
      message: 'Downtime resumed'
    });
    updateViewerPanel();
  }
};

window.stopDowntime = function() {
  if (confirm('Are you sure you want to stop the downtime tracking? All times will be reset.')) {
    window.AppState.downtimeStarted = false;
    window.AppState.downtimeStartTime = null;
    window.AppState.downtimePaused = false;
    window.AppState.pausedDuration = 0;
    window.AppState.pauseStartTime = null;
    window.AppState.lastPauseReason = '';
    window.AppState.lastResetAt = new Date();
    window.AppState.syncedTimelinePosition = 0;

    // Reset actual durations
    window.AppState.runbooks.forEach(function(r) {
      r.actualDuration = null;
      r.completed = false;
    });
    window.AppState.completionTimes = {};
    window.AppState.pendingCompletionUpdates = {};
    
    // Unlock customer name and transform cycle inputs
    var customerNameInput = document.getElementById('customerName');
    var transformCycleInput = document.getElementById('transformCycle');
    if (customerNameInput) customerNameInput.disabled = false;
    if (transformCycleInput) transformCycleInput.disabled = false;
    
    setupStartTimeInputs();
    
    document.getElementById('startTimeDisplay').textContent = '--:--:--';
    document.getElementById('endTimeDisplay').textContent = '--:--:--';
    document.getElementById('currentDurationDisplay').textContent = '00:00:00';
    var durationInputField = document.getElementById('currentDurationInput');
    if (durationInputField) durationInputField.value = '00:00:00';
    document.getElementById('statusText').textContent = 'Not Started';
    document.getElementById('statusText').style.color = 'var(--sap-warning)';
    
    renderDowntimeControls();

    var currentLine = document.getElementById('currentTimeLine');
    if (currentLine) currentLine.style.display = 'none';

    updateTimeline();
    renderRunbookTable();
    updateCompletionPercentage();
    if (typeof schedulePush === 'function' && window.canWrite && window.canWrite()) {
      schedulePush();
    }
    recordStatusChange('downtime-stop', { message: 'Downtime stopped and reset' });
    updateViewerPanel();
  }
};

window.updateProgressIndicators = function() {
  if (!window.AppState.downtimeStarted || !window.AppState.downtimeStartTime) return;

  var now = new Date();
  var startTime = resolveDowntimeStartTime();
  if (!startTime) return;
  var pausedOffset = getEffectivePausedDuration(now);
  var elapsedMs = now - startTime - pausedOffset;
  var elapsed = elapsedMs / 3600000;
  
  var pixelsPerHour = 60;
  var linePosition = Math.min(elapsed * pixelsPerHour, window.AppState.downtimeDuration * pixelsPerHour);
  
  // Store position for viewer sync
  window.AppState.syncedTimelinePosition = linePosition;
  
  var currentLine = document.getElementById('currentTimeLine');
  if (currentLine) {
    currentLine.style.left = linePosition + 'px';
    currentLine.style.display = 'block';
    
    var totalSeconds = Math.floor(elapsedMs / 1000);
    var hours = Math.floor(totalSeconds / 3600);
    var minutes = Math.floor((totalSeconds % 3600) / 60);
    var seconds = totalSeconds % 60;
    
    var timeStr = String(hours).padStart(2, '0') + ':' + String(minutes).padStart(2, '0') + ':' + String(seconds).padStart(2, '0');
    var label = document.getElementById('currentTimeLabel');
    if (label) label.textContent = timeStr;
  }
    
  if (elapsed >= window.AppState.downtimeDuration) {
    document.getElementById('statusText').textContent = 'Completed';
    document.getElementById('statusText').style.color = 'var(--sap-accent)';
  }
};

// Import/Export Functions
window.downloadExcel = function() {
  var data = window.AppState.runbooks.map(function(r) {
    return {
      Sequence: r.sequence,
      Strategy: r.strategy,
      Phase: r.phase,
      Runblock: r.runblock || '',
      Responsibility: r.responsibility || '',
      Predecessor: (r.predecessor === 0 ? '0' : (r.predecessor || '')).toString(),
      Status: r.status || 'not-started',
      Critical: r.critical ? 'Yes' : 'No',
      ScheduleTime: String(r.scheduleHours).padStart(2,'0') + ':' + String(r.scheduleMinutes).padStart(2,'0'),
      PlannedDuration: String(r.durationHours).padStart(2,'0') + ':' + String(r.durationMinutes).padStart(2,'0'),
      ActualDuration: r.actualDuration || '',
      Completed: r.completed ? 'Yes' : 'No'
    };
  });

  var headers = ['Sequence','Strategy','Phase','Runblock','Responsibility','Predecessor','Status','Critical','ScheduleTime','PlannedDuration','ActualDuration','Completed'];
  var csvContent = [
    headers.join(',')
  ].concat(data.map(function(row) {
    return headers.map(function(header) {
      return '"' + (row[header] || '') + '"';
    }).join(',');
  })).join('\n');
  
  var customerName = document.getElementById('customerName').value || 'customer';
  var safeCustomerName = customerName.replace(/[^a-zA-Z0-9]/g, '_');
  var dateStr = new Date().toISOString().slice(0,10);
  
  var blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  var url = URL.createObjectURL(blob);
  var a = document.createElement('a');
  a.href = url;
  a.download = safeCustomerName + '_downtime_runbook_' + dateStr + '.csv';
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
};

window.uploadExcel = function(event) {
  var file = event.target.files[0];
  if (!file) return;
  
  var reader = new FileReader();
  reader.onload = function(e) {
    try {
      var text = e.target.result;
      var lines = text.split('\n');
      var headers = lines[0].split(',').map(function(h) { return h.replace(/"/g, '').trim(); });
      var predecessorIndex = headers.indexOf('Predecessor');
      var plannedDurationIndex = headers.indexOf('PlannedDuration');
      var legacyDurationIndex = headers.indexOf('Duration');
      var scheduleIndex = headers.indexOf('ScheduleTime');
      var statusIndex = headers.indexOf('Status');
      var actualIndex = headers.indexOf('ActualDuration');
      var completedIndex = headers.indexOf('Completed');
      
      window.AppState.runbooks = [];
      
      for (var i = 1; i < lines.length; i++) {
        if (lines[i].trim()) {
          var matches = lines[i].match(/(".*?"|[^,]+)/g);
          var values = matches ? matches.map(function(v) { return v.replace(/"/g, '').trim(); }) : [];
          
          var scheduleSource = scheduleIndex !== -1 ? values[scheduleIndex] : null;
          var scheduleTime = scheduleSource || '00:00';
          var scheduleTimeParts = scheduleTime.split(':').map(Number);
          var scheduleHours = scheduleTimeParts[0] || 0;
          var scheduleMinutes = scheduleTimeParts[1] || 0;

          var planDurationRaw = '';
          if (plannedDurationIndex !== -1) {
            planDurationRaw = values[plannedDurationIndex] || '';
          }
          if (!planDurationRaw && legacyDurationIndex !== -1) {
            planDurationRaw = values[legacyDurationIndex] || '';
          }

          var parsedPlan = parseHHMM(planDurationRaw);
          if (!parsedPlan.ok) {
            if (/^\d{1,2}$/.test(planDurationRaw || '')) {
              var minutesOnly = parseInt(planDurationRaw, 10);
              if (!isNaN(minutesOnly)) {
                parsedPlan.h = Math.floor(minutesOnly / 60);
                parsedPlan.m = minutesOnly % 60;
                parsedPlan.ok = true;
              }
            }
          }
          if (!parsedPlan.ok) {
            var numericDuration = parseFloat(planDurationRaw);
            if (!isNaN(numericDuration) && isFinite(numericDuration)) {
              var totalMinutes = Math.max(0, Math.round(numericDuration * 60));
              parsedPlan.h = Math.floor(totalMinutes / 60);
              parsedPlan.m = totalMinutes % 60;
              parsedPlan.ok = true;
            }
          }
          if (!parsedPlan.ok) {
            parsedPlan.h = 1;
            parsedPlan.m = 0;
          }

          var durationHours = parsedPlan.h;
          var durationMinutes = parsedPlan.m;

          var status = statusIndex !== -1 ? values[statusIndex] : 'not-started';
          if (TASK_STATUSES.indexOf(status) === -1) {
            status = 'not-started';
          }
          
          var runbook = {
            id: Date.now() + Math.random() + i,
            sequence: parseInt(values[headers.indexOf('Sequence')]) || i,
            strategy: values[headers.indexOf('Strategy')] || STRATEGIES[0],
            phase: values[headers.indexOf('Phase')] || PHASES[0],
            runblock: values[headers.indexOf('Runblock')] || '',
            responsibility: values[headers.indexOf('Responsibility')] || '',
            predecessor: predecessorIndex !== -1 ? (values[predecessorIndex] || '') : '',
            status: status,
            critical: values[headers.indexOf('Critical')] === 'Yes',
            scheduleHours: scheduleHours,
            scheduleMinutes: scheduleMinutes,
            durationHours: durationHours,
            durationMinutes: durationMinutes,
            actualDuration: actualIndex !== -1 ? (values[actualIndex] || null) : null,
            completed: completedIndex !== -1 ? values[completedIndex] === 'Yes' : false,
            position: 0
          };
          
          window.AppState.runbooks.push(runbook);
        }
      }
      
      renderRunbookTable();
      updateTimeline();
      updateCompletionPercentage();
      alert('Configuration loaded successfully!');
      
    } catch (error) {
      alert('Error loading file. Please check the format.');
      console.error('Upload error:', error);
    }
  };
  reader.readAsText(file);
  
  event.target.value = '';
};

// PDF Report Generation
window.generatePDFReport = async function() {
  if (typeof window.jspdf === 'undefined') {
    alert('PDF library not loaded. Please refresh the page and try again.');
    return;
  }
  
  var jsPDF = window.jspdf.jsPDF;
  var pdf = new jsPDF('l', 'mm', 'a4');
  
  var customerName = document.getElementById('customerName').value || 'Unknown Customer';
  var transformCycle = document.getElementById('transformCycle').value || 'Unknown Phase';
  var currentDate = new Date().toLocaleString();
  
  pdf.setFontSize(20);
  pdf.text('Technical Downtime Report', 20, 20);
  
  pdf.setFontSize(12);
  pdf.text('Customer: ' + customerName, 20, 30);
  pdf.text('Transform Cycle: ' + transformCycle, 20, 37);
  pdf.text('Generated: ' + currentDate, 20, 44);
  
  pdf.setFontSize(14);
  pdf.text('Execution Status', 20, 55);
  
  pdf.setFontSize(10);
  var statusText = document.getElementById('statusText').textContent;
  var startTime = document.getElementById('startTimeDisplay').textContent;
  var endTime = document.getElementById('endTimeDisplay').textContent;
  var duration = document.getElementById('currentDurationDisplay').textContent;
  
  pdf.text('Status: ' + statusText, 20, 62);
  pdf.text('Start Time: ' + startTime, 20, 68);
  pdf.text('End Time: ' + endTime, 20, 74);
  pdf.text('Current Duration: ' + duration, 20, 80);
  
  // Capture timeline
  var timelineContainer = document.querySelector('.timeline-container');
  if (timelineContainer && typeof html2canvas !== 'undefined') {
    try {
      var canvas = await html2canvas(timelineContainer, {
        scale: 2,
        logging: false,
        useCORS: true
      });
      
      var imgData = canvas.toDataURL('image/png');
      pdf.text('Timeline View', 20, 92);
      var imgWidth = 250;
      var imgHeight = (canvas.height * imgWidth) / canvas.width;
      pdf.addImage(imgData, 'PNG', 20, 97, imgWidth, Math.min(imgHeight, 80));
    } catch (error) {
      console.error('Error capturing timeline:', error);
    }
  }
  
  // Add runbook details
  pdf.addPage();
  pdf.setFontSize(14);
  pdf.text('Runbook Details', 20, 20);
  
  pdf.setFontSize(9);
  var yPos = 30;
  var headers = ['Seq', 'Strategy', 'Phase', 'Runblock', 'Critical', 'Start', 'Plan', 'Actual', 'Complete'];
  var xPositions = [20, 30, 55, 80, 120, 140, 160, 180, 200];
  
  headers.forEach(function(header, i) {
    pdf.text(header, xPositions[i], yPos);
  });
  
  yPos += 7;
  window.AppState.runbooks.forEach(function(runbook) {
    if (yPos > 180) {
      pdf.addPage();
      yPos = 20;
      headers.forEach(function(header, i) {
        pdf.text(header, xPositions[i], yPos);
      });
      yPos += 7;
    }
    
    var rowData = [
      runbook.sequence.toString(),
      runbook.strategy.substring(0, 12),
      runbook.phase.substring(0, 10),
      runbook.runblock.substring(0, 25),
      runbook.critical ? 'Yes' : 'No',
      String(runbook.scheduleHours).padStart(2,'0') + ':' + String(runbook.scheduleMinutes).padStart(2,'0'),
      String(runbook.durationHours).padStart(2,'0') + ':' + String(runbook.durationMinutes).padStart(2,'0'),
      runbook.actualDuration || '--:--:--',
      runbook.completed ? 'Yes' : 'No'
    ];
    
    rowData.forEach(function(data, i) {
      pdf.text(data, xPositions[i], yPos);
    });
    
    yPos += 6;
  });
  
  // Summary
  var totalTasks = window.AppState.runbooks.length;
  var completedTasks = window.AppState.runbooks.filter(function(r) { return r.completed; }).length;
  var criticalTasks = window.AppState.runbooks.filter(function(r) { return r.critical; }).length;
  var completionRate = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;
  
  pdf.addPage();
  pdf.setFontSize(14);
  pdf.text('Summary Statistics', 20, 20);
  
  pdf.setFontSize(10);
  pdf.text('Total Tasks: ' + totalTasks, 20, 30);
  pdf.text('Completed Tasks: ' + completedTasks, 20, 36);
  pdf.text('Critical Path Items: ' + criticalTasks, 20, 42);
  pdf.text('Completion Rate: ' + completionRate + '%', 20, 48);
  
  var safeCustomerName = customerName.replace(/[^a-zA-Z0-9]/g, '_');
  var dateStr = new Date().toISOString().slice(0,10);
  pdf.save(safeCustomerName + '_downtime_report_' + dateStr + '.pdf');
};

// Dropdown focus management - prevent premature closing
document.addEventListener('mousedown', function(e) {
  if (e.target.tagName === 'SELECT' || e.target.closest('select')) {
    e.target.__dropdownFocus = true;
    setTimeout(function() {
      delete e.target.__dropdownFocus;
    }, 300);
  }
}, true);

document.addEventListener('blur', function(e) {
  if (e.target.tagName === 'SELECT' && e.target.__dropdownFocus) {
    e.preventDefault();
    e.stopPropagation();
    e.target.focus();
  }
}, true);

// Time parsing and formatting functions
function parseHHMM(str) {
  if (!str) return {h:0, m:0, ok:false};
  str = String(str).trim();
  var h = 0, m = 0, ok = false;
  if (/^\d{1,3}:\d{1,2}$/.test(str)) {
    var parts = str.split(':');
    h = parseInt(parts[0], 10) || 0;
    m = parseInt(parts[1], 10) || 0;
    ok = true;
  } else if (/^\d{3,}$/.test(str)) {
    var mm = str.slice(-2);
    var hh = str.slice(0, -2);
    h = parseInt(hh, 10) || 0;
    m = parseInt(mm, 10) || 0;
    ok = true;
  }
  if (m >= 60) { 
    h += Math.floor(m / 60); 
    m = m % 60; 
  }
  if (m < 0) m = 0;
  if (h < 0) h = 0;
  return {h: h, m: m, ok: ok};
}

function formatHHMM(h, m) {
  h = Math.max(0, parseInt(h || 0, 10));
  m = Math.max(0, parseInt(m || 0, 10)) % 60;
  return String(h).padStart(2, '0') + ':' + String(m).padStart(2, '0');
}

// Debounce helper
function debounce(fn, delay) { 
  var t; 
  return function() { 
    var ctx = this, args = arguments; 
    clearTimeout(t); 
    t = setTimeout(function() {
      fn.apply(ctx, args);
    }, delay); 
  }; 
}

// Enhancements
function attachTimeInputEnhancements(input, type, id) {
  if (!input) return;
  input.setAttribute('inputmode', 'numeric');
  input.setAttribute('title', 'Use HH:MM (e.g., 01:30). Arrow Up/Down Â±1 min, Shift+Arrow Â±5 min.');

  var validate = function() {
    var val = input.value.trim();
    var match = /^\d{1,3}:\d{1,2}$/.test(val) || /^\d{3,}$/.test(val);
    if (!match) { 
      input.classList.add('input-invalid'); 
    } else { 
      input.classList.remove('input-invalid'); 
    }
  };
  input.addEventListener('input', validate);
  input.addEventListener('blur', function() { 
    input.classList.remove('input-invalid'); 
  });

  input.addEventListener('keydown', function(e) {
    if (e.key !== 'ArrowUp' && e.key !== 'ArrowDown') return;
    e.preventDefault();
    var delta = (e.shiftKey ? 5 : 1) * (e.key === 'ArrowUp' ? 1 : -1);
    var t = parseHHMM(input.value);
    var total = t.h * 60 + t.m + delta;
    if (total < 0) total = 0;
    var nh = Math.floor(total / 60);
    var nm = total % 60;
    var nv = formatHHMM(nh, nm);
    input.value = nv;
    if (type === 'start') window.updateScheduleTime(id, nv);
    else window.updateDurationTime(id, nv);
  });
}

function updateSingleBlockPosition(id) {
  var rb = window.AppState.runbooks.find(function(r) { return r.id === id; });
  if (!rb) return;
  var pph = 60;
  var pos = rb.scheduleHours + rb.scheduleMinutes / 60;
  var x = pos * pph;

  var block = document.querySelector('.timeline-block[data-runbook-id="' + id + '"]');
  var diamond = document.querySelector('.quality-diamond[data-runbook-id="' + id + '"]');
  if (block) block.style.left = x + 'px';
  if (diamond) diamond.style.left = Math.max(0, x - 7) + 'px';
}

function updateSingleBlockWidth(id) {
  var rb = window.AppState.runbooks.find(function(r) { return r.id === id; });
  if (!rb) return;
  var pph = 60;
  var dur = rb.durationHours + rb.durationMinutes / 60;
  var w = Math.max(MIN_TIMELINE_BLOCK_WIDTH, dur * pph - 4);
  var block = document.querySelector('.timeline-block[data-runbook-id="' + id + '"]');
  if (block) block.style.width = w + 'px';
}

var scheduleConflicts = debounce(recomputeConflicts, 120);
var scheduleValidation = debounce(displayValidationWarnings, 150);

function clearConflictArtifacts() {
  document.querySelectorAll('.conflict-overlay').forEach(function(el) { el.remove(); });
  document.querySelectorAll('.timeline-block .conflict-indicator').forEach(function(el) { el.remove(); });
  document.querySelectorAll('.timeline-block .slack-badge').forEach(function(el) { el.remove(); });
  document.querySelectorAll('.timeline-block .quick-fix').forEach(function(el) { el.remove(); });
}

function recomputeConflicts() {
  clearConflictArtifacts();
  var pph = 60;
  var runbooks = window.AppState.runbooks
    .filter(function(r) { return r && r.runblock && r.runblock.trim().length > 0; })
    .sort(function(a, b) { return a.sequence - b.sequence; });

  // Slack badges
  for (var i = 0; i < runbooks.length; i++) {
    var a = runbooks[i];
    var aStart = a.scheduleHours + a.scheduleMinutes / 60;
    var aEnd = aStart + a.durationHours + a.durationMinutes / 60;
    var next = runbooks[i + 1];
    if (next) {
      var nStart = next.scheduleHours + next.scheduleMinutes / 60;
      var slack = Math.max(0, nStart - aEnd);
      var block = document.querySelector('.timeline-block[data-runbook-id="' + a.id + '"]');
      if (block && slack > 0) {
        var badge = document.createElement('span');
        badge.className = 'slack-badge';
        var min = Math.round(slack * 60);
        badge.textContent = 'Slack ' + (min >= 60 ? Math.floor(min / 60) + 'h ' + (min % 60) + 'm' : min + 'm');
        block.appendChild(badge);
      }
    }
  }

  // Conflicts & overlays
  for (var i = 0; i < runbooks.length; i++) {
    for (var j = i + 1; j < runbooks.length; j++) {
      var a = runbooks[i], b = runbooks[j];
      var aStart = a.scheduleHours + a.scheduleMinutes / 60;
      var aEnd = aStart + a.durationHours + a.durationMinutes / 60;
      var bStart = b.scheduleHours + b.scheduleMinutes / 60;
      var bEnd = bStart + b.durationHours + b.durationMinutes / 60;
      if (aEnd > bStart && bEnd > aStart) {
        var later = (bStart >= aStart) ? b : a;
        var block = document.querySelector('.timeline-block[data-runbook-id="' + later.id + '"]');
        if (block) {
          var badge = document.createElement('span');
          badge.className = 'conflict-indicator';
          badge.textContent = 'CLASH';
          block.appendChild(badge);

          var fix = document.createElement('button');
          fix.className = 'quick-fix';
          fix.textContent = '+15m â†’';
          fix.title = 'Shift next item by +15 minutes';
          fix.addEventListener('click', function(ev) {
            ev.stopPropagation();
            shiftFollowing(later.id, 15);
          });
          block.appendChild(fix);
        }
        var scroll = document.querySelector('.timeline-scroll');
        if (scroll) {
          var overlay = document.createElement('div');
          overlay.className = 'conflict-overlay';
          var left = Math.max(aStart, bStart) * pph;
          var right = Math.min(aEnd, bEnd) * pph;
          overlay.style.left = left + 'px';
          overlay.style.width = Math.max(2, right - left) + 'px';
          scroll.appendChild(overlay);
        }
      }
    }
  }
}

function shiftFollowing(id, minutes) {
  var runbooks = window.AppState.runbooks.slice().sort(function(a, b) { return a.sequence - b.sequence; });
  var idx = runbooks.findIndex(function(r) { return r.id === id; });
  var target = runbooks[idx + 1];
  if (!target) return;
  var total = target.scheduleHours * 60 + target.scheduleMinutes + minutes;
  if (total < 0) total = 0;
  target.scheduleHours = Math.floor(total / 60);
  target.scheduleMinutes = total % 60;
  window.updateScheduleTime(target.id, formatHHMM(target.scheduleHours, target.scheduleMinutes));
  updateSingleBlockPosition(target.id);
  scheduleConflicts();
}

// Override generateTimelineRows to add enhancements
var _origGenerateTimelineRows = generateTimelineRows;
generateTimelineRows = function() {
  // Don't regenerate if user is editing timeline inputs
  if (window.AppState.timelineInputLock) {
    return;
  }
  
  _origGenerateTimelineRows.apply(this, arguments);
  recomputeConflicts();
  
  var controls = document.getElementById('timelineControlsRows');
  if (controls) {
    var rows = controls.querySelectorAll('.timeline-control-row');
    var sorted = getFilteredRunbooks()
      .filter(function(r) { return r && r.runbook && r.runblock.trim().length > 0; })
      .sort(function(a, b) { return a.sequence - b.sequence; });
    rows.forEach(function(row, i) {
      var rb = sorted[i];
      if (!rb) return;
      var inputs = row.querySelectorAll('input[type="text"]');
      if (inputs[0]) attachTimeInputEnhancements(inputs[0], 'start', rb.id);
      if (inputs[1]) attachTimeInputEnhancements(inputs[1], 'plan', rb.id);
    });
  }
};

</script>

<!-- Firebase realtime sync -->
<script type="module">
// CRITICAL FIX: Initialize canWrite immediately to prevent errors
window.canWrite = function() {
  // Safe default: return true until Firebase sync is ready
  // This will be properly overridden once Firebase initializes
  return true;
};

import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, serverTimestamp, collection, addDoc, deleteDoc, query, orderBy, getDocs } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-auth.js";

const firebaseConfig = {
  apiKey: "AIzaSyAredpIvTx0c7uxn23HZoD3YkTgcG4cHbk",
  authDomain: "downtime-tracking-135f6.firebaseapp.com",
  projectId: "downtime-tracking-135f6",
  storageBucket: "downtime-tracking-135f6.firebaseapp.com",
  messagingSenderId: "422856401277",
  appId: "1:422856401277:web:7b10cb426abf816d74ec14",
  measurementId: "G-CJ2F30SYRY"
};

const HOST_TAKEOVER_GRACE_MS = window.__DT2_HOST_TAKEOVER_GRACE_MS || 60000;
const PRESENCE_ACTIVITY_WINDOW_MS = 45000;

function resolvePresenceLastActive(entry) {
  if (!entry) return 0;
  if (typeof entry.lastActiveMs === 'number') return entry.lastActiveMs;
  if (typeof entry.lastActive === 'number') return entry.lastActive;
  if (entry.lastActive && typeof entry.lastActive.toMillis === 'function') return entry.lastActive.toMillis();
  if (entry.lastActive && typeof entry.lastActive.seconds === 'number') return entry.lastActive.seconds * 1000;
  if (typeof entry.lastActiveMillis === 'number') return entry.lastActiveMillis;
  if (typeof entry.updatedAt === 'object' && entry.updatedAt && typeof entry.updatedAt.seconds === 'number') {
    return entry.updatedAt.seconds * 1000;
  }
  if (typeof entry.lastSeen === 'number') return entry.lastSeen;
  if (typeof entry.ts === 'number') return entry.ts;
  return 0;
}

function isPresenceEntryActive(entry, now) {
  if (!entry) return false;
  if (typeof entry.isActive === 'boolean') return entry.isActive;
  const lastActive = resolvePresenceLastActive(entry);
  if (!lastActive) return false;
  return (now || Date.now()) - lastActive < PRESENCE_ACTIVITY_WINDOW_MS;
}

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
const auth = getAuth(app);
let uid = null;
window.currentUid = null;
const sessionInstanceId = (() => {
  try {
    const existing = sessionStorage.getItem('dt2PresenceInstance');
    if (existing) return existing;
    const generated = (window.crypto && typeof window.crypto.randomUUID === 'function')
      ? window.crypto.randomUUID()
      : 'sess-' + Math.random().toString(36).slice(2, 10);
    sessionStorage.setItem('dt2PresenceInstance', generated);
    return generated;
  } catch (err) {
    return 'sess-' + Math.random().toString(36).slice(2, 10);
  }
})();
let presenceDocId = null;
let presenceRef = null;
window.getCurrentUid = function() {
  return uid;
};

window.firestore = {
  setDoc,
  updateDoc,
  onSnapshot,
  serverTimestamp,
  collection,
  addDoc,
  deleteDoc,
  query,
  orderBy,
  getDocs,
  doc,
  getDoc
};

// Template Management Functions
window.saveTemplateToFirebase = async function(template) {
  const templatesRef = collection(db, "templates");
  await addDoc(templatesRef, template);
};

window.loadTemplateFromFirebase = async function(templateId) {
  const templateRef = doc(db, "templates", templateId);
  const templateSnap = await getDoc(templateRef);
  if (templateSnap.exists()) {
    return templateSnap.data();
  }
  throw new Error('Template not found');
};

window.deleteTemplateFromFirebase = async function(templateId) {
  const templateRef = doc(db, "templates", templateId);
  await deleteDoc(templateRef);
};

window.loadTemplatesFromFirebase = async function() {
  const templatesRef = collection(db, "templates");
  const q = query(templatesRef, orderBy("createdAt", "desc"));
  const querySnapshot = await getDocs(q);
  
  const templates = [];
  querySnapshot.forEach((doc) => {
    templates.push({
      id: doc.id,
      ...doc.data()
    });
  });
  
  return templates;
};

// Get URL parameters
const url = new URL(window.location.href);
const readCustomerFromUrl = (search = url.searchParams) => search.get("customer") || "";
const readTransformFromUrl = (search = url.searchParams) => search.get("phase") || search.get("transformCycle") || "";
let customerParam = readCustomerFromUrl();
let phaseParam = readTransformFromUrl();
let sessionParam = url.searchParams.get("session") || "";
let viewerParam = url.searchParams.get("viewer");
let requestedViewerMode = viewerParam === "1";
let hostBlockReason = null;
let hostBlockAlerted = false;

const nameInput = document.getElementById("customerName");
const phaseInput = document.getElementById("transformCycle");
const operatorInput = document.getElementById("operatorName");

function readStoredOperatorName() {
  try {
    const storedProfile = JSON.parse(localStorage.getItem('operatorProfile') || 'null');
    if (storedProfile && storedProfile.name) {
      return storedProfile.name;
    }
  } catch (err) {
    console.warn('Failed to parse stored operator profile', err);
  }
  const legacy = localStorage.getItem('operatorName');
  return legacy || "";
}

function loadLastSessionContext() {
  try {
    const stored = JSON.parse(localStorage.getItem('lastSessionContext') || 'null');
    if (stored && typeof stored === 'object') {
      return {
        customer: stored.customer || "",
        transform: stored.transform || "",
        savedAt: stored.savedAt || Date.now()
      };
    }
  } catch (err) {
    console.warn('Failed to parse last session context', err);
  }
  return { customer: "", transform: "" };
}

const lastSessionContext = loadLastSessionContext();
let sessionHydratedCustomer = "";
let sessionHydratedTransform = "";

if (sessionParam) {
  const parts = sessionParam.split("__");
  const hydrate = (segment) => (segment || "").replace(/-/g, " ").trim();
  sessionHydratedCustomer = hydrate(parts[0]);
  sessionHydratedTransform = hydrate(parts[1]);
}

if (!customerParam && sessionHydratedCustomer) customerParam = sessionHydratedCustomer;
if (!phaseParam && sessionHydratedTransform) phaseParam = sessionHydratedTransform;
if (!customerParam && lastSessionContext.customer) customerParam = lastSessionContext.customer;
if (!phaseParam && lastSessionContext.transform) phaseParam = lastSessionContext.transform;

const storedOperatorName = readStoredOperatorName();
if (operatorInput && storedOperatorName) {
  operatorInput.value = storedOperatorName;
}

// Set initial values
if (customerParam && nameInput) nameInput.value = customerParam;
if (phaseParam && phaseInput) phaseInput.value = phaseParam;

// Generate safe key for Firebase
const toKey = s => (s||"default").toString().trim().toLowerCase().replace(/[^a-z0-9]+/g,"-").replace(/^-+|-+$/g,"") || "default";

function deriveSessionContext({ customerValue, transformValue, sessionKeyOverride }) {
  const normalizedCustomer = (customerValue || "").toString().trim() || "default";
  const normalizedTransform = (transformValue || "").toString().trim() || "default";
  const customerKey = toKey(normalizedCustomer);
  const phaseKey = toKey(normalizedTransform);
  return {
    customerValue: normalizedCustomer,
    transformValue: normalizedTransform,
    customerKey,
    phaseKey,
    sessionKey: sessionKeyOverride || `${customerKey}__${phaseKey}`
  };
}

let sessionContext = deriveSessionContext({
  customerValue: nameInput?.value || customerParam,
  transformValue: phaseInput?.value || phaseParam,
  sessionKeyOverride: sessionParam || null
});

customerParam = sessionContext.customerValue;
phaseParam = sessionContext.transformValue;

console.log("Session initialization:", {
  customerParam: customerParam,
  customerKey: sessionContext.customerKey,
  phaseParam: phaseParam,
  phaseKey: sessionContext.phaseKey,
  sessionKey: sessionContext.sessionKey,
  domain: window.location.hostname,
  fullUrl: window.location.href
});

function applySessionContextToUi(context) {
  if (!context) return;
  customerParam = context.customerValue;
  phaseParam = context.transformValue;

  if (nameInput) nameInput.value = context.customerValue;
  if (phaseInput) phaseInput.value = context.transformValue;

  try {
    url.searchParams.set("customer", context.customerValue);
    url.searchParams.set("transformCycle", context.transformValue);
    url.searchParams.set("phase", context.transformValue);
    url.searchParams.set("session", context.sessionKey);
    history.replaceState(null, "", url.toString());
  } catch (err) {
    console.warn("Failed to refresh URL on session switch", err);
  }

  const customerLabel = document.getElementById('rt-customer');
  if (customerLabel) customerLabel.textContent = context.customerValue;
  const transformLabel = document.getElementById('rt-transform');
  if (transformLabel) transformLabel.textContent = context.transformValue;

  addRecentCustomer(context.customerValue, context.transformValue);
  rememberSessionContext(context.customerValue, context.transformValue);
  renderHostStatus();
}

function createLocalRealtimeBridge(sessionKey) {
  const safeSessionKey = sessionKey || 'default__default';
  const stateKey = `dt2-local-state-${safeSessionKey}`;
  const presenceKey = `dt2-local-presence-${safeSessionKey}`;
  const hasStorage = (function() {
    try {
      const probeKey = '__dt2_rt_probe__';
      localStorage.setItem(probeKey, '1');
      localStorage.removeItem(probeKey);
      return true;
    } catch (err) {
      return false;
    }
  })();
  const supportsBroadcast = typeof BroadcastChannel !== 'undefined';

  function safeParse(raw, fallback) {
    if (!raw) return fallback;
    try {
      const parsed = JSON.parse(raw);
      return parsed === null ? fallback : parsed;
    } catch (err) {
      return fallback;
    }
  }

  let stateCache = hasStorage ? safeParse(localStorage.getItem(stateKey), null) : null;
  let presenceCache = hasStorage ? safeParse(localStorage.getItem(presenceKey), {}) : {};
  if (!presenceCache || typeof presenceCache !== 'object') presenceCache = {};

  const stateListeners = new Set();
  const presenceListeners = new Set();

  const stateChannel = supportsBroadcast ? new BroadcastChannel(`${stateKey}-channel`) : null;
  const presenceChannel = supportsBroadcast ? new BroadcastChannel(`${presenceKey}-channel`) : null;

  function persistState() {
    if (!hasStorage) return;
    try {
      localStorage.setItem(stateKey, JSON.stringify(stateCache));
    } catch (err) {
      console.warn('Local realtime state persist failed', err);
    }
  }

  function persistPresence() {
    if (!hasStorage) return;
    try {
      localStorage.setItem(presenceKey, JSON.stringify(presenceCache));
    } catch (err) {
      console.warn('Local realtime presence persist failed', err);
    }
  }

  function notifyStateListeners(payload) {
    stateListeners.forEach(function(listener) {
      try {
        listener(payload.state, payload);
      } catch (err) {
        console.error('Local realtime state listener error', err);
      }
    });
  }

  function currentPresenceEntries() {
    return Object.keys(presenceCache).map(function(id) {
      return { presenceDocId: id, ...presenceCache[id] };
    });
  }

  function notifyPresenceListeners() {
    const entries = currentPresenceEntries();
    presenceListeners.forEach(function(listener) {
      try {
        listener(entries);
      } catch (err) {
        console.error('Local realtime presence listener error', err);
      }
    });
  }

  function setStatePayload(payload, options) {
    if (!payload || typeof payload !== 'object') return;
    const opts = options || {};
    stateCache = payload;
    persistState();
    if (opts.broadcast && stateChannel) {
      try {
        stateChannel.postMessage(payload);
      } catch (err) {
        console.warn('Local realtime state broadcast failed', err);
      }
    }
    notifyStateListeners(payload);
  }

  function setPresenceMap(map, options) {
    const opts = options || {};
    presenceCache = map && typeof map === 'object' ? { ...map } : {};
    persistPresence();
    if (opts.broadcast && presenceChannel) {
      try {
        presenceChannel.postMessage({ type: 'presence', map: presenceCache });
      } catch (err) {
        console.warn('Local realtime presence broadcast failed', err);
      }
    }
    notifyPresenceListeners();
  }

  if (stateChannel) {
    stateChannel.addEventListener('message', function(event) {
      const payload = event && event.data;
      if (payload && payload.type === 'state' && payload.state) {
        setStatePayload(payload, { broadcast: false });
      }
    });
  }

  const storageStateHandler = function(event) {
    if (event.key === stateKey && event.newValue) {
      const payload = safeParse(event.newValue, null);
      if (payload && payload.state) {
        setStatePayload(payload, { broadcast: false });
      }
    }
  };

  const storagePresenceHandler = function(event) {
    if (event.key === presenceKey) {
      const map = safeParse(event.newValue, {});
      setPresenceMap(map, { broadcast: false });
    }
  };

  if (hasStorage) {
    window.addEventListener('storage', storageStateHandler);
    window.addEventListener('storage', storagePresenceHandler);
  }

  if (presenceChannel) {
    presenceChannel.addEventListener('message', function(event) {
      const payload = event && event.data;
      if (payload && payload.type === 'presence' && payload.map) {
        setPresenceMap(payload.map, { broadcast: false });
      }
    });
  }

  function emitState(state, reason, meta) {
    if (!state) return;
    const payload = {
      type: 'state',
      state,
      reason: reason || 'update',
      uid: (meta && meta.uid) || uid || null,
      ts: Date.now(),
      origin: (meta && meta.origin) || 'local'
    };
    setStatePayload(payload, { broadcast: true });
  }

  function ingestState(state, meta) {
    if (!state) return;
    const payload = {
      type: 'state',
      state,
      reason: (meta && meta.reason) || 'ingest',
      uid: (meta && meta.uid) || null,
      ts: Date.now(),
      origin: (meta && meta.origin) || 'remote'
    };
    const broadcast = !meta || meta.broadcast !== false;
    setStatePayload(payload, { broadcast });
  }

  function normalizePresenceEntry(entry) {
    if (!entry) return null;
    const id = entry.presenceDocId || entry.id || entry.uid || entry.instanceId;
    if (!id) return null;
    let lastActiveMs = Date.now();
    if (typeof entry.lastActive === 'number') {
      lastActiveMs = entry.lastActive;
    } else if (entry.lastActive && typeof entry.lastActive.toMillis === 'function') {
      lastActiveMs = entry.lastActive.toMillis();
    } else if (entry.lastActive && typeof entry.lastActive.seconds === 'number') {
      lastActiveMs = entry.lastActive.seconds * 1000;
    } else if (typeof entry.lastActiveMillis === 'number') {
      lastActiveMs = entry.lastActiveMillis;
    }
    return {
      id,
      payload: {
        uid: entry.uid || id,
        displayName: entry.displayName || entry.name || null,
        name: entry.name || entry.displayName || null,
        mode: entry.mode || 'viewer',
        lastActive: lastActiveMs,
        instanceId: entry.instanceId || sessionInstanceId
      }
    };
  }

  function emitPresenceEntry(entry) {
    const normalized = normalizePresenceEntry(entry);
    if (!normalized) return;
    const next = { ...presenceCache };
    next[normalized.id] = normalized.payload;
    setPresenceMap(next, { broadcast: true });
  }

  function ingestPresence(entries, meta) {
    const next = {};
    (entries || []).forEach(function(entry) {
      const normalized = normalizePresenceEntry(entry);
      if (normalized) {
        next[normalized.id] = normalized.payload;
      }
    });
    const broadcast = !meta || meta.broadcast !== false;
    setPresenceMap(next, { broadcast });
  }

  function removePresence(id) {
    if (!id) return;
    if (!presenceCache[id]) return;
    const next = { ...presenceCache };
    delete next[id];
    setPresenceMap(next, { broadcast: true });
  }

  function subscribeState(callback) {
    if (typeof callback !== 'function') return function() {};
    stateListeners.add(callback);
    if (stateCache && stateCache.state) {
      try {
        callback(stateCache.state, stateCache);
      } catch (err) {
        console.error('Local realtime state listener error', err);
      }
    }
    return function() {
      stateListeners.delete(callback);
    };
  }

  function subscribePresence(callback) {
    if (typeof callback !== 'function') return function() {};
    presenceListeners.add(callback);
    try {
      callback(currentPresenceEntries());
    } catch (err) {
      console.error('Local realtime presence listener error', err);
    }
    return function() {
      presenceListeners.delete(callback);
    };
  }

  function getCachedState() {
    return stateCache;
  }

  function getPresenceSnapshot() {
    return currentPresenceEntries();
  }

  function dispose() {
    stateListeners.clear();
    presenceListeners.clear();
    if (stateChannel) {
      try { stateChannel.close(); } catch (err) {}
    }
    if (presenceChannel) {
      try { presenceChannel.close(); } catch (err) {}
    }
    if (hasStorage) {
      window.removeEventListener('storage', storageStateHandler);
      window.removeEventListener('storage', storagePresenceHandler);
    }
  }

  return {
    emitState,
    ingestState,
    subscribeState,
    emitPresenceEntry,
    ingestPresence,
    subscribePresence,
    removePresence,
    getCachedState,
    getPresenceSnapshot,
    dispose
  };
}

let LocalRealtime = createLocalRealtimeBridge(sessionContext.sessionKey);
let localStateUnsubscribe = null;
let localPresenceUnsubscribe = null;

window.LocalRealtimeBridge = LocalRealtime;

bindLocalRealtimeBridges();

function getOperatorName() {
  const raw = (operatorInput && operatorInput.value) ? operatorInput.value.trim() : "";
  if (raw) return raw;
  const stored = readStoredOperatorName();
  return stored || "Host";
}

function persistOperatorProfile(name) {
  const normalized = (name || "").trim();
  try {
    localStorage.setItem('operatorProfile', JSON.stringify({
      name: normalized,
      updatedAt: Date.now()
    }));
  } catch (err) {
    console.warn('Failed to persist operator profile', err);
  }
  if (operatorInput && operatorInput.value !== normalized) {
    operatorInput.value = normalized;
  }
}

let presenceRoster = {};
let presenceRosterReady = false;
let controllerName = null;
let controlRequest = null;
let latestSessionData = {};
let lastControlRequestUid = null;
let connectionStatus = 'pending';
let connectionDetail = 'Awaiting Firebase handshake';
let lastSnapshotAt = Date.now();
let contextSwitchInFlight = false;
let pendingSessionContext = null;
let remoteController = null;
let remoteDowntimeActive = false;
let attemptedControllerClaim = false;

function updateConnectionIndicator(status, detail) {
  connectionStatus = status;
  connectionDetail = detail || connectionDetail;
  const indicator = document.getElementById('syncIndicator');
  if (!indicator) return;
  indicator.className = 'sync-indicator ' + status;
  if (connectionDetail) {
    indicator.setAttribute('title', connectionDetail);
  } else {
    indicator.removeAttribute('title');
  }
}

function showContextSwitchToast(detail) {
  const toast = document.getElementById('contextSwitchToast');
  if (!toast) return;
  const detailEl = document.getElementById('contextSwitchDetails');
  if (detailEl) {
    detailEl.textContent = detail || 'Preparing workspaceâ€¦';
  }
  toast.classList.add('show');
}

function hideContextSwitchToast() {
  const toast = document.getElementById('contextSwitchToast');
  if (!toast) return;
  toast.classList.remove('show');
}

function resolveControllerName() {
  if (remoteController) {
    if (latestSessionData && latestSessionData.controllerName) {
      return latestSessionData.controllerName;
    }
    const presence = presenceRoster[remoteController];
    if (presence) {
      return presence.displayName || presence.name || null;
    }
    if (remoteController && typeof remoteController === 'string') {
      return 'User ' + remoteController.slice(-6);
    }
    return null;
  }

  const rosterEntries = Object.values(presenceRoster || {});
  const fallbackHost = rosterEntries.find(function(entry) {
    return entry && (entry.mode || '').toLowerCase() !== 'viewer';
  });
  if (fallbackHost) {
    return fallbackHost.displayName || fallbackHost.name || 'Host';
  }

  return null;
}

function renderHostStatus() {
  const hostValue = document.getElementById('hostStatusValue');
  const hostMetaNodes = [
    document.getElementById('hostStatusMeta'),
    document.getElementById('rt-host-meta')
  ].filter(Boolean);
  const requestButtons = [
    document.getElementById('requestControlBtn')
  ].filter(Boolean);
  const pendingNodes = [
    document.getElementById('pendingRequestStatus')
  ].filter(Boolean);

  const activeName = controllerName || resolveControllerName();
  const canWrite = typeof window.canWrite === 'function' ? window.canWrite() : true;
  const isViewer = typeof window.canWrite === 'function' ? !window.canWrite() : false;
  if (hostValue) {
    hostValue.textContent = activeName || 'Unassigned';
  }

  hostMetaNodes.forEach(function(metaEl) {
    if (!metaEl) return;
    if (!remoteController) {
      metaEl.textContent = 'Awaiting first host';
    } else if (canWrite && remoteController === uid) {
      metaEl.textContent = 'You are controlling this session';
      if (typeof OnboardingTour !== 'undefined' && OnboardingTour) {
        OnboardingTour.maybeStart();
      }
    } else if (activeName) {
      metaEl.textContent = 'Controlled by ' + activeName;
    } else {
      metaEl.textContent = 'Host connection pending';
    }
  });

  const pendingForUser = controlRequest && controlRequest.uid === uid;
  const requestBlocked = controlRequest && controlRequest.uid !== uid;
  const offline = typeof navigator !== 'undefined' ? !navigator.onLine : false;

  requestButtons.forEach(function(button) {
    if (!button) return;
    if (!isViewer) {
      button.style.display = 'none';
      button.disabled = false;
      button.removeAttribute('title');
    } else {
      button.style.display = 'inline-flex';
      button.disabled = !!requestBlocked || offline;
      if (button.disabled) {
        button.setAttribute('title', offline ? 'Reconnect to request host control' : 'Host is reviewing another request');
      } else {
        button.setAttribute('title', 'Ask the host to hand over control');
      }
    }
  });

  let pendingMessage = '';
  let shouldAutoClearPending = false;
  if (isViewer) {
    if (pendingForUser) {
      pendingMessage = 'Request sent to host';
    } else if (!controlRequest && lastControlRequestUid === uid && remoteController === uid) {
      pendingMessage = 'Request approved! Switching rolesâ€¦';
      shouldAutoClearPending = true;
    }
  }

  pendingNodes.forEach(function(node) {
    if (!node) return;
    if (pendingMessage) {
      node.textContent = pendingMessage;
      node.classList.add('show');
    } else {
      node.classList.remove('show');
    }
  });

  if ((!isViewer || !pendingMessage) && shouldAutoClearPending) {
    shouldAutoClearPending = false;
  }

  if (shouldAutoClearPending && pendingMessage) {
    setTimeout(function() {
      pendingNodes.forEach(function(node) {
        if (node) {
          node.classList.remove('show');
        }
      });
      lastControlRequestUid = null;
    }, 4000);
  }

  if (!pendingMessage) {
    pendingNodes.forEach(function(node) {
      if (node) {
        node.classList.remove('show');
      }
    });
  }

  const overlayHost = document.getElementById('rt-host-name');
  if (overlayHost) {
    overlayHost.textContent = activeName || 'Unassigned';
  }

  renderDowntimeControls();
}

function formatControlRequestTimestamp(requestedAt) {
  if (!requestedAt) return 'Just now';
  try {
    const ts = typeof requestedAt.toDate === 'function' ? requestedAt.toDate() :
      (requestedAt.toMillis ? new Date(requestedAt.toMillis()) : new Date(requestedAt));
    if (ts && !isNaN(ts.getTime())) {
      return 'Requested at ' + ts.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
    }
  } catch (err) {
    console.warn('Failed to format control request timestamp', err);
  }
  return 'Just now';
}

function renderControlRequestBanner() {
  const banner = document.getElementById('controlRequestBanner');
  const nameEl = document.getElementById('controlRequestName');
  const timestampEl = document.getElementById('controlRequestTimestamp');
  const canWrite = typeof window.canWrite === 'function' ? window.canWrite() : false;

  if (!banner) return;

  if (canWrite && controlRequest && controlRequest.uid && controlRequest.uid !== uid) {
    const presence = presenceRoster[controlRequest.uid] || {};
    const displayName = controlRequest.name || presence.displayName || presence.name || ('User ' + controlRequest.uid.slice(-6));
    if (nameEl) nameEl.textContent = displayName;
    if (timestampEl) timestampEl.textContent = formatControlRequestTimestamp(controlRequest.requestedAt);
    banner.classList.add('show');
  } else {
    banner.classList.remove('show');
  }

  renderHostStatus();
}

updateConnectionIndicator('pending', 'Connecting to Firebaseâ€¦');

window.addEventListener('online', function() {
  if (connectionStatus === 'offline') {
    updateConnectionIndicator('pending', 'Re-establishing connectionâ€¦');
  }
  flushOfflineQueue();
  renderOfflineQueueState();
});

window.addEventListener('offline', function() {
  updateConnectionIndicator('offline', 'Browser is offline');
  renderOfflineQueueState();
});

setInterval(function() {
  if (connectionStatus === 'online' && Date.now() - lastSnapshotAt > 15000) {
    updateConnectionIndicator('degraded', 'Waiting for realtime updatesâ€¦');
  }
}, 5000);

// Ensure URL reflects the active customer/transform cycle for easy sharing
try {
  url.searchParams.set("customer", sessionContext.customerValue);
  url.searchParams.set("transformCycle", sessionContext.transformValue);
  url.searchParams.set("phase", sessionContext.transformValue);
  url.searchParams.set("session", sessionContext.sessionKey);
  history.replaceState(null, "", url.toString());
} catch (e) {
  console.warn("Failed to update URL parameters", e);
}

// Determine mode (host vs viewer)
let isFirstUser = false;
let viewerForced = false;

// Auto-detect first user
async function detectMode() {
  const sessionRef = doc(db, "sessions", sessionContext.sessionKey);

  console.log("Detecting mode for customer:", customerParam, "key:", sessionContext.customerKey, "transform:", phaseParam, "phaseKey:", sessionContext.phaseKey);
  console.log("Current domain:", window.location.hostname);
  console.log("Viewer param:", viewerParam);

  const hostAttempted = viewerParam !== "1";
  hostBlockReason = null;

  try {
    const sessionSnap = await getDoc(sessionRef);
    console.log("Session exists:", sessionSnap.exists());
    if (sessionSnap.exists()) {
      console.log("Session data:", sessionSnap.data());
    }

    const sessionData = sessionSnap.data() || {};
    const controllerUid = sessionData.controllerUid || null;
    const sessionHasHost = !!controllerUid;

    if (hostAttempted && !sessionHasHost) {
      isFirstUser = true;
      viewerForced = false;
      requestedViewerMode = false;
      url.searchParams.set("viewer", "0");
      window.AppState.isFirstUser = true;
      console.log("Mode: HOST (available)");
    } else {
      isFirstUser = false;
      viewerForced = true;
      requestedViewerMode = true;
      url.searchParams.set("viewer", "1");
      if (hostAttempted && sessionHasHost) {
        hostBlockReason = "âš ï¸ Only one host is allowed for this customer and cycle. You have been placed in viewer mode.";
        console.warn(hostBlockReason);
      } else {
        console.log("Mode: VIEWER (explicit or no host requested)");
      }
    }

    history.replaceState(null, "", url.toString());
    viewerParam = url.searchParams.get("viewer");
    requestedViewerMode = viewerParam === "1";
  } catch (e) {
    console.error("Error checking session:", e);
  }

  if (hostBlockReason && !hostBlockAlerted) {
    hostBlockAlerted = true;
    setTimeout(() => alert(hostBlockReason), 100);
  }
}

function createRealtimeOverlay() {
  if (document.getElementById('realtimeStatusPanel')) return;

  const statusPanel = document.createElement("div");
  statusPanel.id = 'realtimeStatusPanel';
  statusPanel.style.cssText = "position:fixed;right:10px;bottom:10px;background:#fff;border:1px solid #dcdcdc;border-radius:8px;padding:10px 12px;font:12px system-ui,-apple-system,sans-serif;box-shadow:0 2px 6px rgba(0,0,0,.08);z-index:100000;min-width:280px";
  statusPanel.innerHTML = `
    <div class="rt-panel-header">
      <div style="display:flex;flex-direction:column;gap:4px;flex:1;min-width:0;">
        <div style="font-size:12px;"><strong>Customer:</strong> <span id="rt-customer" style="font-family:monospace">${customerParam}</span></div>
        <div style="font-size:11px;color:#555;"><strong>Transform:</strong> <span id="rt-transform" style="font-family:monospace">${phaseParam}</span></div>
      </div>
      <div class="rt-panel-header-buttons">
        <button id="rt-collapse" class="rt-collapse-btn" type="button" aria-expanded="true" aria-controls="rt-body" title="Collapse panel">â–¾</button>
        <button id="rt-copy" style="padding:4px 8px;border:1px solid #ccc;border-radius:6px;cursor:pointer;background:#f9f9fb;">ðŸ“‹ Copy link</button>
      </div>
    </div>
    <div class="rt-body" id="rt-body">
      <div style="display:flex;gap:6px;align-items:center;justify-content:space-between;margin-top:8px;">
        <span id="rt-online" style="display:inline-block;padding:2px 8px;border:1px solid #dcdcdc;border-radius:999px;">0 online</span>
        <span id="rt-mode" style="font-weight:600;color:#444">mode: â€”</span>
      </div>
      <div style="margin-top:6px;font-size:12px;display:flex;gap:6px;align-items:center;justify-content:space-between;flex-wrap:wrap;">
        <span><strong>Host:</strong> <span id="rt-host-name">â€”</span></span>
        <button id="rt-open-diagnostics" style="padding:2px 8px;border:1px solid #ccc;border-radius:999px;background:#f3f5f8;font-size:11px;cursor:pointer;">Diagnostics</button>
      </div>
      <div id="rt-host-meta" style="margin-top:4px;font-size:11px;color:#666;">Awaiting first host</div>
      <div id="rt-engagement" style="margin-top:6px;padding:6px 8px;background:#f7f9fc;border:1px solid #e1e6f0;border-radius:6px;font-size:11px;line-height:1.4;">
        <div style="display:flex;justify-content:space-between;">
          <span>Peak viewers</span>
          <strong id="rt-peak-viewers">0</strong>
        </div>
        <div style="display:flex;justify-content:space-between;margin-top:4px;">
          <span>Avg session length</span>
          <strong id="rt-avg-session">0m</strong>
        </div>
        <div id="rt-current-viewers" style="margin-top:4px;color:#556;"></div>
      </div>
      <div id="rt-viewer-panel" style="display:none;margin-top:8px;">
        <div style="font-size:12px;margin-bottom:2px"><b>Status:</b> <span id="rt-status">â€”</span></div>
        <div style="font-size:12px;margin-bottom:4px"><b>Start:</b> <span id="rt-start">â€”</span></div>
        <div style="font-size:12px;margin-bottom:6px"><b>ETA:</b> <span id="rt-eta">â€”</span></div>
        <div style="position:relative;height:10px;border:1px solid #dcdcdc;border-radius:999px;overflow:hidden;background:#f2f3f6;">
          <div id="rt-bar" style="position:absolute;left:0;top:0;bottom:0;width:0%;background:linear-gradient(90deg,#4CAF50,#2196F3)"></div>
        </div>
        <div id="rt-bar-label" style="font-size:11px;margin-top:4px;text-align:right">0%</div>
        <div id="rt-pause-reason-row" style="font-size:12px;margin-top:6px;display:none;"><b>Pause reason:</b> <span id="rt-pause-reason">â€”</span></div>
        <div id="rt-last-reset-row" style="font-size:11px;margin-top:6px;color:#666;">Last reset: <span id="rt-last-reset">â€”</span></div>
        <div id="rt-focus-row" style="font-size:11px;margin-top:4px;color:#666;display:none;">Focus mode since <span id="rt-focus-time">â€”</span></div>
        <div id="rt-timeline-preview" style="margin-top:8px;display:none;">
          <div style="font-size:12px;font-weight:600;margin-bottom:4px;">Upcoming tasks</div>
          <ul id="rt-timeline-list" style="list-style:none;padding:0;margin:0;font-size:11px;max-height:120px;overflow-y:auto;"></ul>
        </div>
      </div>
    </div>`;
  document.body.appendChild(statusPanel);

  document.getElementById("rt-copy").onclick = async () => {
    const shareUrl = new URL(window.location.href);
    shareUrl.searchParams.set("viewer", "1");
    shareUrl.searchParams.set("customer", sessionContext.customerValue);
    shareUrl.searchParams.set("transformCycle", sessionContext.transformValue);
    shareUrl.searchParams.set("phase", sessionContext.transformValue);
    shareUrl.searchParams.set("session", sessionContext.sessionKey);
    await navigator.clipboard.writeText(shareUrl.toString());
    const btn = document.getElementById("rt-copy");
    const prev = btn.textContent;
    btn.textContent = "âœ“ Copied";
    setTimeout(() => btn.textContent = prev, 1500);
  };

  const collapseBtn = document.getElementById('rt-collapse');
  if (collapseBtn && !collapseBtn.__bound) {
    collapseBtn.__bound = true;
    let collapsed = false;
    const applyCollapsedState = () => {
      statusPanel.classList.toggle('collapsed', collapsed);
      collapseBtn.setAttribute('aria-expanded', (!collapsed).toString());
      collapseBtn.textContent = collapsed ? 'â–¸' : 'â–¾';
      collapseBtn.title = collapsed ? 'Expand panel' : 'Collapse panel';
      collapseBtn.setAttribute('aria-label', collapsed ? 'Expand real-time status panel' : 'Collapse real-time status panel');
      statusPanel.style.minWidth = collapsed ? '160px' : '280px';
    };
    collapseBtn.addEventListener('click', function() {
      collapsed = !collapsed;
      applyCollapsedState();
    });
    collapseBtn.addEventListener('keydown', function(evt) {
      if (evt.key === 'Enter' || evt.key === ' ') {
        evt.preventDefault();
        collapseBtn.click();
      }
    });
    applyCollapsedState();
  }

  const diagnosticsBtn = document.getElementById('rt-open-diagnostics');
  if (diagnosticsBtn && !diagnosticsBtn.__bound) {
    diagnosticsBtn.__bound = true;
    diagnosticsBtn.addEventListener('click', function() {
      toggleDiagnosticsDrawer();
    });
  }

  const rtRequestBtn = document.getElementById('rt-request-control');
  if (rtRequestBtn && !rtRequestBtn.__bound) {
    rtRequestBtn.__bound = true;
    rtRequestBtn.addEventListener('click', function(e) {
      e.preventDefault();
      requestHostControl();
    });
  }

  const resetBtn = document.createElement("div");
  resetBtn.id = 'realtimeResetWrapper';
  resetBtn.style.cssText = "position:fixed;left:10px;bottom:10px;z-index:100001";
  resetBtn.innerHTML = `<button id="rt-reset" style="padding:10px 14px;border:none;border-radius:8px;cursor:pointer;background:#d32f2f;color:#fff;font-weight:600;box-shadow:0 2px 6px rgba(0,0,0,.15)">ðŸ”„ Reset</button>`;
  document.body.appendChild(resetBtn);

  if (typeof updateViewerPanel === 'function') {
    setTimeout(() => updateViewerPanel(), 0);
  }

  if (typeof renderHostStatus === 'function') {
    setTimeout(() => renderHostStatus(), 0);
  }
}

createRealtimeOverlay();

function initializeRealtime() {
  if (realtimeInitPromise) {
    return realtimeInitPromise;
  }

  realtimeInitPromise = (async function() {
    try {
      await detectMode();
    } catch (err) {
      console.error('Failed to detect mode', err);
    }

    if (hostBlockReason && !hostBlockAlerted) {
      hostBlockAlerted = true;
      setTimeout(() => alert(hostBlockReason), 100);
    }

    let credential = null;
    try {
      credential = await signInAnonymously(auth);
    } catch (err) {
      console.error('Anonymous sign-in failed', err);
      updateConnectionIndicator('offline', 'Authentication failed');
      throw err;
    }

    uid = (credential && credential.user && credential.user.uid) || (auth.currentUser && auth.currentUser.uid) || uid;

    if (!uid) {
      uid = await new Promise((resolve, reject) => {
        const unsubscribe = onAuthStateChanged(auth, (user) => {
          if (user) {
            unsubscribe();
            resolve(user.uid);
          }
        }, reject);
        setTimeout(() => {
          unsubscribe();
          reject(new Error('Authentication timeout'));
        }, 15000);
      });
    }

    window.currentUid = uid;
    presenceDocId = `${uid}-${sessionInstanceId}`;
    presenceRef = doc(db, "sessions", sessionContext.sessionKey, "presence", presenceDocId);
    sessionRef = doc(db, "sessions", sessionContext.sessionKey);

    try {
      await bindPresenceListeners();
    } catch (err) {
      console.warn('Presence listeners failed to bind', err);
    }

    subscribeToSession();
  })();

  realtimeInitPromise = realtimeInitPromise.catch(function(err) {
    console.error('Realtime initialization error', err);
    realtimeInitPromise = null;
    throw err;
  });

  return realtimeInitPromise;
}

// Presence tracking

async function updatePresence() {
  const currentUrl = new URL(window.location.href);
  const forcedViewer = viewerForced || currentUrl.searchParams.get('viewer') === '1';
  const canWriteNow = typeof window.canWrite === 'function' ? window.canWrite() : !forcedViewer;
  const presenceId = presenceDocId || uid || sessionInstanceId;
  const presencePayload = {
    id: presenceId,
    uid: uid || presenceId,
    displayName: getOperatorName(),
    name: getOperatorName(),
    mode: canWriteNow ? 'host' : 'viewer',
    instanceId: sessionInstanceId,
    lastActive: Date.now()
  };

  try {
    if (LocalRealtime && typeof LocalRealtime.emitPresenceEntry === 'function') {
      LocalRealtime.emitPresenceEntry(presencePayload);
    }
  } catch (err) {
    console.warn('Local realtime presence emit failed', err);
  }

  if (!presenceRef) return;
  try {
    await window.firestore.setDoc(presenceRef, {
      displayName: presencePayload.displayName,
      name: presencePayload.name,
      customer: sessionContext.customerValue,
      transform: sessionContext.transformValue,
      uid,
      instanceId: sessionInstanceId,
      lastActive: window.firestore.serverTimestamp(),
      mode: presencePayload.mode
    }, { merge: true });
  } catch(e) {
    console.error("Presence update failed:", e);
  }
}

let presenceIntervalId = null;
let presenceUnsubscribe = null;

const ViewerEngagement = {
  active: {},
  history: [],
  peak: 0,
  totalDurationMs: 0,
  sessionsCompleted: 0
};

function formatDurationMinutes(ms) {
  const minutes = Math.max(0, Math.round(ms / 60000));
  if (minutes < 1) {
    return '<1m';
  }
  return `${minutes}m`;
}

function renderViewerMetrics() {
  const peakEl = document.getElementById('rt-peak-viewers');
  if (peakEl) {
    peakEl.textContent = ViewerEngagement.peak.toString();
  }

  const avgEl = document.getElementById('rt-avg-session');
  if (avgEl) {
    if (ViewerEngagement.sessionsCompleted === 0) {
      const activeIds = Object.keys(ViewerEngagement.active);
      if (activeIds.length) {
        const now = Date.now();
        const runningAverage = activeIds.reduce(function(total, id) {
          const active = ViewerEngagement.active[id];
          return total + Math.max(0, now - (active.startedAt || now));
        }, 0) / activeIds.length;
        avgEl.textContent = formatDurationMinutes(runningAverage);
      } else {
        avgEl.textContent = '0m';
      }
    } else {
      const avg = ViewerEngagement.totalDurationMs / ViewerEngagement.sessionsCompleted;
      avgEl.textContent = formatDurationMinutes(avg);
    }
  }

  const currentEl = document.getElementById('rt-current-viewers');
  if (currentEl) {
    const ids = Object.keys(ViewerEngagement.active);
    if (!ids.length) {
      currentEl.textContent = 'No active viewers';
    } else {
      const now = Date.now();
      currentEl.innerHTML = ids.map(function(id) {
        const session = ViewerEngagement.active[id];
        const duration = now - (session.startedAt || now);
        const label = session.displayName || session.uid || 'Viewer';
        return `<div>${label} Â· ${formatDurationMinutes(duration)}</div>`;
      }).join('');
    }
  }
}

function trackViewerEngagement(viewerEntries, now) {
  const activeIds = new Set();

  viewerEntries.forEach(function(entry) {
    const id = entry.uid || entry.presenceDocId || entry.id;
    if (!id) return;
    activeIds.add(id);
    if (!ViewerEngagement.active[id]) {
      ViewerEngagement.active[id] = {
        startedAt: now,
        lastSeen: now,
        displayName: entry.displayName || entry.name || 'Viewer',
        uid: id
      };
    } else {
      ViewerEngagement.active[id].lastSeen = now;
      ViewerEngagement.active[id].displayName = entry.displayName || entry.name || ViewerEngagement.active[id].displayName;
    }
  });

  Object.keys(ViewerEngagement.active).forEach(function(id) {
    if (!activeIds.has(id)) {
      const session = ViewerEngagement.active[id];
      const duration = Math.max(0, (session.lastSeen || now) - (session.startedAt || now));
      if (duration) {
        ViewerEngagement.history.push({ id, duration, name: session.displayName });
        ViewerEngagement.totalDurationMs += duration;
        ViewerEngagement.sessionsCompleted += 1;
      }
      delete ViewerEngagement.active[id];
    }
  });

  ViewerEngagement.peak = Math.max(ViewerEngagement.peak, activeIds.size);
  renderViewerMetrics();
}

function handlePresenceEntries(entries) {
  const now = Date.now();
  let online = 0;
  let viewerCount = 0;
  let hostCount = 0;
  const roster = {};
  const viewerEntries = [];

  (entries || []).forEach(function(entry) {
    if (!entry) return;
    const presenceEntry = { ...entry };
    const rosterEntry = {
      ...presenceEntry,
      displayName: presenceEntry.displayName || presenceEntry.name || null,
      name: presenceEntry.name || presenceEntry.displayName || null,
      mode: presenceEntry.mode || 'viewer'
    };
    if (presenceEntry.presenceDocId) {
      roster[presenceEntry.presenceDocId] = rosterEntry;
    }
    if (presenceEntry.uid) {
      roster[presenceEntry.uid] = rosterEntry;
    }

    const timestamp = resolvePresenceLastActive(presenceEntry);
    const isActive = timestamp ? (now - timestamp < PRESENCE_ACTIVITY_WINDOW_MS) : true;
    if (isActive) {
      online++;
      if ((rosterEntry.mode || '').toLowerCase() === 'viewer') {
        viewerCount++;
        viewerEntries.push({ ...rosterEntry, lastActive: timestamp });
      } else {
        hostCount++;
      }
    }

    rosterEntry.lastActiveMs = timestamp || 0;
    rosterEntry.isActive = isActive;
    rosterEntry.lastSeen = timestamp || 0;
  });

  presenceRoster = roster;
  presenceRosterReady = true;
  controllerName = resolveControllerName();
  trackViewerEngagement(viewerEntries, now);

  const el = document.getElementById('rt-online');
  if (el) {
    el.textContent = `${viewerCount} viewer${viewerCount === 1 ? '' : 's'} online`;
    el.setAttribute('title', `${online} active participant${online === 1 ? '' : 's'} Â· ${hostCount} host${hostCount === 1 ? '' : 's'} on deck`);
  }

  const headerViewer = document.getElementById('viewerCountHeader');
  if (headerViewer) {
    headerViewer.textContent = viewerCount === 1 ? '1 viewer' : `${viewerCount} viewers`;
  }

  const headerMeta = document.getElementById('viewerCountMeta');
  if (headerMeta) {
    headerMeta.textContent = viewerCount ? 'Viewing live progress' : 'No active viewers';
  }

  renderControlRequestBanner();
  renderDiagnosticsPanel();
}

async function bindPresenceListeners() {
  if (presenceIntervalId) clearInterval(presenceIntervalId);
  await updatePresence();
  presenceIntervalId = setInterval(updatePresence, 20000);

  if (presenceUnsubscribe) presenceUnsubscribe();
  const presenceCollectionRef = collection(db, "sessions", sessionContext.sessionKey, "presence");
  presenceUnsubscribe = window.firestore.onSnapshot(presenceCollectionRef, (snap) => {
    const entries = [];
    snap.forEach(function(docSnap) {
      const data = docSnap.data() || {};
      entries.push({ ...data, presenceDocId: docSnap.id });
    });
    try {
      if (LocalRealtime && typeof LocalRealtime.ingestPresence === 'function') {
        LocalRealtime.ingestPresence(entries, { origin: 'remote' });
      }
    } catch (err) {
      console.warn('Local realtime presence ingest failed', err);
    }
    handlePresenceEntries(entries);
  }, (error) => {
    console.warn('Presence listener error', error);
    updateConnectionIndicator('degraded', 'Presence updates delayed');
  });
}

await bindPresenceListeners();

function bindLocalRealtimeBridges() {
  if (!LocalRealtime) return;

  if (localStateUnsubscribe) localStateUnsubscribe();
  localStateUnsubscribe = LocalRealtime.subscribeState(function(state, meta) {
    const currentUid = uid;
    if (meta && meta.uid && currentUid && meta.uid === currentUid && typeof window.canWrite === 'function' && window.canWrite()) {
      return;
    }
    try {
      applyRemoteState(state);
      renderControlRequestBanner();
      renderHostStatus();
      if (typeof updateViewerPanel === 'function') updateViewerPanel();
      if (typeof updateTimelinePreview === 'function') updateTimelinePreview();
      if (typeof renderRunbookTable === 'function') renderRunbookTable();
      if (typeof updateTimeline === 'function') updateTimeline();
    } catch (err) {
      console.error('Failed to apply local realtime state', err);
    }
  });

  if (localPresenceUnsubscribe) localPresenceUnsubscribe();
  localPresenceUnsubscribe = LocalRealtime.subscribePresence(function(entries) {
    handlePresenceEntries(entries);
  });
}

// Session management
let sessionRef = doc(db, "sessions", sessionContext.sessionKey);
let sessionUnsubscribe = null;
remoteController = null;
remoteDowntimeActive = false;
attemptedControllerClaim = false;
let lastSentState = null;
let writing = false;

async function attemptControllerClaim(reason) {
  if (attemptedControllerClaim) return false;

  let forcedTakeover = false;
  let clearedViewerLock = false;
  if (remoteController && remoteController !== uid) {
    const presence = presenceRoster ? presenceRoster[remoteController] : null;
    const now = Date.now();
    let stale = false;
    let offlineDuration = 0;

    if (presence) {
      const lastActive = resolvePresenceLastActive(presence);
      const active = isPresenceEntryActive(presence, now);
      offlineDuration = lastActive ? now - lastActive : Number.POSITIVE_INFINITY;
      stale = !active && offlineDuration >= HOST_TAKEOVER_GRACE_MS;
    } else if (presenceRosterReady) {
      stale = true;
      offlineDuration = Number.POSITIVE_INFINITY;
    }

    if (!stale) {
      if (viewerForced) {
        console.warn('Viewer mode enforced: active host still connected');
      }
      return false;
    }

    forcedTakeover = true;
    console.warn('Forcing host takeover from offline controller', remoteController, 'inactive for', offlineDuration, 'ms');
  } else if (viewerForced) {
    clearedViewerLock = true;
  }

  if (viewerForced) {
    viewerForced = false;
  }
  if (clearedViewerLock) {
    console.log('Viewer lock cleared after host verification');
  }

  attemptedControllerClaim = true;
  try {
    await window.firestore.setDoc(sessionRef, {
      controllerUid: uid,
      controllerName: getOperatorName(),
      controllerSetAt: window.firestore.serverTimestamp()
    }, { merge: true });
    console.log('âœ“ Became controller:', uid, reason || 'manual');
    if (forcedTakeover) {
      if (typeof window.displayHostAuthMessage === 'function') {
        window.displayHostAuthMessage('Host control reclaimed from an inactive host.', 'success');
      }
      if (typeof window.showToast === 'function') {
        window.showToast('Host control reassigned. Previous host inactive.');
      }
    }
    return true;
  } catch (e) {
    attemptedControllerClaim = false;
    console.error('Failed to set controller:', e);
    return false;
  }
}

window.__DT2_attemptControllerClaim = attemptControllerClaim;

attemptControllerClaim('module-init');

// Check if can write - PROPERLY OVERRIDE THE EARLY INIT
window.canWrite = function() {
  // If viewer mode is forced via URL parameter, always return false
  const currentUrl = new URL(window.location.href);
  if (viewerForced || currentUrl.searchParams.get("viewer") === "1") return false;

  // If no remote controller set, we can write (we are/can be the host)
  if (!remoteController) return true;

  // We can only write if we are the registered controller
  return remoteController === uid;
};

if (typeof updateViewerPanel === 'function') {
  updateViewerPanel();
}

window.getViewerState = function() {
  const currentUrl = new URL(window.location.href);
  return {
    viewerParam,
    viewerForced,
    urlViewer: currentUrl.searchParams.get('viewer'),
    canWrite: typeof window.canWrite === 'function' ? window.canWrite() : null
  };
};

// Serialize state
function serialize() {
  const state = window.AppState;
  return {
    runbooks: (state.runbooks || []).map(r => ({...r})),
    downtimeStarted: !!state.downtimeStarted,
    downtimeStartTime: state.downtimeStartTime ? new Date(state.downtimeStartTime).toISOString() : null,
    downtimeDuration: state.downtimeDuration || 24,
    downtimePaused: !!state.downtimePaused,
    pausedDuration: state.pausedDuration || 0,
    pauseStartTime: state.pauseStartTime ? new Date(state.pauseStartTime).toISOString() : null,
    completionTimes: state.completionTimes || {},
    customerName: nameInput?.value || "",
    transformCycle: phaseInput?.value || "",
    syncedTimelinePosition: state.syncedTimelinePosition || 0,
    fullscreenMode: state.fullscreenMode || false,
    fullscreenSince: state.fullscreenSince ? new Date(state.fullscreenSince).toISOString() : null,
    messagesOn: !!state.messagesOn,
    darkMode: !!state.darkMode,
    lastPauseReason: state.lastPauseReason || '',
    lastResetAt: state.lastResetAt ? new Date(state.lastResetAt).toISOString() : null,
    lastStatusChange: state.lastStatusChange || null
  };
}

// Apply remote state
function applyRemoteState(remoteState) {
  if (!remoteState) return;
  
  const state = window.AppState;
  
  // Update runbooks - ensure they have status field
  state.runbooks = Array.isArray(remoteState.runbooks) ? remoteState.runbooks.map(function(r) {
    return {
      ...r,
      status: r.status || 'not-started'
    };
  }) : [];
  state.downtimeStarted = !!remoteState.downtimeStarted;
  state.downtimeDuration = remoteState.downtimeDuration || 24;
  state.downtimePaused = !!remoteState.downtimePaused;
  state.pausedDuration = remoteState.pausedDuration || 0;
  state.pauseStartTime = remoteState.pauseStartTime ? new Date(remoteState.pauseStartTime) : null;
  state.downtimeStartTime = remoteState.downtimeStartTime ? new Date(remoteState.downtimeStartTime) : null;
  state.completionTimes = remoteState.completionTimes || {};

  var pendingChanged = reconcilePendingCompletionUpdates();
  state.syncedTimelinePosition = remoteState.syncedTimelinePosition || 0;
  state.messagesOn = !!remoteState.messagesOn;
  state.lastPauseReason = remoteState.lastPauseReason || '';
  state.lastResetAt = remoteState.lastResetAt ? new Date(remoteState.lastResetAt) : null;

  // Sync dark mode across clients
  if (remoteState.darkMode !== undefined) {
    state.darkMode = !!remoteState.darkMode;
    document.body.classList.toggle('dark-mode', state.darkMode);
    updateDarkModeButton(state.darkMode);
    try {
      localStorage.setItem('darkMode', state.darkMode);
    } catch (err) {
      console.warn('Unable to persist dark mode preference', err);
    }
  }

  applyMessageToggleState();

  if (remoteState.fullscreenMode !== undefined) {
    const remoteFocusSince = remoteState.fullscreenSince ? new Date(remoteState.fullscreenSince) : null;
    applyFocusState(!!remoteState.fullscreenMode, {
      attemptFullscreen: false,
      since: remoteFocusSince,
      forceRefresh: !window.canWrite() && !!remoteState.fullscreenMode
    });
  }

  // Only update UI fields if not currently being edited and the incoming state matches the active session
  if (!state.inputLock) {
    const remoteCustomer = remoteState.customerName;
    const remoteTransform = remoteState.transformCycle;
    const remoteMatchesContext = (
      (!remoteCustomer || toKey(remoteCustomer) === sessionContext.customerKey) &&
      (!remoteTransform || toKey(remoteTransform) === sessionContext.phaseKey)
    );

    if (remoteMatchesContext) {
      if (nameInput && remoteCustomer) nameInput.value = remoteCustomer;
      if (phaseInput && remoteTransform) phaseInput.value = remoteTransform;
    }
  }

  // Lock/unlock customer name and transform cycle based on downtime status
  var customerNameInput = document.getElementById('customerName');
  var transformCycleInput = document.getElementById('transformCycle');
  if (customerNameInput) {
    customerNameInput.disabled = state.downtimeStarted;
  }
  if (transformCycleInput) {
    transformCycleInput.disabled = state.downtimeStarted;
  }
  
  const durationInput = document.getElementById('downtimeDuration');
  if (durationInput) durationInput.value = state.downtimeDuration;
  
  // Update displays for running downtime
  if (state.downtimeStarted && state.downtimeStartTime) {
    const startTimeDisplay = document.getElementById('startTimeDisplay');
    const startTimeInput = document.getElementById('startTimeInput');
    const currentDurationDisplay = document.getElementById('currentDurationDisplay');
    const currentDurationInput = document.getElementById('currentDurationInput');
    
    if (startTimeDisplay && startTimeInput) {
      startTimeDisplay.style.display = 'block';
      startTimeInput.style.display = 'none';
      startTimeDisplay.textContent = new Date(state.downtimeStartTime).toLocaleTimeString('en-US', 
        { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
    }
    
    if (currentDurationDisplay && currentDurationInput) {
      currentDurationDisplay.style.display = 'block';
      currentDurationInput.style.display = 'none';
    }
    
    // Update status
    const statusText = document.getElementById('statusText');
    if (statusText) {
      if (state.downtimePaused) {
        statusText.textContent = 'Paused';
        statusText.style.color = 'var(--sap-warning)';
      } else {
        statusText.textContent = 'In Progress';
        statusText.style.color = 'var(--sap-error)';
      }
    }
    
    // Show current time line
    const currentLine = document.getElementById('currentTimeLine');
    if (currentLine) {
      currentLine.style.display = state.downtimeStarted ? 'block' : 'none';
    }
  }

  renderDowntimeControls();
  
  // Update fullscreen customer info
  if (state.fullscreenMode) {
    window.updateFullscreenCustomerInfo();
  }
  
  // Update tables and timeline
  if (typeof window.renderRunbookTable === 'function') window.renderRunbookTable(pendingChanged);
  if (typeof window.updateTimeline === 'function') window.updateTimeline();
  if (typeof window.calculateEndTime === 'function') window.calculateEndTime();
  if (typeof window.updateCompletionPercentage === 'function') window.updateCompletionPercentage();
  if (typeof updateFullscreenKpis === 'function') updateFullscreenKpis();

  // Force update duration display for viewers
  if (!window.canWrite() && state.downtimeStarted) {
    const statusText = document.getElementById('statusText');
    if (statusText) {
      statusText.textContent = state.downtimePaused ? 'Paused' : 'In Progress';
      statusText.style.color = state.downtimePaused ? 'var(--sap-warning)' : 'var(--sap-error)';
    }

    // Ensure progress panel is visible
    const progressPanel = document.getElementById('progressPanel');
    if (progressPanel) {
      progressPanel.style.display = 'block';
    }

    // Force update of current duration
    if (typeof window.updateDuration === 'function') {
      window.updateDuration();
    }
  }

  // Update viewer panel
  updateViewerPanel();

  if (remoteState.lastStatusChange) {
    const remoteChange = {
      type: remoteState.lastStatusChange.type || 'update',
      message: remoteState.lastStatusChange.message || 'Status updated',
      reason: remoteState.lastStatusChange.reason || '',
      at: remoteState.lastStatusChange.at || null
    };
    state.lastStatusChange = remoteChange;
    if (!state.lastStatusSeenAt && remoteChange.at) {
      state.lastStatusSeenAt = remoteChange.at;
    } else if (remoteChange.at && state.lastStatusSeenAt !== remoteChange.at) {
      handleRemoteStatusChange(remoteChange);
      state.lastStatusSeenAt = remoteChange.at;
    }
  }
}

// Update viewer panel
function updateViewerPanel() {
  const state = window.AppState;
  const isViewer = !window.canWrite();

  console.log("Updating viewer panel:", {
    isViewer: isViewer,
    downtimeStarted: state.downtimeStarted,
    hasStartTime: !!state.downtimeStartTime,
    startTime: state.downtimeStartTime
  });

  if (typeof syncTimelineDragPermissions === 'function') {
    syncTimelineDragPermissions();
  }

  // Update mode display
  const modeEl = document.getElementById("rt-mode");
  if (modeEl) modeEl.textContent = `mode: ${isViewer ? "VIEWER" : "HOST"}`;

  const hostEl = document.getElementById('rt-host-name');
  if (hostEl) {
    hostEl.textContent = controllerName || resolveControllerName() || 'Unassigned';
  }
  
  // Show/hide viewer panel
  const panel = document.getElementById("rt-viewer-panel");
  if (panel) panel.style.display = isViewer ? "block" : "none";

  const resetLabel = document.getElementById('rt-last-reset');
  if (resetLabel) {
    if (state.lastResetAt) {
      const resetDate = new Date(state.lastResetAt);
      resetLabel.textContent = resetDate.toLocaleString();
    } else {
      resetLabel.textContent = 'â€”';
    }
  }

  // If viewer and downtime started, ensure UI shows it
  if (isViewer && state.downtimeStarted) {
    console.log("ðŸ“Š Viewer: Updating UI for active downtime");

    // Show progress panel
    const progressPanel = document.getElementById('progressPanel');
    if (progressPanel) progressPanel.style.display = 'block';
    
    // Update status text
    const statusText = document.getElementById('statusText');
    if (statusText) {
      statusText.textContent = state.downtimePaused ? 'Paused' : 'In Progress';
      statusText.style.color = state.downtimePaused ? 'var(--sap-warning)' : 'var(--sap-error)';
    }
    
    // Show downtime info
    const downtimeInfo = document.getElementById('downtimeInfo');
    if (downtimeInfo) downtimeInfo.style.display = 'block';
    
    // Update start time display
    if (state.downtimeStartTime) {
      const startTimeDisplay = document.getElementById('startTimeDisplay');
      if (startTimeDisplay) {
        const startTime = new Date(state.downtimeStartTime);
        startTimeDisplay.textContent = startTime.toLocaleTimeString('en-US', 
          { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false });
        startTimeDisplay.style.display = 'block';
      }
      
      const startTimeInput = document.getElementById('startTimeInput');
      if (startTimeInput) startTimeInput.style.display = 'none';
    }
    
    // Show current duration display
    const currentDurationDisplay = document.getElementById('currentDurationDisplay');
    if (currentDurationDisplay) currentDurationDisplay.style.display = 'block';
    
    const currentDurationInput = document.getElementById('currentDurationInput');
    if (currentDurationInput) currentDurationInput.style.display = 'none';
  }
  
  if (isViewer) {
    // Apply viewer mode class
    document.body.classList.add('viewer-mode');

    // Update viewer status
    const statusEl = document.getElementById("rt-status");
    if (statusEl) {
      if (!state.downtimeStarted) statusEl.textContent = "Not started";
      else if (state.downtimePaused) statusEl.textContent = "Paused";
      else statusEl.textContent = "Running";
    }

    const durationText = document.getElementById('durationText');
    if (durationText) {
      if (state.downtimeStarted && state.downtimeStartTime) {
        const startTime = new Date(state.downtimeStartTime).getTime();
        let pausedOffset = state.pausedDuration || 0;
        if (state.downtimePaused && state.pauseStartTime) {
          const pauseStart = new Date(state.pauseStartTime).getTime();
          if (!isNaN(pauseStart)) {
            pausedOffset += Math.max(0, Date.now() - pauseStart);
          }
        }
        const elapsedMs = Date.now() - startTime - pausedOffset;
        const totalSeconds = Math.max(0, Math.floor(elapsedMs / 1000));
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        durationText.textContent = `${String(hours).padStart(2,'0')}:${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}`;
      } else {
        durationText.textContent = '00:00:00';
      }
    }

    const pauseRow = document.getElementById('rt-pause-reason-row');
    const pauseLabel = document.getElementById('rt-pause-reason');
    if (pauseRow && pauseLabel) {
      if (state.downtimePaused) {
        pauseRow.style.display = 'block';
        pauseLabel.textContent = state.lastPauseReason || 'No reason provided';
      } else {
        pauseRow.style.display = 'none';
      }
    }

    const focusRow = document.getElementById('rt-focus-row');
    const focusTime = document.getElementById('rt-focus-time');
    if (focusRow && focusTime) {
      if (state.fullscreenMode && state.fullscreenSince) {
        focusRow.style.display = 'block';
        const since = new Date(state.fullscreenSince);
        focusTime.textContent = since.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', second: '2-digit' });
      } else {
        focusRow.style.display = 'none';
      }
    }

    // Update start time
    const startEl = document.getElementById("rt-start");
    if (startEl && state.downtimeStartTime) {
      startEl.textContent = new Date(state.downtimeStartTime).toLocaleString();
    } else if (startEl) {
      startEl.textContent = "â€”";
    }

    // Update ETA
    const etaEl = document.getElementById("rt-eta");
    if (etaEl && state.downtimeStartTime) {
      const endTime = new Date(state.downtimeStartTime.getTime() + state.downtimeDuration * 3600000);
      etaEl.textContent = endTime.toLocaleString();
    } else if (etaEl) {
      etaEl.textContent = "â€”";
    }

    // Update progress bar
    if (state.downtimeStarted && state.downtimeStartTime) {
      const now = Date.now();
      const start = new Date(state.downtimeStartTime).getTime();
      const duration = state.downtimeDuration * 3600000;
      let pausedOffset = state.pausedDuration || 0;
      if (state.downtimePaused && state.pauseStartTime) {
        const pauseStart = new Date(state.pauseStartTime).getTime();
        if (!isNaN(pauseStart)) {
          pausedOffset += Math.max(0, now - pauseStart);
        }
      }
      const elapsed = now - start - pausedOffset;
      const percent = Math.min(100, Math.max(0, (elapsed / duration) * 100));

      const bar = document.getElementById("rt-bar");
      const label = document.getElementById("rt-bar-label");
      if (bar) bar.style.width = `${percent}%`;
      if (label) label.textContent = `${Math.round(percent)}%`;
    } else {
      const bar = document.getElementById("rt-bar");
      const label = document.getElementById("rt-bar-label");
      if (bar) bar.style.width = '0%';
      if (label) label.textContent = '0%';
    }
  } else {
    document.body.classList.remove('viewer-mode');
  }

  updateTimelinePreview();
  renderHostStatus();
}

function updateTimelinePreview() {
  const previewContainer = document.getElementById('rt-timeline-preview');
  const list = document.getElementById('rt-timeline-list');
  if (!previewContainer || !list) return;

  const state = window.AppState || {};
  const runbooks = Array.isArray(state.runbooks) ? state.runbooks.slice() : [];
  if (runbooks.length === 0) {
    previewContainer.style.display = 'none';
    list.innerHTML = '';
    return;
  }

  runbooks.sort(function(a, b) {
    const aStart = (a.scheduleHours || 0) * 60 + (a.scheduleMinutes || 0);
    const bStart = (b.scheduleHours || 0) * 60 + (b.scheduleMinutes || 0);
    return aStart - bStart;
  });

  const activeItems = runbooks.filter(function(runbook) {
    return !runbook.completed && (runbook.status !== 'completed');
  }).slice(0, 5);

  if (activeItems.length === 0) {
    previewContainer.style.display = 'none';
    list.innerHTML = '';
    return;
  }

  const downtimeStart = state.downtimeStartTime ? new Date(state.downtimeStartTime).getTime() : null;

  list.innerHTML = activeItems.map(function(runbook) {
    const offsetMinutes = (runbook.scheduleHours || 0) * 60 + (runbook.scheduleMinutes || 0);
    let timeLabel = `${String(runbook.scheduleHours || 0).padStart(2,'0')}:${String(runbook.scheduleMinutes || 0).padStart(2,'0')}`;
    if (downtimeStart) {
      const scheduledMs = downtimeStart + offsetMinutes * 60000;
      timeLabel = new Date(scheduledMs).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    }
    const status = (runbook.status || 'not-started').replace(/-/g, ' ');
    const name = escapeHtml(runbook.runblock || 'Unnamed task');
    return `<li style="display:flex;gap:8px;justify-content:space-between;margin-bottom:4px;">` +
      `<span style="font-family:monospace;color:#555;">${timeLabel}</span>` +
      `<span style="flex:1;text-align:right;">${name}<span style="display:block;font-size:10px;color:#666;">${status}</span></span>` +
    `</li>`;
  }).join('');

  previewContainer.style.display = 'block';
}

// Push state to Firebase (host only)
async function transmitState(statePayload, reason) {
  try {
    await window.firestore.updateDoc(sessionRef, {
      state: statePayload,
      updatedAt: window.firestore.serverTimestamp(),
      reason
    });
  } catch (primaryError) {
    await window.firestore.setDoc(sessionRef, {
      state: statePayload,
      controllerUid: uid,
      controllerName: getOperatorName(),
      updatedAt: window.firestore.serverTimestamp(),
      reason
    }, { merge: true });
  }
}

async function pushState(reason = "update", forcedState) {
  if (!window.canWrite() || writing) return;

  const currentState = forcedState || serialize();
  const stateJson = JSON.stringify(currentState);

  if (!forcedState && stateJson === lastSentState) return;

  try {
    if (LocalRealtime && typeof LocalRealtime.emitState === 'function') {
      LocalRealtime.emitState(currentState, reason, { uid, origin: 'local' });
    }
  } catch (err) {
    console.warn('Local realtime state emit failed', err);
  }

  if (!navigator.onLine) {
    OfflineQueue.enqueue(currentState, reason, 'offline');
    updateConnectionIndicator('offline', 'Browser is offline â€“ queued updates');
    return;
  }

  writing = true;
  try {
    await transmitState(currentState, reason);
    lastSentState = stateJson;
  } catch (e) {
    console.warn('Primary state push failed, queuing for retry', e);
    OfflineQueue.enqueue(currentState, reason, e && e.message ? e.message : 'push failed');
  } finally {
    writing = false;
  }
}

async function flushOfflineQueue() {
  if (!navigator.onLine) return;
  writing = true;
  try {
    await OfflineQueue.flush(async function(queuedState, queuedReason) {
      await transmitState(queuedState, queuedReason);
      lastSentState = JSON.stringify(queuedState);
    });
  } finally {
    writing = false;
    renderOfflineQueueState();
  }
}

// Debounced push
const OfflineQueue = (function() {
  const storageKey = 'dt2-offline-queue';
  let queue = [];
  try {
    const persisted = JSON.parse(localStorage.getItem(storageKey) || '[]');
    if (Array.isArray(persisted)) {
      queue = persisted;
    }
  } catch (err) {
    console.warn('Failed to read offline queue', err);
  }

  function persist() {
    try {
      localStorage.setItem(storageKey, JSON.stringify(queue.slice(-20)));
    } catch (err) {
      console.warn('Unable to persist offline queue', err);
    }
    renderOfflineQueueState();
  }

  function enqueue(state, reason, errorMessage) {
    queue.push({
      state,
      reason,
      error: errorMessage || null,
      timestamp: Date.now()
    });
    persist();
  }

  function shift() {
    const item = queue.shift();
    persist();
    return item;
  }

  function snapshot() {
    return queue.slice();
  }

  async function flush(transmit) {
    if (typeof transmit !== 'function') return;
    if (!navigator.onLine) return;
    if (queue.length === 0) return;

    const pending = snapshot();
    queue.length = 0;
    persist();

    for (const entry of pending) {
      try {
        await transmit(entry.state, entry.reason || 'replay');
      } catch (err) {
        console.warn('Failed to replay queued action', err);
        enqueue(entry.state, entry.reason, err && err.message ? err.message : 'Replay failure');
        break;
      }
    }
  }

  return {
    enqueue,
    flush,
    snapshot
  };
})();

function renderOfflineQueueState() {
  const entries = OfflineQueue.snapshot();
  const countEl = document.getElementById('offlineQueueCount');
  if (countEl) {
    countEl.textContent = entries.length;
    countEl.style.display = entries.length ? 'inline-block' : 'none';
  }
  const listEl = document.getElementById('offlineQueueList');
  if (listEl) {
    if (!entries.length) {
      listEl.innerHTML = '<li style="color:var(--sap-muted)">Queue empty</li>';
    } else {
      listEl.innerHTML = entries.map(function(entry) {
        const ts = new Date(entry.timestamp).toLocaleTimeString();
        return `<li><code>${entry.reason || 'update'}</code> @ ${ts}${entry.error ? ` Â· <span style="color:var(--sap-warning)">${entry.error}</span>` : ''}</li>`;
      }).join('');
    }
  }
}

const NotificationHooks = (function() {
  const storageKey = 'dt2-notification-hooks';
  let hooks = [];
  try {
    const stored = JSON.parse(localStorage.getItem(storageKey) || '[]');
    if (Array.isArray(stored)) {
      hooks = stored;
    }
  } catch (err) {
    console.warn('Failed to parse notification hooks', err);
  }

  function persist() {
    try {
      localStorage.setItem(storageKey, JSON.stringify(hooks));
    } catch (err) {
      console.warn('Unable to persist notification hooks', err);
    }
    renderNotificationHooks();
  }

  function addHook(url, events) {
    if (!url) return;
    hooks.push({ id: 'hook-' + Math.random().toString(36).slice(2, 10), url, events: events && events.length ? events : ['all'] });
    persist();
  }

  function removeHook(id) {
    hooks = hooks.filter(function(hook) { return hook.id !== id; });
    persist();
  }

  async function notify(eventName, payload) {
    if (!hooks.length) return;
    if (!navigator.onLine) {
      console.warn('Skipping external notifications while offline');
      return;
    }
    if (typeof fetch !== 'function') {
      console.warn('Fetch API unavailable â€“ cannot deliver notification hooks');
      return;
    }

    const body = JSON.stringify({ event: eventName, payload, generatedAt: new Date().toISOString() });
    await Promise.allSettled(hooks.map(async function(hook) {
      if (!hook || !hook.url) return;
      const interested = hook.events.includes('all') || hook.events.includes(eventName);
      if (!interested) return;
      try {
        await fetch(hook.url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: body
        });
      } catch (err) {
        console.warn('Notification hook failed', hook.url, err);
      }
    }));
  }

  function getHooks() {
    return hooks.slice();
  }

  return { addHook, removeHook, notify, getHooks };
})();

function renderNotificationHooks() {
  const list = document.getElementById('hooksList');
  if (!list) return;
  const hooks = NotificationHooks.getHooks();
  if (!hooks.length) {
    list.innerHTML = '<li style="color:var(--sap-muted)">No hooks configured</li>';
    return;
  }
  list.innerHTML = hooks.map(function(hook) {
    const events = (hook.events || ['all']).join(', ');
    return `<li style="margin-bottom:4px;">
      <div>${hook.url}</div>
      <div style="font-size:10px;color:var(--sap-muted);">Events: ${events}</div>
      <button class="btn small danger" data-hook-id="${hook.id}">Remove</button>
    </li>`;
  }).join('');

  list.querySelectorAll('button[data-hook-id]').forEach(function(btn) {
    btn.addEventListener('click', function() {
      NotificationHooks.removeHook(btn.getAttribute('data-hook-id'));
    });
  });
}

const KpiAutomation = (function() {
  const storageKey = 'dt2-kpi-automation';
  let config = { variancePercent: 15, varianceMinutes: 20, enabled: true };
  try {
    const stored = JSON.parse(localStorage.getItem(storageKey) || 'null');
    if (stored && typeof stored === 'object') {
      config = { ...config, ...stored };
    }
  } catch (err) {
    console.warn('Failed to parse KPI automation config', err);
  }
  let lastSignature = null;

  function persist() {
    try {
      localStorage.setItem(storageKey, JSON.stringify(config));
    } catch (err) {
      console.warn('Unable to persist KPI automation config', err);
    }
    renderAutomationConfig();
  }

  function update(partial) {
    config = { ...config, ...partial };
    persist();
  }

  function get() {
    return { ...config };
  }

  function shouldTrigger(varianceMinutes, variancePercent) {
    if (!config.enabled) return false;
    const exceedsPercent = Math.abs(variancePercent) >= config.variancePercent;
    const exceedsMinutes = Math.abs(varianceMinutes) >= config.varianceMinutes;
    const signature = `${Math.round(varianceMinutes)}:${Math.round(variancePercent)}`;
    if (exceedsPercent || exceedsMinutes) {
      if (lastSignature === signature) return false;
      lastSignature = signature;
      return true;
    }
    lastSignature = null;
    return false;
  }

  return { update, get, shouldTrigger };
})();

function renderAutomationConfig() {
  const form = document.getElementById('automationForm');
  if (!form) return;
  const config = KpiAutomation.get();
  const percentInput = document.getElementById('automationPercent');
  const minutesInput = document.getElementById('automationMinutes');
  const enabledInput = document.getElementById('automationEnabled');
  if (percentInput) percentInput.value = config.variancePercent;
  if (minutesInput) minutesInput.value = config.varianceMinutes;
  if (enabledInput) enabledInput.checked = !!config.enabled;
}

let lastAutomationToastAt = 0;

function handleKpiAutomation(plannedMinutes, actualMinutes) {
  const varianceMinutes = actualMinutes - plannedMinutes;
  const variancePercent = plannedMinutes ? (varianceMinutes / plannedMinutes) * 100 : 0;
  if (!KpiAutomation.shouldTrigger(varianceMinutes, variancePercent)) return;

  const message = `Variance ${variancePercent.toFixed(1)}% (${formatHoursShort(Math.abs(varianceMinutes))})`; 
  if (Date.now() - lastAutomationToastAt > 5000 && typeof showToast === 'function') {
    showToast('ðŸ“ˆ KPI automation alert â€“ ' + message);
    lastAutomationToastAt = Date.now();
  }
  NotificationHooks.notify('kpi-threshold', {
    varianceMinutes,
    variancePercent,
    plannedMinutes,
    actualMinutes
  });
}

function renderSnapshotStatus() {
  const statusEl = document.getElementById('snapshotStatus');
  if (!statusEl) return;
  try {
    const snapshot = JSON.parse(localStorage.getItem('dt2-mobile-snapshot') || 'null');
    if (snapshot && snapshot.generatedAt) {
      const when = new Date(snapshot.generatedAt).toLocaleString();
      statusEl.textContent = `Snapshot from ${when} Â· ${snapshot.runbooks ? snapshot.runbooks.length : 0} tasks`;
    } else {
      statusEl.textContent = 'No snapshot generated.';
    }
  } catch (err) {
    statusEl.textContent = 'Snapshot unavailable';
  }
}

function generateMobileSnapshot() {
  const state = window.AppState || {};
  const snapshot = {
    generatedAt: new Date().toISOString(),
    customer: nameInput?.value || '',
    transform: phaseInput?.value || '',
    downtime: {
      started: !!state.downtimeStarted,
      startTime: state.downtimeStartTime || null,
      duration: state.downtimeDuration || null,
      paused: !!state.downtimePaused
    },
    runbooks: (state.runbooks || []).map(function(r) {
      return {
        sequence: r.sequence,
        runblock: r.runblock,
        responsibility: r.responsibility,
        status: r.status,
        planned: `${String(r.scheduleHours || 0).padStart(2,'0')}:${String(r.scheduleMinutes || 0).padStart(2,'0')}`,
        duration: `${String(r.durationHours || 0).padStart(2,'0')}:${String(r.durationMinutes || 0).padStart(2,'0')}`,
        predecessor: r.predecessor || null
      };
    })
  };
  try {
    localStorage.setItem('dt2-mobile-snapshot', JSON.stringify(snapshot));
    renderSnapshotStatus();
    showToast('ðŸ“± Mobile snapshot cached for offline access.');
  } catch (err) {
    console.error('Failed to persist mobile snapshot', err);
    alert('Unable to generate snapshot â€“ storage full?');
  }
  return snapshot;
}

function ensureDiagnosticsDrawer() {
  if (document.getElementById('diagnosticsDrawer')) return;
  const drawer = document.createElement('div');
  drawer.id = 'diagnosticsDrawer';
  drawer.innerHTML = `
    <header>
      <h3>Health Diagnostics</h3>
      <button id="diagnosticsClose" class="btn small danger" type="button">Close</button>
    </header>
    <div class="diagnostics-body">
      <dl>
        <dt>Status</dt><dd id="diag-connection">â€”</dd>
        <dt>Auth</dt><dd id="diag-auth">â€”</dd>
        <dt>Last Sync</dt><dd id="diag-last-snapshot">â€”</dd>
        <dt>Presence</dt><dd id="diag-presence">â€”</dd>
      </dl>
      <div class="offline-queue">
        <h4>Offline Queue <span id="offlineQueueCount" style="display:none;background:var(--sap-accent);color:#fff;padding:0 6px;border-radius:999px;font-size:10px;"></span></h4>
        <ul id="offlineQueueList"><li style="color:var(--sap-muted)">Queue empty</li></ul>
      </div>
      <div class="hooks">
        <h4>Notification Hooks</h4>
        <form id="hookForm" style="display:flex;flex-direction:column;gap:6px;margin-bottom:6px;">
          <input type="url" id="hookUrl" placeholder="https://hooks.slack.com/..." required>
          <select id="hookEvent">
            <option value="all">All events</option>
            <option value="downtime-start">Downtime started</option>
            <option value="downtime-stop">Downtime stopped</option>
            <option value="focus-enter">Focus entered</option>
            <option value="focus-exit">Focus exited</option>
            <option value="dark-mode">Dark mode toggled</option>
            <option value="kpi-threshold">KPI threshold exceeded</option>
          </select>
          <button class="btn small primary" type="submit">Add hook</button>
        </form>
        <ul id="hooksList"></ul>
      </div>
      <div class="automation">
        <h4>KPI Automation</h4>
        <form id="automationForm" style="display:flex;flex-direction:column;gap:6px;margin-bottom:6px;">
          <label style="font-size:11px;display:flex;justify-content:space-between;gap:8px;">Variance %
            <input type="number" min="1" max="100" id="automationPercent" style="width:90px;">
          </label>
          <label style="font-size:11px;display:flex;justify-content:space-between;gap:8px;">Variance minutes
            <input type="number" min="1" max="360" id="automationMinutes" style="width:90px;">
          </label>
          <label style="font-size:11px;display:flex;align-items:center;gap:6px;"><input type="checkbox" id="automationEnabled"> Enable automation</label>
          <button class="btn small primary" type="submit">Save thresholds</button>
        </form>
      </div>
      <div class="snapshot">
        <h4>Mobile Snapshot</h4>
        <p id="snapshotStatus" style="font-size:11px;color:var(--sap-muted);margin:4px 0;">No snapshot generated.</p>
        <button id="snapshotGenerate" class="btn small" type="button">Generate snapshot</button>
      </div>
      <div class="messaging-help" style="margin-top:12px;">
        <h4>Messaging Tips</h4>
        <p style="font-size:11px;color:var(--sap-muted);">Use the <strong>Messages</strong> toggle to surface announcements. Each message row supports scheduling via planned time, responsibility, and status badges. Enable messages only after validating content so viewers are not spammed.</p>
      </div>
      <div class="tour-controls" style="margin-top:12px;">
        <h4>Onboarding</h4>
        <button id="tourRestart" class="btn small primary" type="button">Run host tour</button>
      </div>
    </div>
  `;
  document.body.appendChild(drawer);

  const closeBtn = drawer.querySelector('#diagnosticsClose');
  if (closeBtn) {
    closeBtn.addEventListener('click', function() {
      drawer.classList.remove('open');
    });
  }

  const hookForm = drawer.querySelector('#hookForm');
  if (hookForm) {
    hookForm.addEventListener('submit', function(e) {
      e.preventDefault();
      const urlInput = drawer.querySelector('#hookUrl');
      const eventInput = drawer.querySelector('#hookEvent');
      const urlValue = urlInput?.value.trim();
      const eventValue = eventInput?.value || 'all';
      if (urlValue) {
        NotificationHooks.addHook(urlValue, [eventValue]);
        urlInput.value = '';
      }
    });
  }

  const automationForm = drawer.querySelector('#automationForm');
  if (automationForm) {
    automationForm.addEventListener('submit', function(e) {
      e.preventDefault();
      const percent = parseInt(document.getElementById('automationPercent').value, 10) || 0;
      const minutes = parseInt(document.getElementById('automationMinutes').value, 10) || 0;
      const enabled = document.getElementById('automationEnabled').checked;
      KpiAutomation.update({ variancePercent: Math.max(1, percent), varianceMinutes: Math.max(1, minutes), enabled });
      showToast('âš™ï¸ KPI automation thresholds updated');
    });
  }

  const snapshotBtn = drawer.querySelector('#snapshotGenerate');
  if (snapshotBtn) {
    snapshotBtn.addEventListener('click', function() {
      generateMobileSnapshot();
    });
  }

  const tourBtn = drawer.querySelector('#tourRestart');
  if (tourBtn) {
    tourBtn.addEventListener('click', function() {
      OnboardingTour.start(true);
    });
  }
}

function renderDiagnosticsPanel() {
  const statusEl = document.getElementById('diag-connection');
  if (statusEl) statusEl.textContent = connectionStatus || 'â€”';
  const authEl = document.getElementById('diag-auth');
  if (authEl) authEl.textContent = auth?.currentUser?.uid ? auth.currentUser.uid.slice(-6) : 'anon';
  const lastEl = document.getElementById('diag-last-snapshot');
  if (lastEl) {
    if (lastSnapshotAt) {
      const seconds = Math.round((Date.now() - lastSnapshotAt) / 1000);
      lastEl.textContent = seconds <= 1 ? 'Realtime' : `${seconds}s ago`;
    } else {
      lastEl.textContent = 'Pending';
    }
  }
  const presenceEl = document.getElementById('diag-presence');
  if (presenceEl) presenceEl.textContent = Object.keys(presenceRoster || {}).length;

  renderOfflineQueueState();
  renderNotificationHooks();
  renderAutomationConfig();
  renderSnapshotStatus();
}

function toggleDiagnosticsDrawer(forceState) {
  ensureDiagnosticsDrawer();
  const drawer = document.getElementById('diagnosticsDrawer');
  if (!drawer) return;
  if (typeof forceState === 'boolean') {
    drawer.classList.toggle('open', forceState);
  } else {
    drawer.classList.toggle('open');
  }
  if (drawer.classList.contains('open')) {
    renderDiagnosticsPanel();
  }
}

function showMessagingInstructions() {
  toggleDiagnosticsDrawer(true);
  showToast('â„¹ï¸ Diagnostics drawer includes messaging & announcement guidance.');
}

const CommandPalette = (function() {
  let overlay = null;
  let input = null;
  let list = null;
  let activeIndex = 0;

  const commands = [
    { id: 'toggle-focus', label: 'Toggle focus mode', action: () => toggleFullscreenMode(), shortcut: 'F' },
    { id: 'toggle-dark', label: 'Toggle dark mode', action: () => toggleDarkMode(), shortcut: 'D' },
    { id: 'start-downtime', label: 'Start downtime session', action: () => { if (typeof startDowntime === 'function') startDowntime(); }, shortcut: 'Ctrl+Enter' },
    { id: 'pause-downtime', label: 'Pause downtime', action: () => { if (typeof pauseDowntime === 'function') pauseDowntime(); } },
    { id: 'resume-downtime', label: 'Resume downtime', action: () => { if (typeof resumeDowntime === 'function') resumeDowntime(); } },
    { id: 'open-diagnostics', label: 'Open diagnostics drawer', action: () => toggleDiagnosticsDrawer(true) },
    { id: 'messages-help', label: 'Messaging framework instructions', action: showMessagingInstructions },
    { id: 'save-template', label: 'Save current template', action: () => { if (typeof window.saveTemplate === 'function') window.saveTemplate(); }, shortcut: 'Ctrl+S' },
    { id: 'generate-snapshot', label: 'Generate mobile snapshot', action: generateMobileSnapshot }
  ];

  function ensure() {
    if (overlay) return;
    overlay = document.createElement('div');
    overlay.className = 'command-palette-overlay';
    overlay.innerHTML = `
      <div class="command-palette">
        <input type="text" placeholder="Type a commandâ€¦" aria-label="Command search" />
        <ul></ul>
      </div>
    `;
    document.body.appendChild(overlay);
    input = overlay.querySelector('input');
    list = overlay.querySelector('ul');

    overlay.addEventListener('click', function(e) {
      if (e.target === overlay) {
        close();
      }
    });

    input.addEventListener('input', function() {
      renderList(input.value);
    });

    input.addEventListener('keydown', function(e) {
      if (e.key === 'ArrowDown') {
        e.preventDefault();
        activeIndex = Math.min(activeIndex + 1, filteredCommands.length - 1);
        highlight();
      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        activeIndex = Math.max(activeIndex - 1, 0);
        highlight();
      } else if (e.key === 'Enter') {
        e.preventDefault();
        invoke(activeIndex);
      } else if (e.key === 'Escape') {
        e.preventDefault();
        close();
      }
    });
  }

  let filteredCommands = commands.slice();

  function renderList(filterValue) {
    const query = (filterValue || '').toLowerCase();
    filteredCommands = commands.filter(function(cmd) {
      return !query || cmd.label.toLowerCase().includes(query);
    });
    if (!filteredCommands.length) {
      list.innerHTML = '<li style="color:var(--sap-muted);">No commands</li>';
      return;
    }
    list.innerHTML = filteredCommands.map(function(cmd, idx) {
      const shortcut = cmd.shortcut ? `<span class="shortcut">${cmd.shortcut}</span>` : '';
      return `<li data-index="${idx}" class="${idx === activeIndex ? 'active' : ''}">${cmd.label}${shortcut}</li>`;
    }).join('');
    list.querySelectorAll('li').forEach(function(item) {
      item.addEventListener('click', function() {
        const idx = parseInt(item.getAttribute('data-index'), 10);
        invoke(idx);
      });
    });
    highlight();
  }

  function highlight() {
    if (!list) return;
    list.querySelectorAll('li').forEach(function(li) {
      li.classList.remove('active');
    });
    const active = list.querySelector(`li[data-index="${activeIndex}"]`);
    if (active) {
      active.classList.add('active');
      active.scrollIntoView({ block: 'nearest' });
    }
  }

  function invoke(idx) {
    const command = filteredCommands[idx];
    if (!command) return;
    close();
    try {
      command.action();
    } catch (err) {
      console.error('Command execution failed', err);
    }
  }

  function open() {
    ensure();
    overlay.classList.add('show');
    filteredCommands = commands.slice();
    activeIndex = 0;
    renderList('');
    setTimeout(function() {
      input.focus();
      input.select();
    }, 0);
  }

  function close() {
    if (!overlay) return;
    overlay.classList.remove('show');
  }

  return { open, close };
})();

document.addEventListener('keydown', function(e) {
  if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'k') {
    e.preventDefault();
    CommandPalette.open();
  }
});

const OnboardingTour = (function() {
  const storageKey = 'dt2-onboarding-complete';
  let overlay = null;
  let stepIndex = 0;
  let highlighted = null;

  const steps = [
    { selector: '#fullscreenToggle', title: 'Focus mode', description: 'Use focus mode to hide configuration panels and synchronize a fullscreen view with all viewers.' },
    { selector: '#darkModeToggle', title: 'Dark mode', description: 'Toggle dark mode to adjust the shared theme. The preference propagates to viewers in real time.' },
    { selector: '#messageToggleBtn', title: 'Messaging framework', description: 'Enable messages after validating announcements. Scheduled messages appear in the timeline for viewers.' },
    { selector: '#rt-open-diagnostics', title: 'Health diagnostics', description: 'Open the diagnostics drawer for offline queue visibility, webhook configuration, and automation settings.' },
    { selector: '#rt-copy', title: 'Share viewer link', description: 'Copy a viewer-safe link when you are ready to broadcast downtime updates to observers.' }
  ];

  function ensureOverlay() {
    if (overlay) return;
    overlay = document.createElement('div');
    overlay.className = 'onboarding-overlay';
    overlay.innerHTML = `
      <div class="onboarding-card" role="dialog" aria-modal="true" aria-labelledby="tourTitle">
        <h2 id="tourTitle"></h2>
        <p id="tourDescription" style="font-size:13px;line-height:1.5;"></p>
        <footer>
          <button id="tourSkip" class="btn subtle" type="button">Skip</button>
          <div style="display:flex;gap:8px;">
            <button id="tourPrev" class="btn small" type="button">Back</button>
            <button id="tourNext" class="btn small primary" type="button">Next</button>
          </div>
        </footer>
      </div>
    `;
    document.body.appendChild(overlay);

    overlay.querySelector('#tourSkip').addEventListener('click', function() {
      finish(true);
    });
    overlay.querySelector('#tourPrev').addEventListener('click', function() {
      showStep(stepIndex - 1);
    });
    overlay.querySelector('#tourNext').addEventListener('click', function() {
      if (stepIndex === steps.length - 1) {
        finish(true);
      } else {
        showStep(stepIndex + 1);
      }
    });
  }

  function highlightTarget(selector) {
    if (highlighted) {
      highlighted.classList.remove('tour-highlight');
      highlighted = null;
    }
    if (!selector) return;
    const target = document.querySelector(selector);
    if (target) {
      target.classList.add('tour-highlight');
      highlighted = target;
      target.scrollIntoView({ behavior: 'smooth', block: 'center' });
    }
  }

  function showStep(index) {
    ensureOverlay();
    stepIndex = Math.max(0, Math.min(index, steps.length - 1));
    const step = steps[stepIndex];
    overlay.querySelector('#tourTitle').textContent = step.title;
    overlay.querySelector('#tourDescription').textContent = step.description;
    overlay.classList.add('show');
    highlightTarget(step.selector);
    overlay.querySelector('#tourPrev').disabled = stepIndex === 0;
    overlay.querySelector('#tourNext').textContent = stepIndex === steps.length - 1 ? 'Finish' : 'Next';
  }

  function finish(store) {
    if (overlay) overlay.classList.remove('show');
    highlightTarget(null);
    if (store) {
      try {
        localStorage.setItem(storageKey, 'true');
      } catch (err) {
        console.warn('Unable to persist onboarding completion', err);
      }
    }
  }

  function start(force) {
    try {
      if (!force && localStorage.getItem(storageKey) === 'true') return;
    } catch (err) {
      console.warn('Onboarding storage check failed', err);
    }
    showStep(0);
  }

  return {
    start,
    maybeStart: function() { start(false); }
  };
})();

let pushTimer = null;
function schedulePush(reason = 'debounce') {
  clearTimeout(pushTimer);
  pushTimer = setTimeout(() => pushState(reason), 250);
}

// Subscribe to session changes
let initialSync = true;

function subscribeToSession() {
  if (sessionUnsubscribe) sessionUnsubscribe();
  sessionUnsubscribe = window.firestore.onSnapshot(
    sessionRef,
    async (snap) => {
  const data = snap.data() || {};
  const wasViewerRequested = requestedViewerMode;
  remoteController = data.controllerUid || null;
  latestSessionData = data;
  controlRequest = data.controlRequest && data.controlRequest.uid ? { ...data.controlRequest } : null;
  if (controlRequest && !controlRequest.name) {
    controlRequest.name = controlRequest.displayName || controlRequest.requesterName || null;
  }
  controllerName = resolveControllerName();
  const isDowntimeActive = data.state?.downtimeStarted || false;
  remoteDowntimeActive = isDowntimeActive;
  if (!remoteController) attemptedControllerClaim = false;
  lastSnapshotAt = Date.now();
  updateConnectionIndicator('online', 'Realtime updates connected');

  console.log("Session snapshot received:", {
    hasData: !!data,
    hasState: !!data.state,
    remoteController: remoteController,
    isViewer: !window.canWrite(),
    downtimeStarted: isDowntimeActive,
    currentUid: uid
  });

  // Apply state
  if (data.state) {
    applyRemoteState(data.state);
    try {
      if (LocalRealtime && typeof LocalRealtime.ingestState === 'function') {
        LocalRealtime.ingestState(data.state, {
          uid: data.controllerUid || null,
          reason: data.reason || 'remote-sync',
          origin: 'remote'
        });
      }
    } catch (err) {
      console.warn('Local realtime state ingest failed', err);
    }
  }

  renderControlRequestBanner();

  if (remoteController === uid && viewerForced) {
    viewerForced = false;
    viewerParam = "0";
    requestedViewerMode = false;
    const url = new URL(window.location.href);
    url.searchParams.set("viewer", "0");
    history.replaceState(null, "", url.toString());
    hostBlockReason = null;
    hostBlockAlerted = false;
    if (typeof updatePresence === 'function') {
      setTimeout(() => updatePresence(), 0);
    }
  }

  if (remoteController && remoteController !== uid) {
    if (!viewerForced) {
      viewerForced = true;
      if (typeof updatePresence === 'function') {
        setTimeout(() => updatePresence(), 0);
      }
    }

    const url = new URL(window.location.href);
    if (url.searchParams.get("viewer") !== "1") {
      url.searchParams.set("viewer", "1");
      history.replaceState(null, "", url.toString());
    }
    viewerParam = "1";
    requestedViewerMode = true;

    if (!wasViewerRequested && !hostBlockAlerted) {
      hostBlockReason = "âš ï¸ Only one host is allowed for this customer and cycle. You have been placed in viewer mode.";
      hostBlockAlerted = true;
      alert(hostBlockReason);
    }
  }

  // Try to become controller if none exists and we are eligible to host
  if (!remoteController && !viewerForced) {
    await attemptControllerClaim(initialSync ? 'initial-sync' : 'session-sync');
  }

  // Update UI based on role
  updateViewerPanel();
  if (typeof window.updateHostAuthUI === 'function') {
    window.updateHostAuthUI();
  }

  if (initialSync) {
    initialSync = false;
    lastSentState = JSON.stringify(serialize());
    console.log("Initial sync complete, mode:", window.canWrite() ? "HOST" : "VIEWER");
    hideContextSwitchToast();
    contextSwitchInFlight = false;
    renderHostStatus();
    if (typeof window.updateHostAuthUI === 'function') {
      window.updateHostAuthUI();
    }

    // CRITICAL FIX: For viewers, force UI update and start duration counter
    if (!window.canWrite() && data.state) {
      console.log("ðŸ”„ Forcing viewer UI update on initial load");
      setTimeout(() => {
        updateViewerPanel();
        if (typeof window.updateDuration === 'function') window.updateDuration();
        if (typeof window.updateTimeline === 'function') window.updateTimeline();

        // Start continuous updates for viewers when downtime is active
        if (window.AppState.downtimeStarted) {
          console.log("ðŸ”„ Starting viewer duration counter");
          // Duration updates handled by interval below
        }
      }, 500);
    }
  }
  },
  (error) => {
    console.error("Session listener error", error);
    updateConnectionIndicator('offline', 'Realtime session disconnected');
  });
}

subscribeToSession();

async function requestHostControl() {
  if (typeof window.canWrite === 'function' && window.canWrite()) {
    alert('You are already the host of this session.');
    return;
  }
  if (!uid) {
    alert('Authentication is still in progress. Please try again momentarily.');
    return;
  }
  if (controlRequest && controlRequest.uid && controlRequest.uid !== uid) {
    alert('Another teammate has already requested control. Please wait for the host to respond.');
    return;
  }
  if (!navigator.onLine) {
    alert('You are offline. Reconnect to request host control.');
    return;
  }
  try {
    lastControlRequestUid = uid;
    await window.firestore.setDoc(sessionRef, {
      controlRequest: {
        uid,
        name: getOperatorName(),
        requestedAt: window.firestore.serverTimestamp()
      }
    }, { merge: true });
    renderControlRequestBanner();
  } catch (err) {
    console.error('Failed to request host control', err);
    alert('Could not send host control request. Please try again.');
    lastControlRequestUid = null;
  }
}

async function approveControlRequest() {
  if (typeof window.canWrite !== 'function' || !window.canWrite()) {
    alert('Only the current host can approve a request.');
    return;
  }
  if (!controlRequest || !controlRequest.uid) {
    renderControlRequestBanner();
    return;
  }
  try {
    const presence = presenceRoster[controlRequest.uid] || {};
    await window.firestore.setDoc(sessionRef, {
      controllerUid: controlRequest.uid,
      controllerName: controlRequest.name || presence.displayName || presence.name || null,
      controllerSetAt: window.firestore.serverTimestamp(),
      controlRequest: null
    }, { merge: true });
    renderControlRequestBanner();
  } catch (err) {
    console.error('Failed to approve host control request', err);
    alert('Unable to hand over control. Please retry.');
  }
}

async function dismissControlRequest() {
  if (typeof window.canWrite !== 'function' || !window.canWrite()) return;
  if (!controlRequest) return;
  try {
    await window.firestore.setDoc(sessionRef, { controlRequest: null }, { merge: true });
    renderControlRequestBanner();
  } catch (err) {
    console.error('Failed to dismiss host control request', err);
  }
}

async function switchSessionContext(newValues) {
  const newContext = deriveSessionContext(newValues);
  const previousContext = sessionContext;
  const previousPresenceId = presenceDocId || uid || sessionInstanceId;

  if (contextSwitchInFlight) {
    console.warn("Session switch already in progress; queuing latest request.");
    pendingSessionContext = newContext;
    // Keep the UI aligned with the user's requested context while the switch is queued
    applySessionContextToUi({ ...sessionContext, ...newContext });
    return;
  }

  if (newContext.sessionKey === previousContext.sessionKey) {
    sessionContext = { ...previousContext, ...newContext };
    applySessionContextToUi(sessionContext);
    return;
  }

  if (window.AppState.downtimeStarted) {
    console.warn("Cannot change session while downtime is active");
    if (nameInput) nameInput.value = customerParam;
    if (phaseInput) phaseInput.value = phaseParam;
    alert("Cannot change customer or transform cycle while downtime tracker is active.");
    return;
  }

  console.log("Switching session context", previousContext.sessionKey, "->", newContext.sessionKey);

  if (LocalRealtime && typeof LocalRealtime.removePresence === 'function') {
    try {
      LocalRealtime.removePresence(previousPresenceId);
    } catch (err) {
      console.warn('Failed to clear local presence before context switch', err);
    }
  }

  if (localStateUnsubscribe) {
    try { localStateUnsubscribe(); } catch (err) { console.warn('Failed to detach local state listener', err); }
    localStateUnsubscribe = null;
  }
  if (localPresenceUnsubscribe) {
    try { localPresenceUnsubscribe(); } catch (err) { console.warn('Failed to detach local presence listener', err); }
    localPresenceUnsubscribe = null;
  }

  if (LocalRealtime && typeof LocalRealtime.dispose === 'function') {
    try {
      LocalRealtime.dispose();
    } catch (err) {
      console.warn('Failed to dispose realtime bridge', err);
    }
  }

  contextSwitchInFlight = true;
  showContextSwitchToast(`Switching to ${newContext.customerValue} Â· ${newContext.transformValue}`);
  updateConnectionIndicator('pending', 'Syncing new session contextâ€¦');

  const previousPresenceRef = presenceRef;
  const previousSessionRef = sessionRef;

  try {
    if (previousPresenceRef) {
      await window.firestore.deleteDoc(previousPresenceRef);
    }
  } catch (err) {
    console.warn("Failed to delete previous presence record", err);
  }

  try {
    if (remoteController === uid) {
      await window.firestore.setDoc(previousSessionRef, {
        controllerUid: null,
        controllerName: null,
        controlRequest: null,
        updatedAt: window.firestore.serverTimestamp(),
        reason: "context-switch"
      }, { merge: true });
    }
  } catch (err) {
    console.warn("Failed to release previous controller", err);
  }

  try {
    sessionContext = newContext;
    if (!presenceDocId && uid) {
      presenceDocId = `${uid}-${sessionInstanceId}`;
    }
    presenceRef = doc(db, "sessions", sessionContext.sessionKey, "presence", presenceDocId || uid);
    sessionRef = doc(db, "sessions", sessionContext.sessionKey);
    attemptedControllerClaim = false;
    remoteController = null;
    remoteDowntimeActive = false;
    initialSync = true;
    viewerParam = url.searchParams.get("viewer");
    viewerForced = viewerParam === "1";
    requestedViewerMode = viewerParam === "1";
    hostBlockReason = null;
    hostBlockAlerted = false;
    window.AppState.isFirstUser = false;
    controlRequest = null;
    controllerName = null;
    presenceRoster = {};
    presenceRosterReady = false;

    applySessionContextToUi(sessionContext);
    renderControlRequestBanner();

    LocalRealtime = createLocalRealtimeBridge(sessionContext.sessionKey);
    window.LocalRealtimeBridge = LocalRealtime;
    bindLocalRealtimeBridges();

    await bindPresenceListeners();
    subscribeToSession();
    await detectMode();
    updateViewerPanel();
  } catch (err) {
    console.error('Failed to switch session context', err);
    updateConnectionIndicator('error', 'Session switch failed, restoring previous context');
    sessionContext = previousContext;
    applySessionContextToUi(previousContext);
    throw err;
  } finally {
    hideContextSwitchToast();
    contextSwitchInFlight = false;

    if (pendingSessionContext && pendingSessionContext.sessionKey !== sessionContext.sessionKey) {
      const queued = pendingSessionContext;
      pendingSessionContext = null;
      switchSessionContext(queued).catch(err => console.error('Queued session context switch failed', err));
    } else {
      pendingSessionContext = null;
    }
  }
}

if (nameInput) {
  nameInput.addEventListener('change', () => {
    switchSessionContext({
      customerValue: nameInput.value,
      transformValue: phaseInput?.value || phaseParam
    }).catch(err => console.error('Failed to switch session context (customer change)', err));
  });

  nameInput.addEventListener('keydown', (event) => {
    if (event.key === 'Enter') {
      event.preventDefault();
      switchSessionContext({
        customerValue: nameInput.value,
        transformValue: phaseInput?.value || phaseParam
      }).catch(err => console.error('Failed to switch session context (customer change via enter)', err));
    }
  });
}

if (phaseInput) {
  phaseInput.addEventListener('change', () => {
    switchSessionContext({
      customerValue: nameInput?.value || customerParam,
      transformValue: phaseInput.value
    }).catch(err => console.error('Failed to switch session context (transform change)', err));
  });
}

function syncSessionContextFromUrl() {
  const currentSearch = new URL(window.location.href).searchParams;
  const urlCustomer = readCustomerFromUrl(currentSearch);
  const urlTransform = readTransformFromUrl(currentSearch);

  const needsCustomerUpdate = nameInput && urlCustomer && urlCustomer !== nameInput.value;
  const needsTransformUpdate = phaseInput && urlTransform && urlTransform !== phaseInput.value;

  if (!needsCustomerUpdate && !needsTransformUpdate) return;

  if (needsCustomerUpdate) nameInput.value = urlCustomer;
  if (needsTransformUpdate) phaseInput.value = urlTransform;

  switchSessionContext({
    customerValue: nameInput?.value || urlCustomer,
    transformValue: phaseInput?.value || urlTransform
  }).catch(err => console.error('Failed to sync session from URL params', err));
}

['pushState', 'replaceState'].forEach(function(method) {
  const original = history[method];
  history[method] = function() {
    const result = original.apply(this, arguments);
    window.dispatchEvent(new Event('locationchange'));
    return result;
  };
});

window.addEventListener('popstate', function() {
  window.dispatchEvent(new Event('locationchange'));
});
window.addEventListener('locationchange', syncSessionContextFromUrl);
syncSessionContextFromUrl();

// Hook into mutation functions (including fullscreen toggle)
const mutationFunctions = [
  "startDowntime", "pauseDowntime", "resumeDowntime", "stopDowntime",
  "addRunbookRow", "removeRunbook", "clearRunbook",
  "updateSequence", "updateStrategy", "updatePhase", "updateRunblock",
  "updateResponsibility", "updateCritical", "updateScheduleTime",
  "updateDurationTime", "toggleCompleted", "calculateEndTime", "updateTimeline",
  "updateStatus", "duplicateRunbook", "filterRunbooks", "clearFilters",
  "toggleFullscreenMode"
];

mutationFunctions.forEach(fnName => {
  const original = window[fnName];
  if (typeof original === "function") {
    window[fnName] = function(...args) {
      const result = original.apply(this, args);
      if (window.canWrite()) schedulePush();
      return result;
    };
  }
});

// Watch input changes
["customerName", "transformCycle", "downtimeDuration"].forEach(id => {
  const el = document.getElementById(id);
  if (el) {
    el.addEventListener("change", () => {
      if (window.canWrite()) schedulePush();
    });
  }
});

// Update timeline position for viewers and hosts
setInterval(() => {
  if (window.AppState.downtimeStarted && window.AppState.downtimeStartTime) {
    // Calculate current position
    const now = new Date();
    const startTime = resolveDowntimeStartTime();
    if (!startTime) return;
    const pausedOffset = getEffectivePausedDuration(now);
    const elapsed = (now - startTime - pausedOffset) / 3600000;
    const pixelsPerHour = 60;
    const linePosition = Math.min(elapsed * pixelsPerHour, window.AppState.downtimeDuration * pixelsPerHour);
    
    // Update timeline
      const currentLine = document.getElementById('currentTimeLine');
      if (currentLine) {
        currentLine.style.left = `${linePosition}px`;
        currentLine.style.display = 'block';

        // Update label
        const elapsedMs = now - startTime - pausedOffset;
        const totalSeconds = Math.floor(elapsedMs / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;

        const label = document.getElementById('currentTimeLabel');
        if (label) {
          label.textContent = `${String(hours).padStart(2,'0')}:${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}`;
        }
      }

      // Update duration display
      if (typeof window.updateDuration === 'function') window.updateDuration();

      // Update main duration text in header
      const durationText = document.getElementById('durationText');
      if (durationText) {
        const elapsedMs = now - startTime - pausedOffset;
        const totalSeconds = Math.floor(elapsedMs / 1000);
        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;
        durationText.textContent = `${String(hours).padStart(2,'0')}:${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}`;
      }
    
    // Update viewer panel
    updateViewerPanel();
    
    // Force update of progress indicators for viewers
    if (!window.canWrite()) {
      updateProgressIndicators();
      
      // Ensure viewer sees the active session UI
      const progressPanel = document.getElementById('progressPanel');
      if (progressPanel) progressPanel.style.display = 'block';
    }
  }
}, 1000);

window.addEventListener('beforeunload', function() {
  const presenceId = presenceDocId || uid || sessionInstanceId;
  try {
    if (LocalRealtime && typeof LocalRealtime.removePresence === 'function') {
      LocalRealtime.removePresence(presenceId);
    }
  } catch (err) {
    console.warn('Failed to clean up local presence on unload', err);
  }
});

window.initializeRealtime = initializeRealtime;
window.schedulePush = schedulePush;
window.pushRealtimeState = pushState;
document.dispatchEvent(new CustomEvent('dt2-realtime-ready'));

// Reset function
document.getElementById("rt-reset").onclick = async function() {
  if (!window.canWrite()) {
    alert("Only the host can reset the session.");
    return;
  }
  
  if (!confirm("Reset the session for ALL viewers? This will clear all data and release host control.")) return;
  
  // Clear state
  window.AppState = {
    runbooks: [],
    downtimeStarted: false,
    downtimeStartTime: null,
    downtimeDuration: 24,
    downtimePaused: false,
    pausedDuration: 0,
    pauseStartTime: null,
    currentDraggedBlock: null,
    dragOffset: 0,
    completionTimes: {},
    pendingCompletionUpdates: {},
    isFirstUser: false,
    syncedTimelinePosition: 0,
    renderLock: false,
    messagesOn: false,
    fullscreenMode: false
  };
  presenceRoster = {};
  presenceRosterReady = false;

  // Reset UI
  document.getElementById('customerName').value = '';
  document.getElementById('transformCycle').value = 'Test Migration';
  document.getElementById('downtimeDuration').value = '24';
  
  // CRITICAL FIX: Clear controller from Firebase to allow new hosts
  try {
    const presenceDocs = await window.firestore.getDocs(collection(db, "sessions", sessionContext.sessionKey, "presence"));
    for (const presenceDoc of presenceDocs.docs || []) {
      try {
        await window.firestore.deleteDoc(presenceDoc.ref);
      } catch (presenceError) {
        console.warn("Failed to remove presence entry during reset", presenceError);
      }
    }

    await window.firestore.deleteDoc(sessionRef);
    console.log("âœ“ Session reset, data cleared");
  } catch (e) {
    console.error("Failed to reset session:", e);
    // Still push the reset state even if Firebase update fails
    await pushState("reset");
  }
  
  // Reload to ensure clean state
  window.location.reload();
};

console.log("Firebase sync initialized - Mode:", window.canWrite() ? "HOST" : "VIEWER");
</script>

</body>
</html>
